; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	d:\downloads\tgl-master\tgl-master\zlib\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateMark@4
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN3@inflateRes
  0000a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 1e		 je	 SHORT $LN3@inflateRes

; 135  :     state = (struct inflate_state FAR *)strm->state;
; 136  :     state->wsize = 0;

  00011	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 137  :     state->whave = 0;

  00018	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 138  :     state->wnext = 0;

  0001f	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 139  :     return inflateResetKeep(strm);

  00026	89 45 08	 mov	 DWORD PTR _strm$[ebp], eax

; 140  : }

  00029	5d		 pop	 ebp

; 139  :     return inflateResetKeep(strm);

  0002a	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
$LN3@inflateRes:

; 132  :     struct inflate_state FAR *state;
; 133  : 
; 134  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 140  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  :     int ret;
; 187  :     struct inflate_state FAR *state;
; 188  : 
; 189  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 a3 00 00
	00		 je	 $LN3@inflateIni
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 9a 00 00
	00		 jne	 $LN3@inflateIni
  00017	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 90 00 00
	00		 jne	 $LN3@inflateIni

; 192  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 220  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 193  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 194  :     if (strm->zalloc == (alloc_func)0) {

  00031	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00035	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003c	75 0e		 jne	 SHORT $LN5@inflateIni

; 195  : #ifdef Z_SOLO
; 196  :         return Z_STREAM_ERROR;
; 197  : #else
; 198  :         strm->zalloc = zcalloc;

  0003e	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 199  :         strm->opaque = (voidpf)0;

  00045	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN5@inflateIni:

; 200  : #endif
; 201  :     }
; 202  :     if (strm->zfree == (free_func)0)

  0004c	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00050	75 07		 jne	 SHORT $LN6@inflateIni

; 203  : #ifdef Z_SOLO
; 204  :         return Z_STREAM_ERROR;
; 205  : #else
; 206  :         strm->zfree = zcfree;

  00052	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:

; 207  : #endif
; 208  :     state = (struct inflate_state FAR *)

  00059	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005c	57		 push	 edi
  0005d	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00062	6a 01		 push	 1
  00064	ff 76 28	 push	 DWORD PTR [esi+40]
  00067	ff d0		 call	 eax
  00069	8b f8		 mov	 edi, eax
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 210  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006e	85 ff		 test	 edi, edi
  00070	75 09		 jne	 SHORT $LN7@inflateIni
  00072	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 220  : }

  00077	5d		 pop	 ebp
  00078	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007b	53		 push	 ebx

; 211  :     Tracev((stderr, "inflate: allocated\n"));
; 212  :     strm->state = (struct internal_state FAR *)state;
; 213  :     state->window = Z_NULL;
; 214  :     ret = inflateReset2(strm, windowBits);

  0007c	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  0007f	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00082	56		 push	 esi
  00083	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
  0008a	e8 00 00 00 00	 call	 _inflateReset2@8
  0008f	8b d8		 mov	 ebx, eax

; 215  :     if (ret != Z_OK) {

  00091	85 db		 test	 ebx, ebx
  00093	74 13		 je	 SHORT $LN8@inflateIni

; 216  :         ZFREE(strm, state);

  00095	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00098	57		 push	 edi
  00099	ff 76 28	 push	 DWORD PTR [esi+40]
  0009c	ff d1		 call	 ecx
  0009e	83 c4 08	 add	 esp, 8

; 217  :         strm->state = Z_NULL;

  000a1	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 218  :     }
; 219  :     return ret;

  000a8	8b c3		 mov	 eax, ebx
  000aa	5b		 pop	 ebx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi

; 220  : }

  000ad	5d		 pop	 ebp
  000ae	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 190  :         stream_size != (int)(sizeof(z_stream)))
; 191  :         return Z_VERSION_ERROR;

  000b1	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 220  : }

  000b6	5d		 pop	 ebp
  000b7	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv2776 = -64						; size = 4
_in$1$ = -60						; size = 4
$T1 = -56						; size = 4
_copy$9$ = -56						; size = 4
tv2758 = -56						; size = 4
tv2717 = -56						; size = 4
tv2715 = -56						; size = 4
tv2704 = -56						; size = 4
tv2690 = -56						; size = 4
tv2666 = -56						; size = 4
tv2665 = -56						; size = 4
tv2620 = -56						; size = 4
_copy$7$ = -56						; size = 4
_copy$4$ = -56						; size = 4
_copy$3$ = -56						; size = 4
_copy$2$ = -56						; size = 4
_len$5$ = -56						; size = 4
_len$1$ = -56						; size = 4
_last$ = -56						; size = 4
_here$ = -56						; size = 4
_copy$11$ = -52						; size = 4
_copy$8$ = -52						; size = 4
tv2711 = -52						; size = 4
tv2710 = -52						; size = 4
tv2688 = -52						; size = 4
tv2664 = -52						; size = 4
_copy$1$ = -52						; size = 4
tv2779 = -48						; size = 4
_ret$1$ = -44						; size = 4
_from$1$ = -40						; size = 4
tv2786 = -40						; size = 4
tv2696 = -40						; size = 4
tv2687 = -40						; size = 4
tv2686 = -40						; size = 4
_len$4$ = -40						; size = 4
_len$3$ = -40						; size = 4
_len$2$ = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
tv2678 = -20						; size = 4
tv2677 = -20						; size = 4
_bits$1$ = -20						; size = 4
_next$1$ = -16						; size = 4
tv2713 = -12						; size = 4
_have$1$ = -12						; size = 4
_state$1$ = -8						; size = 4
_hold$1$ = -4						; size = 4
tv2648 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 609  :     struct inflate_state FAR *state;
; 610  :     z_const unsigned char FAR *next;    /* next input */
; 611  :     unsigned char FAR *put;     /* next output */
; 612  :     unsigned have, left;        /* available input and output */
; 613  :     unsigned long hold;         /* bit buffer */
; 614  :     unsigned bits;              /* bits in bit buffer */
; 615  :     unsigned in, out;           /* save starting available input and output */
; 616  :     unsigned copy;              /* number of stored or match bytes to copy */
; 617  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 618  :     code here;                  /* current decoding table entry */
; 619  :     code last;                  /* parent table entry */
; 620  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 621  :     int ret;                    /* return code */
; 622  : #ifdef GUNZIP
; 623  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 624  : #endif
; 625  :     static const unsigned short order[19] = /* permutation of code lengths */
; 626  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 627  : 
; 628  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 1e 16 00
	00		 je	 $LN333@inflate
  00011	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00014	89 4d f8	 mov	 DWORD PTR _state$1$[ebp], ecx
  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 10 16 00
	00		 je	 $LN333@inflate
  0001f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00023	0f 84 06 16 00
	00		 je	 $LN333@inflate
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	75 0a		 jne	 SHORT $LN332@inflate
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	0f 85 f7 15 00
	00		 jne	 $LN333@inflate
$LN332@inflate:

; 631  : 
; 632  :     state = (struct inflate_state FAR *)strm->state;
; 633  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00038	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  0003b	75 06		 jne	 SHORT $LN4@inflate
  0003d	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
$LN4@inflate:

; 634  :     LOAD();

  00043	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00046	53		 push	 ebx
  00047	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0004a	56		 push	 esi
  0004b	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  0004e	89 55 e0	 mov	 DWORD PTR _put$1$[ebp], edx
  00051	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00054	89 55 e8	 mov	 DWORD PTR _left$1$[ebp], edx
  00057	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0005a	57		 push	 edi
  0005b	8b 38		 mov	 edi, DWORD PTR [eax]

; 635  :     in = have;
; 636  :     out = left;

  0005d	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  00060	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax

; 637  :     ret = Z_OK;

  00063	33 c0		 xor	 eax, eax
  00065	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax

; 638  :     for (;;)
; 639  :         switch (state->mode) {

  00068	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0006d	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00070	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00073	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00076	89 5d c4	 mov	 DWORD PTR _in$1$[ebp], ebx
  00079	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0007c	0f 87 a5 0a 00
	00		 ja	 $LN498@inflate

; 938  :                 for (;;) {
; 939  :                     here = state->lencode[BITS(state->lenbits)];

  00082	8d 79 54	 lea	 edi, DWORD PTR [ecx+84]
  00085	89 7d d0	 mov	 DWORD PTR tv2779[ebp], edi

; 1080 :         case DIST:
; 1081 :             for (;;) {
; 1082 :                 here = state->distcode[BITS(state->distbits)];

  00088	8d 79 58	 lea	 edi, DWORD PTR [ecx+88]
  0008b	89 7d c0	 mov	 DWORD PTR tv2776[ebp], edi
  0008e	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
$LL5@inflate:

; 638  :     for (;;)
; 639  :         switch (state->mode) {

  00091	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN935@inflate[eax*4]
$LN335@inflate:

; 640  :         case HEAD:
; 641  :             if (state->wrap == 0) {

  00098	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0009b	89 45 c8	 mov	 DWORD PTR tv2758[ebp], eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 0b		 jne	 SHORT $LN12@inflate

; 642  :                 state->mode = TYPEDO;

  000a2	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH

; 643  :                 break;

  000a8	e9 6f 0a 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 644  :             }
; 645  :             NEEDBITS(16);

  000ad	83 fe 10	 cmp	 esi, 16			; 00000010H
  000b0	73 2d		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000b2	85 db		 test	 ebx, ebx
  000b4	0f 84 c0 04 00
	00		 je	 $LN886@inflate
  000ba	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000bd	8b ce		 mov	 ecx, esi
  000bf	d3 e0		 shl	 eax, cl
  000c1	83 c6 08	 add	 esi, 8
  000c4	4b		 dec	 ebx
  000c5	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000c8	03 d0		 add	 edx, eax
  000ca	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  000cd	47		 inc	 edi
  000ce	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  000d1	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  000d4	83 fe 10	 cmp	 esi, 16			; 00000010H
  000d7	72 d9		 jb	 SHORT $LL13@inflate
  000d9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000dc	8b 45 c8	 mov	 eax, DWORD PTR tv2758[ebp]
$LN10@inflate:

; 646  : #ifdef GUNZIP
; 647  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000df	a8 02		 test	 al, 2
  000e1	74 46		 je	 SHORT $LN338@inflate
  000e3	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000e9	75 3e		 jne	 SHORT $LN338@inflate

; 648  :                 state->check = crc32(0L, Z_NULL, 0);

  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	6a 00		 push	 0
  000f1	e8 00 00 00 00	 call	 _crc32@12
  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 649  :                 CRC2(state->check, hold);

  000f9	6a 02		 push	 2
  000fb	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  00101	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00104	8d 4d e4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00107	51		 push	 ecx
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _crc32@12
  0010e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 650  :                 INITBITS();

  00111	33 d2		 xor	 edx, edx
  00113	33 f6		 xor	 esi, esi
  00115	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00118	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0011b	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 651  :                 state->mode = FLAGS;

  0011e	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 652  :                 break;

  00124	e9 f3 09 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 653  :             }
; 654  :             state->flags = 0;           /* expect zlib header */
; 655  :             if (state->head != Z_NULL)

  00129	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0012c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00133	85 c0		 test	 eax, eax
  00135	74 07		 je	 SHORT $LN339@inflate

; 656  :                 state->head->done = -1;

  00137	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN339@inflate:

; 657  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  0013e	f6 41 08 01	 test	 BYTE PTR [ecx+8], 1
  00142	0f 84 c1 00 00
	00		 je	 $LN341@inflate
  00148	0f b6 ca	 movzx	 ecx, dl
  0014b	8b c2		 mov	 eax, edx
  0014d	c1 e1 08	 shl	 ecx, 8
  00150	33 d2		 xor	 edx, edx
  00152	c1 e8 08	 shr	 eax, 8
  00155	03 c1		 add	 eax, ecx
  00157	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0015c	f7 f1		 div	 ecx

; 668  :                 state->mode = BAD;

  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00161	85 d2		 test	 edx, edx
  00163	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00166	0f 85 9d 00 00
	00		 jne	 $LN341@inflate

; 665  :             }
; 666  :             if (BITS(4) != Z_DEFLATED) {

  0016c	8b c2		 mov	 eax, edx
  0016e	24 0f		 and	 al, 15			; 0000000fH
  00170	3c 08		 cmp	 al, 8
  00172	74 15		 je	 SHORT $LN26@inflate
$LN932@inflate:

; 667  :                 strm->msg = (char *)"unknown compression method";

  00174	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00177	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 668  :                 state->mode = BAD;

  0017e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 669  :                 break;

  00184	e9 93 09 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 670  :             }
; 671  :             DROPBITS(4);

  00189	c1 ea 04	 shr	 edx, 4
  0018c	83 ee 04	 sub	 esi, 4

; 672  :             len = BITS(4) + 8;

  0018f	8b c2		 mov	 eax, edx
  00191	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00194	83 e0 0f	 and	 eax, 15			; 0000000fH
  00197	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0019a	83 c0 08	 add	 eax, 8

; 673  :             if (state->wbits == 0)

  0019d	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  001a1	89 45 c8	 mov	 DWORD PTR _len$1$[ebp], eax
  001a4	75 49		 jne	 SHORT $LN343@inflate

; 674  :                 state->wbits = len;

  001a6	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$LN345@inflate:

; 679  :             }
; 680  :             state->dmax = 1U << len;

  001a9	8b 4d c8	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001ac	b8 01 00 00 00	 mov	 eax, 1
  001b1	d3 e0		 shl	 eax, cl
  001b3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 681  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 682  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001b6	6a 00		 push	 0
  001b8	6a 00		 push	 0
  001ba	6a 00		 push	 0
  001bc	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  001bf	e8 00 00 00 00	 call	 _adler32@12
  001c4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001c7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001ca	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001cd	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 683  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001d0	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001d3	c1 ea 08	 shr	 edx, 8
  001d6	f7 d2		 not	 edx
  001d8	83 e2 02	 and	 edx, 2
  001db	83 ca 09	 or	 edx, 9
  001de	89 11		 mov	 DWORD PTR [ecx], edx

; 684  :             INITBITS();

  001e0	33 d2		 xor	 edx, edx
  001e2	33 f6		 xor	 esi, esi
  001e4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  001e7	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 685  :             break;

  001ea	e9 2d 09 00 00	 jmp	 $LN8@inflate
$LN343@inflate:

; 675  :             else if (len > state->wbits) {

  001ef	3b 41 24	 cmp	 eax, DWORD PTR [ecx+36]
  001f2	76 b5		 jbe	 SHORT $LN345@inflate

; 676  :                 strm->msg = (char *)"invalid window size";

  001f4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001f7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 677  :                 state->mode = BAD;

  001fe	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 678  :                 break;

  00204	e9 13 09 00 00	 jmp	 $LN8@inflate
$LN341@inflate:

; 658  : #else
; 659  :             if (
; 660  : #endif
; 661  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 662  :                 strm->msg = (char *)"incorrect header check";

  00209	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0020c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 663  :                 state->mode = BAD;

  00213	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 664  :                 break;

  00219	e9 fe 08 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 686  : #ifdef GUNZIP
; 687  :         case FLAGS:
; 688  :             NEEDBITS(16);

  0021e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00221	73 2a		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00223	85 db		 test	 ebx, ebx
  00225	0f 84 4f 03 00
	00		 je	 $LN886@inflate
  0022b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0022e	8b ce		 mov	 ecx, esi
  00230	d3 e0		 shl	 eax, cl
  00232	83 c6 08	 add	 esi, 8
  00235	4b		 dec	 ebx
  00236	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00239	03 d0		 add	 edx, eax
  0023b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0023e	47		 inc	 edi
  0023f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00242	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00245	83 fe 10	 cmp	 esi, 16			; 00000010H
  00248	72 d9		 jb	 SHORT $LL33@inflate
  0024a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 689  :             state->flags = (int)(hold);

  0024d	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 690  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00250	80 fa 08	 cmp	 dl, 8
  00253	0f 85 1b ff ff
	ff		 jne	 $LN932@inflate

; 691  :                 strm->msg = (char *)"unknown compression method";
; 692  :                 state->mode = BAD;
; 693  :                 break;
; 694  :             }
; 695  :             if (state->flags & 0xe000) {

  00259	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  0025f	74 15		 je	 SHORT $LN349@inflate

; 696  :                 strm->msg = (char *)"unknown header flags set";

  00261	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00264	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  0026b	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00271	e9 a6 08 00 00	 jmp	 $LN8@inflate
$LN349@inflate:

; 697  :                 state->mode = BAD;
; 698  :                 break;
; 699  :             }
; 700  :             if (state->head != Z_NULL)

  00276	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  00279	85 f6		 test	 esi, esi
  0027b	74 0a		 je	 SHORT $LN350@inflate

; 701  :                 state->head->text = (int)((hold >> 8) & 1);

  0027d	8b c2		 mov	 eax, edx
  0027f	c1 e8 08	 shr	 eax, 8
  00282	83 e0 01	 and	 eax, 1
  00285	89 06		 mov	 DWORD PTR [esi], eax
$LN350@inflate:

; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00287	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0028e	74 1d		 je	 SHORT $LN39@inflate
  00290	6a 02		 push	 2
  00292	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00295	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00298	50		 push	 eax
  00299	ff 71 18	 push	 DWORD PTR [ecx+24]
  0029c	c1 ea 08	 shr	 edx, 8
  0029f	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  002a2	e8 00 00 00 00	 call	 _crc32@12
  002a7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002aa	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN39@inflate:

; 703  :             INITBITS();

  002ad	33 d2		 xor	 edx, edx

; 704  :             state->mode = TIME;

  002af	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
  002b5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002b8	33 f6		 xor	 esi, esi

; 705  :         case TIME:
; 706  :             NEEDBITS(32);

  002ba	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  002bc	83 fe 20	 cmp	 esi, 32			; 00000020H
  002bf	73 27		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  002c1	85 db		 test	 ebx, ebx
  002c3	0f 84 b1 02 00
	00		 je	 $LN886@inflate
  002c9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002cc	8b ce		 mov	 ecx, esi
  002ce	d3 e0		 shl	 eax, cl
  002d0	4b		 dec	 ebx
  002d1	03 d0		 add	 edx, eax
  002d3	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  002d6	47		 inc	 edi
  002d7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002da	83 c6 08	 add	 esi, 8
  002dd	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  002e0	83 fe 20	 cmp	 esi, 32			; 00000020H
  002e3	72 dc		 jb	 SHORT $LL47@inflate
  002e5	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 707  :             if (state->head != Z_NULL)

  002e8	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  002eb	85 c0		 test	 eax, eax
  002ed	74 03		 je	 SHORT $LN354@inflate

; 708  :                 state->head->time = hold;

  002ef	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN354@inflate:

; 709  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  002f2	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  002f9	74 2d		 je	 SHORT $LN53@inflate
  002fb	8b c2		 mov	 eax, edx
  002fd	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00300	c1 e8 08	 shr	 eax, 8
  00303	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00306	8b c2		 mov	 eax, edx
  00308	c1 e8 10	 shr	 eax, 16			; 00000010H
  0030b	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  0030e	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00311	6a 04		 push	 4
  00313	50		 push	 eax
  00314	ff 71 18	 push	 DWORD PTR [ecx+24]
  00317	c1 ea 18	 shr	 edx, 24			; 00000018H
  0031a	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  0031d	e8 00 00 00 00	 call	 _crc32@12
  00322	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00325	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN53@inflate:

; 710  :             INITBITS();

  00328	33 d2		 xor	 edx, edx

; 711  :             state->mode = OS;

  0032a	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3
  00330	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00333	33 f6		 xor	 esi, esi

; 712  :         case OS:
; 713  :             NEEDBITS(16);

  00335	eb 09		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  00337	83 fe 10	 cmp	 esi, 16			; 00000010H
  0033a	73 2b		 jae	 SHORT $LN58@inflate
  0033c	0f 1f 40 00	 npad	 4
$LL61@inflate:
  00340	85 db		 test	 ebx, ebx
  00342	0f 84 32 02 00
	00		 je	 $LN886@inflate
  00348	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0034b	8b ce		 mov	 ecx, esi
  0034d	d3 e0		 shl	 eax, cl
  0034f	4b		 dec	 ebx
  00350	03 d0		 add	 edx, eax
  00352	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00355	47		 inc	 edi
  00356	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00359	83 c6 08	 add	 esi, 8
  0035c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0035f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00362	72 dc		 jb	 SHORT $LL61@inflate
  00364	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 714  :             if (state->head != Z_NULL) {

  00367	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  0036a	85 f6		 test	 esi, esi
  0036c	74 17		 je	 SHORT $LN358@inflate

; 715  :                 state->head->xflags = (int)(hold & 0xff);

  0036e	0f b6 c2	 movzx	 eax, dl

; 716  :                 state->head->os = (int)(hold >> 8);

  00371	8b ca		 mov	 ecx, edx
  00373	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00376	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00379	c1 e9 08	 shr	 ecx, 8
  0037c	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0037f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00382	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN358@inflate:

; 717  :             }
; 718  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00385	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0038c	74 1d		 je	 SHORT $LN67@inflate
  0038e	6a 02		 push	 2
  00390	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00393	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00396	50		 push	 eax
  00397	ff 71 18	 push	 DWORD PTR [ecx+24]
  0039a	c1 ea 08	 shr	 edx, 8
  0039d	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  003a0	e8 00 00 00 00	 call	 _crc32@12
  003a5	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003a8	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN67@inflate:

; 719  :             INITBITS();

  003ab	33 d2		 xor	 edx, edx

; 720  :             state->mode = EXLEN;

  003ad	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
  003b3	33 f6		 xor	 esi, esi
  003b5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  003b8	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN360@inflate:

; 721  :         case EXLEN:
; 722  :             if (state->flags & 0x0400) {

  003bb	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  003c2	74 74		 je	 SHORT $LN361@inflate

; 723  :                 NEEDBITS(16);

  003c4	83 fe 10	 cmp	 esi, 16			; 00000010H
  003c7	73 2e		 jae	 SHORT $LN72@inflate
  003c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL75@inflate:
  003d0	85 db		 test	 ebx, ebx
  003d2	0f 84 a2 01 00
	00		 je	 $LN886@inflate
  003d8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  003db	8b ce		 mov	 ecx, esi
  003dd	d3 e0		 shl	 eax, cl
  003df	4b		 dec	 ebx
  003e0	03 d0		 add	 edx, eax
  003e2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  003e5	47		 inc	 edi
  003e6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  003e9	83 c6 08	 add	 esi, 8
  003ec	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  003ef	83 fe 10	 cmp	 esi, 16			; 00000010H
  003f2	72 dc		 jb	 SHORT $LL75@inflate
  003f4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 724  :                 state->length = (unsigned)(hold);
; 725  :                 if (state->head != Z_NULL)

  003f7	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  003fa	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  003fd	85 c0		 test	 eax, eax
  003ff	74 03		 je	 SHORT $LN364@inflate

; 726  :                     state->head->extra_len = (unsigned)hold;

  00401	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN364@inflate:

; 727  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  00404	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0040b	74 1d		 je	 SHORT $LN81@inflate
  0040d	6a 02		 push	 2
  0040f	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00412	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00415	50		 push	 eax
  00416	ff 71 18	 push	 DWORD PTR [ecx+24]
  00419	c1 ea 08	 shr	 edx, 8
  0041c	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  0041f	e8 00 00 00 00	 call	 _crc32@12
  00424	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00427	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN81@inflate:

; 728  :                 INITBITS();

  0042a	33 f6		 xor	 esi, esi
  0042c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00433	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 729  :             }

  00436	eb 0e		 jmp	 SHORT $LN366@inflate
$LN361@inflate:

; 730  :             else if (state->head != Z_NULL)

  00438	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0043b	85 c0		 test	 eax, eax
  0043d	74 07		 je	 SHORT $LN366@inflate

; 731  :                 state->head->extra = Z_NULL;

  0043f	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN366@inflate:

; 732  :             state->mode = EXTRA;

  00446	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN367@inflate:

; 733  :         case EXTRA:
; 734  :             if (state->flags & 0x0400) {

  0044c	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  00453	0f 84 8d 00 00
	00		 je	 $LN373@inflate

; 735  :                 copy = state->length;

  00459	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 736  :                 if (copy > have) copy = have;

  0045c	3b c3		 cmp	 eax, ebx
  0045e	8b d0		 mov	 edx, eax
  00460	89 45 cc	 mov	 DWORD PTR _copy$1$[ebp], eax
  00463	0f 47 d3	 cmova	 edx, ebx
  00466	89 55 c8	 mov	 DWORD PTR _copy$2$[ebp], edx

; 737  :                 if (copy) {

  00469	85 d2		 test	 edx, edx
  0046b	74 6f		 je	 SHORT $LN370@inflate

; 738  :                     if (state->head != Z_NULL &&

  0046d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00470	85 c0		 test	 eax, eax
  00472	74 3f		 je	 SHORT $LN371@inflate
  00474	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  00477	85 ff		 test	 edi, edi
  00479	89 7d f4	 mov	 DWORD PTR tv2713[ebp], edi
  0047c	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  0047f	74 32		 je	 SHORT $LN371@inflate

; 739  :                         state->head->extra != Z_NULL) {
; 740  :                         len = state->head->extra_len - state->length;

  00481	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00484	2b 4d cc	 sub	 ecx, DWORD PTR _copy$1$[ebp]
  00487	89 4d d8	 mov	 DWORD PTR _len$2$[ebp], ecx

; 741  :                         zmemcpy(state->head->extra + len, next,

  0048a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0048d	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  00490	03 c2		 add	 eax, edx
  00492	3b c1		 cmp	 eax, ecx
  00494	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  00497	76 04		 jbe	 SHORT $LN508@inflate
  00499	2b c8		 sub	 ecx, eax
  0049b	eb 02		 jmp	 SHORT $LN509@inflate
$LN508@inflate:
  0049d	8b ca		 mov	 ecx, edx
$LN509@inflate:
  0049f	03 45 f4	 add	 eax, DWORD PTR tv2713[ebp]
  004a2	51		 push	 ecx
  004a3	57		 push	 edi
  004a4	50		 push	 eax
  004a5	e8 00 00 00 00	 call	 _memcpy
  004aa	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b0	8b 55 c8	 mov	 edx, DWORD PTR _copy$2$[ebp]
$LN371@inflate:

; 742  :                                 len + copy > state->head->extra_max ?
; 743  :                                 state->head->extra_max - len : copy);
; 744  :                     }
; 745  :                     if (state->flags & 0x0200)

  004b3	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  004ba	74 10		 je	 SHORT $LN372@inflate

; 746  :                         state->check = crc32(state->check, next, copy);

  004bc	52		 push	 edx
  004bd	57		 push	 edi
  004be	ff 71 18	 push	 DWORD PTR [ecx+24]
  004c1	e8 00 00 00 00	 call	 _crc32@12
  004c6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004c9	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN372@inflate:

; 747  :                     have -= copy;

  004cc	8b 45 c8	 mov	 eax, DWORD PTR _copy$2$[ebp]
  004cf	2b d8		 sub	 ebx, eax

; 748  :                     next += copy;

  004d1	03 f8		 add	 edi, eax
  004d3	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 749  :                     state->length -= copy;

  004d6	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  004d9	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
$LN370@inflate:

; 750  :                 }
; 751  :                 if (state->length) goto inf_leave;

  004dc	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  004e0	0f 85 94 00 00
	00		 jne	 $LN886@inflate
$LN373@inflate:

; 752  :             }
; 753  :             state->length = 0;

  004e6	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 754  :             state->mode = NAME;

  004ed	c7 01 06 00 00
	00		 mov	 DWORD PTR [ecx], 6
$LN374@inflate:

; 755  :         case NAME:
; 756  :             if (state->flags & 0x0800) {

  004f3	f7 41 10 00 08
	00 00		 test	 DWORD PTR [ecx+16], 2048 ; 00000800H
  004fa	0f 84 fd 00 00
	00		 je	 $LN375@inflate

; 757  :                 if (have == 0) goto inf_leave;

  00500	85 db		 test	 ebx, ebx
  00502	74 76		 je	 SHORT $LN886@inflate

; 758  :                 copy = 0;

  00504	33 d2		 xor	 edx, edx
$LL88@inflate:

; 759  :                 do {
; 760  :                     len = (unsigned)(next[copy++]);

  00506	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  0050a	42		 inc	 edx
  0050b	89 45 d8	 mov	 DWORD PTR _len$3$[ebp], eax

; 761  :                     if (state->head != Z_NULL &&
; 762  :                             state->head->name != Z_NULL &&

  0050e	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00511	85 c0		 test	 eax, eax
  00513	74 23		 je	 SHORT $LN86@inflate
  00515	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00518	89 75 cc	 mov	 DWORD PTR tv2711[ebp], esi
  0051b	85 f6		 test	 esi, esi
  0051d	74 19		 je	 SHORT $LN86@inflate
  0051f	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00522	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00525	73 11		 jae	 SHORT $LN86@inflate

; 763  :                             state->length < state->head->name_max)
; 764  :                         state->head->name[state->length++] = len;

  00527	8b 5d d8	 mov	 ebx, DWORD PTR _len$3$[ebp]
  0052a	8b c6		 mov	 eax, esi
  0052c	8b 75 cc	 mov	 esi, DWORD PTR tv2711[ebp]
  0052f	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  00532	ff 41 40	 inc	 DWORD PTR [ecx+64]
  00535	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN86@inflate:

; 765  :                 } while (len && copy < have);

  00538	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
  0053b	85 c0		 test	 eax, eax
  0053d	74 04		 je	 SHORT $LN379@inflate
  0053f	3b d3		 cmp	 edx, ebx
  00541	72 c3		 jb	 SHORT $LL88@inflate
$LN379@inflate:

; 766  :                 if (state->flags & 0x0200)

  00543	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0054a	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  0054d	89 55 c8	 mov	 DWORD PTR _copy$3$[ebp], edx
  00550	74 16		 je	 SHORT $LN380@inflate

; 767  :                     state->check = crc32(state->check, next, copy);

  00552	52		 push	 edx
  00553	57		 push	 edi
  00554	ff 71 18	 push	 DWORD PTR [ecx+24]
  00557	e8 00 00 00 00	 call	 _crc32@12
  0055c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0055f	8b 55 c8	 mov	 edx, DWORD PTR _copy$3$[ebp]
  00562	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00565	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
$LN380@inflate:

; 768  :                 have -= copy;

  00568	2b da		 sub	 ebx, edx

; 769  :                 next += copy;

  0056a	03 fa		 add	 edi, edx
  0056c	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0056f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 770  :                 if (len) goto inf_leave;

  00572	85 c0		 test	 eax, eax
  00574	0f 84 91 00 00
	00		 je	 $LN382@inflate
$LN886@inflate:
  0057a	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN896@inflate:
  0057d	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$937:

; 1222 :         }
; 1223 : 
; 1224 :     /*
; 1225 :        Return from inflate(), updating the total counts and the check value.
; 1226 :        If there was no progress during the inflate() call, return a buffer
; 1227 :        error.  Call updatewindow() to create and/or update the window state.
; 1228 :        Note: a memory error from inflate() is non-recoverable.
; 1229 :      */
; 1230 :   inf_leave:
; 1231 :     RESTORE();

  00580	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00583	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  00586	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00589	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  0058c	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  0058f	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00592	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  00595	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00598	8b 45 fc	 mov	 eax, DWORD PTR _hold$1$[ebp]
  0059b	89 0f		 mov	 DWORD PTR [edi], ecx

; 1232 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  0059d	83 7b 28 00	 cmp	 DWORD PTR [ebx+40], 0
  005a1	89 73 3c	 mov	 DWORD PTR [ebx+60], esi
  005a4	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  005a7	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  005aa	75 22		 jne	 SHORT $LN501@inflate
  005ac	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  005af	0f 84 c9 0f 00
	00		 je	 $LN502@inflate
  005b5	8b 03		 mov	 eax, DWORD PTR [ebx]
  005b7	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  005ba	0f 8d be 0f 00
	00		 jge	 $LN502@inflate
  005c0	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  005c3	7c 09		 jl	 SHORT $LN501@inflate
  005c5	83 fa 04	 cmp	 edx, 4
  005c8	0f 84 b0 0f 00
	00		 je	 $LN502@inflate
$LN501@inflate:

; 1233 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1234 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  005ce	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  005d1	8b c6		 mov	 eax, esi
  005d3	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  005d6	8b cf		 mov	 ecx, edi
  005d8	50		 push	 eax
  005d9	e8 00 00 00 00	 call	 _updatewindow
  005de	83 c4 04	 add	 esp, 4
  005e1	85 c0		 test	 eax, eax
  005e3	0f 84 95 0f 00
	00		 je	 $LN502@inflate

; 1235 :             state->mode = MEM;

  005e9	c7 03 1e 00 00
	00		 mov	 DWORD PTR [ebx], 30	; 0000001eH
$LN497@inflate:
  005ef	5f		 pop	 edi
  005f0	5e		 pop	 esi

; 1236 :             return Z_MEM_ERROR;

  005f1	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  005f6	5b		 pop	 ebx

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  005f7	8b e5		 mov	 esp, ebp
  005f9	5d		 pop	 ebp
  005fa	c2 08 00	 ret	 8
$LN375@inflate:

; 771  :             }
; 772  :             else if (state->head != Z_NULL)

  005fd	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00600	85 c0		 test	 eax, eax
  00602	74 07		 je	 SHORT $LN382@inflate

; 773  :                 state->head->name = Z_NULL;

  00604	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN382@inflate:

; 774  :             state->length = 0;

  0060b	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 775  :             state->mode = COMMENT;

  00612	c7 01 07 00 00
	00		 mov	 DWORD PTR [ecx], 7
$LN383@inflate:

; 776  :         case COMMENT:
; 777  :             if (state->flags & 0x1000) {

  00618	f7 41 10 00 10
	00 00		 test	 DWORD PTR [ecx+16], 4096 ; 00001000H
  0061f	0f 84 81 00 00
	00		 je	 $LN384@inflate

; 778  :                 if (have == 0) goto inf_leave;

  00625	85 db		 test	 ebx, ebx
  00627	0f 84 4d ff ff
	ff		 je	 $LN886@inflate

; 779  :                 copy = 0;

  0062d	33 d2		 xor	 edx, edx
  0062f	90		 npad	 1
$LL91@inflate:

; 780  :                 do {
; 781  :                     len = (unsigned)(next[copy++]);

  00630	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00634	42		 inc	 edx
  00635	89 45 d8	 mov	 DWORD PTR _len$4$[ebp], eax

; 782  :                     if (state->head != Z_NULL &&
; 783  :                             state->head->comment != Z_NULL &&

  00638	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0063b	85 c0		 test	 eax, eax
  0063d	74 23		 je	 SHORT $LN89@inflate
  0063f	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00642	89 75 cc	 mov	 DWORD PTR tv2710[ebp], esi
  00645	85 f6		 test	 esi, esi
  00647	74 19		 je	 SHORT $LN89@inflate
  00649	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  0064c	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  0064f	73 11		 jae	 SHORT $LN89@inflate

; 784  :                             state->length < state->head->comm_max)
; 785  :                         state->head->comment[state->length++] = len;

  00651	8b 5d d8	 mov	 ebx, DWORD PTR _len$4$[ebp]
  00654	8b c6		 mov	 eax, esi
  00656	8b 75 cc	 mov	 esi, DWORD PTR tv2710[ebp]
  00659	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  0065c	ff 41 40	 inc	 DWORD PTR [ecx+64]
  0065f	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN89@inflate:

; 786  :                 } while (len && copy < have);

  00662	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
  00665	85 c0		 test	 eax, eax
  00667	74 04		 je	 SHORT $LN388@inflate
  00669	3b d3		 cmp	 edx, ebx
  0066b	72 c3		 jb	 SHORT $LL91@inflate
$LN388@inflate:

; 787  :                 if (state->flags & 0x0200)

  0066d	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00674	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  00677	89 55 c8	 mov	 DWORD PTR _copy$4$[ebp], edx
  0067a	74 16		 je	 SHORT $LN389@inflate

; 788  :                     state->check = crc32(state->check, next, copy);

  0067c	52		 push	 edx
  0067d	57		 push	 edi
  0067e	ff 71 18	 push	 DWORD PTR [ecx+24]
  00681	e8 00 00 00 00	 call	 _crc32@12
  00686	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00689	8b 55 c8	 mov	 edx, DWORD PTR _copy$4$[ebp]
  0068c	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0068f	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
$LN389@inflate:

; 789  :                 have -= copy;

  00692	2b da		 sub	 ebx, edx

; 790  :                 next += copy;

  00694	03 fa		 add	 edi, edx
  00696	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00699	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 791  :                 if (len) goto inf_leave;

  0069c	85 c0		 test	 eax, eax
  0069e	0f 85 d6 fe ff
	ff		 jne	 $LN886@inflate

; 792  :             }

  006a4	eb 0e		 jmp	 SHORT $LN391@inflate
$LN384@inflate:

; 793  :             else if (state->head != Z_NULL)

  006a6	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  006a9	85 c0		 test	 eax, eax
  006ab	74 07		 je	 SHORT $LN391@inflate

; 794  :                 state->head->comment = Z_NULL;

  006ad	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN391@inflate:
  006b4	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 795  :             state->mode = HCRC;

  006b7	c7 01 08 00 00
	00		 mov	 DWORD PTR [ecx], 8
$LN392@inflate:

; 796  :         case HCRC:
; 797  :             if (state->flags & 0x0200) {

  006bd	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  006c4	74 5d		 je	 SHORT $LN101@inflate

; 798  :                 NEEDBITS(16);

  006c6	83 fe 10	 cmp	 esi, 16			; 00000010H
  006c9	73 2f		 jae	 SHORT $LN92@inflate
  006cb	0f 1f 44 00 00	 npad	 5
$LL95@inflate:
  006d0	85 db		 test	 ebx, ebx
  006d2	0f 84 a2 fe ff
	ff		 je	 $LN886@inflate
  006d8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  006db	8b ce		 mov	 ecx, esi
  006dd	d3 e0		 shl	 eax, cl
  006df	83 c6 08	 add	 esi, 8
  006e2	4b		 dec	 ebx
  006e3	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  006e6	03 d0		 add	 edx, eax
  006e8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  006eb	47		 inc	 edi
  006ec	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  006ef	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  006f2	83 fe 10	 cmp	 esi, 16			; 00000010H
  006f5	72 d9		 jb	 SHORT $LL95@inflate
  006f7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 799  :                 if (hold != (state->check & 0xffff)) {

  006fa	0f b7 41 18	 movzx	 eax, WORD PTR [ecx+24]
  006fe	3b d0		 cmp	 edx, eax
  00700	74 15		 je	 SHORT $LN102@inflate

; 800  :                     strm->msg = (char *)"header crc mismatch";

  00702	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00705	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  0070c	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00712	e9 05 04 00 00	 jmp	 $LN8@inflate
$LN102@inflate:

; 801  :                     state->mode = BAD;
; 802  :                     break;
; 803  :                 }
; 804  :                 INITBITS();

  00717	33 f6		 xor	 esi, esi
  00719	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00720	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 805  :             }
; 806  :             if (state->head != Z_NULL) {

  00723	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00726	85 d2		 test	 edx, edx
  00728	74 16		 je	 SHORT $LN396@inflate

; 807  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  0072a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0072d	c1 f8 09	 sar	 eax, 9
  00730	83 e0 01	 and	 eax, 1
  00733	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 808  :                 state->head->done = 1;

  00736	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00739	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN396@inflate:

; 809  :             }
; 810  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00740	6a 00		 push	 0
  00742	6a 00		 push	 0
  00744	6a 00		 push	 0
  00746	e8 00 00 00 00	 call	 _crc32@12
  0074b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0074e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00751	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00754	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 811  :             state->mode = TYPE;

  00757	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 812  :             break;

  0075d	e9 b7 03 00 00	 jmp	 $LN887@inflate
$LN105@inflate:

; 813  : #endif
; 814  :         case DICTID:
; 815  :             NEEDBITS(32);

  00762	83 fe 20	 cmp	 esi, 32			; 00000020H
  00765	73 24		 jae	 SHORT $LN103@inflate
$LL106@inflate:
  00767	85 db		 test	 ebx, ebx
  00769	0f 84 0b fe ff
	ff		 je	 $LN886@inflate
  0076f	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00772	8b ce		 mov	 ecx, esi
  00774	d3 e0		 shl	 eax, cl
  00776	4b		 dec	 ebx
  00777	03 d0		 add	 edx, eax
  00779	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0077c	47		 inc	 edi
  0077d	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00780	83 c6 08	 add	 esi, 8
  00783	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00786	83 fe 20	 cmp	 esi, 32			; 00000020H
  00789	72 dc		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 816  :             strm->adler = state->check = ZSWAP32(hold);

  0078b	8b ca		 mov	 ecx, edx
  0078d	8b c2		 mov	 eax, edx
  0078f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00792	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00798	03 c8		 add	 ecx, eax
  0079a	8b c2		 mov	 eax, edx
  0079c	c1 e8 08	 shr	 eax, 8
  0079f	c1 e1 08	 shl	 ecx, 8
  007a2	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007a7	c1 ea 18	 shr	 edx, 24			; 00000018H
  007aa	03 c1		 add	 eax, ecx
  007ac	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007af	03 c2		 add	 eax, edx
  007b1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007b4	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  007b7	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 817  :             INITBITS();

  007ba	33 d2		 xor	 edx, edx
  007bc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  007bf	33 f6		 xor	 esi, esi

; 818  :             state->mode = DICT;

  007c1	c7 01 0a 00 00
	00		 mov	 DWORD PTR [ecx], 10	; 0000000aH
$LN399@inflate:

; 819  :         case DICT:
; 820  :             if (state->havedict == 0) {

  007c7	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  007cb	0f 84 53 0d 00
	00		 je	 $LN585@inflate

; 823  :             }
; 824  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  007d1	6a 00		 push	 0
  007d3	6a 00		 push	 0
  007d5	6a 00		 push	 0
  007d7	e8 00 00 00 00	 call	 _adler32@12
  007dc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007df	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007e2	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  007e5	89 42 30	 mov	 DWORD PTR [edx+48], eax
  007e8	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 825  :             state->mode = TYPE;

  007eb	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH
$LN401@inflate:

; 826  :         case TYPE:
; 827  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  007f1	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  007f4	83 f8 05	 cmp	 eax, 5
  007f7	0f 84 7d fd ff
	ff		 je	 $LN886@inflate
  007fd	83 f8 06	 cmp	 eax, 6
  00800	0f 84 74 fd ff
	ff		 je	 $LN886@inflate
$LN402@inflate:

; 828  :         case TYPEDO:
; 829  :             if (state->last) {

  00806	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0080a	74 1d		 je	 SHORT $LN122@inflate

; 830  :                 BYTEBITS();

  0080c	8b ce		 mov	 ecx, esi
  0080e	83 e1 07	 and	 ecx, 7
  00811	d3 ea		 shr	 edx, cl
  00813	2b f1		 sub	 esi, ecx

; 831  :                 state->mode = CHECK;

  00815	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00818	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0081b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0081e	c7 01 1a 00 00
	00		 mov	 DWORD PTR [ecx], 26	; 0000001aH

; 832  :                 break;

  00824	e9 f3 02 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 833  :             }
; 834  :             NEEDBITS(3);

  00829	83 fe 03	 cmp	 esi, 3
  0082c	73 29		 jae	 SHORT $LN120@inflate
  0082e	66 90		 npad	 2
$LL123@inflate:
  00830	85 db		 test	 ebx, ebx
  00832	0f 84 42 fd ff
	ff		 je	 $LN886@inflate
  00838	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0083b	8b ce		 mov	 ecx, esi
  0083d	d3 e0		 shl	 eax, cl
  0083f	4b		 dec	 ebx
  00840	03 d0		 add	 edx, eax
  00842	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00845	47		 inc	 edi
  00846	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00849	83 c6 08	 add	 esi, 8
  0084c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0084f	83 fe 03	 cmp	 esi, 3
  00852	72 dc		 jb	 SHORT $LL123@inflate
  00854	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 835  :             state->last = BITS(1);

  00857	8b c2		 mov	 eax, edx

; 836  :             DROPBITS(1);

  00859	d1 ea		 shr	 edx, 1
  0085b	83 e0 01	 and	 eax, 1
  0085e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 837  :             switch (BITS(2)) {

  00861	8b c2		 mov	 eax, edx
  00863	83 e0 03	 and	 eax, 3
  00866	83 f8 03	 cmp	 eax, 3
  00869	77 64		 ja	 SHORT $LN138@inflate
  0086b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN936@inflate[eax*4]
$LN407@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  00872	c1 ea 02	 shr	 edx, 2
  00875	83 ee 03	 sub	 esi, 3
  00878	c7 01 0d 00 00
	00		 mov	 DWORD PTR [ecx], 13	; 0000000dH
  0087e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00881	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 863  :             break;

  00884	e9 93 02 00 00	 jmp	 $LN8@inflate
$LN408@inflate:

; 838  :             case 0:                             /* stored block */
; 839  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 840  :                         state->last ? " (last)" : ""));
; 841  :                 state->mode = STORED;
; 842  :                 break;
; 843  :             case 1:                             /* fixed block */
; 844  :                 fixedtables(state);

  00889	e8 00 00 00 00	 call	 _fixedtables

; 845  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 846  :                         state->last ? " (last)" : ""));
; 847  :                 state->mode = LEN_;             /* decode codes */
; 848  :                 if (flush == Z_TREES) {

  0088e	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00892	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00898	75 35		 jne	 SHORT $LN138@inflate

; 849  :                     DROPBITS(2);

  0089a	c1 ea 02	 shr	 edx, 2
  0089d	83 ee 03	 sub	 esi, 3
  008a0	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 850  :                     goto inf_leave;

  008a3	e9 d2 fc ff ff	 jmp	 $LN886@inflate
$LN410@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  008a8	c1 ea 02	 shr	 edx, 2
  008ab	83 ee 03	 sub	 esi, 3
  008ae	c7 01 10 00 00
	00		 mov	 DWORD PTR [ecx], 16	; 00000010H
  008b4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008b7	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 863  :             break;

  008ba	e9 5d 02 00 00	 jmp	 $LN8@inflate
$LN411@inflate:

; 851  :                 }
; 852  :                 break;
; 853  :             case 2:                             /* dynamic block */
; 854  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 855  :                         state->last ? " (last)" : ""));
; 856  :                 state->mode = TABLE;
; 857  :                 break;
; 858  :             case 3:
; 859  :                 strm->msg = (char *)"invalid block type";

  008bf	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  008c2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 860  :                 state->mode = BAD;

  008c9	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN138@inflate:

; 861  :             }
; 862  :             DROPBITS(2);

  008cf	c1 ea 02	 shr	 edx, 2
  008d2	83 ee 03	 sub	 esi, 3
  008d5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008d8	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 863  :             break;

  008db	e9 3c 02 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 864  :         case STORED:
; 865  :             BYTEBITS();                         /* go to byte boundary */

  008e0	8b ce		 mov	 ecx, esi
  008e2	83 e1 07	 and	 ecx, 7
  008e5	2b f1		 sub	 esi, ecx
  008e7	d3 ea		 shr	 edx, cl
  008e9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008ec	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 866  :             NEEDBITS(32);

  008ef	83 fe 20	 cmp	 esi, 32			; 00000020H
  008f2	73 27		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  008f4	85 db		 test	 ebx, ebx
  008f6	0f 84 7e fc ff
	ff		 je	 $LN886@inflate
  008fc	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  008ff	8b ce		 mov	 ecx, esi
  00901	d3 e0		 shl	 eax, cl
  00903	83 c6 08	 add	 esi, 8
  00906	4b		 dec	 ebx
  00907	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0090a	03 d0		 add	 edx, eax
  0090c	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0090f	47		 inc	 edi
  00910	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00913	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00916	83 fe 20	 cmp	 esi, 32			; 00000020H
  00919	72 d9		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 867  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0091b	8b c2		 mov	 eax, edx
  0091d	0f b7 ca	 movzx	 ecx, dx
  00920	f7 d0		 not	 eax
  00922	89 4d c8	 mov	 DWORD PTR tv2704[ebp], ecx
  00925	c1 e8 10	 shr	 eax, 16			; 00000010H
  00928	3b c8		 cmp	 ecx, eax

; 869  :                 state->mode = BAD;

  0092a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0092d	74 15		 je	 SHORT $LN414@inflate

; 868  :                 strm->msg = (char *)"invalid stored block lengths";

  0092f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00932	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  00939	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  0093f	e9 d8 01 00 00	 jmp	 $LN8@inflate
$LN414@inflate:

; 870  :                 break;
; 871  :             }
; 872  :             state->length = (unsigned)hold & 0xffff;

  00944	8b 45 c8	 mov	 eax, DWORD PTR tv2704[ebp]

; 873  :             Tracev((stderr, "inflate:       stored length %u\n",
; 874  :                     state->length));
; 875  :             INITBITS();

  00947	33 d2		 xor	 edx, edx
  00949	33 f6		 xor	 esi, esi
  0094b	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 876  :             state->mode = COPY_;
; 877  :             if (flush == Z_TREES) goto inf_leave;

  0094e	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00952	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00955	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00958	c7 01 0e 00 00
	00		 mov	 DWORD PTR [ecx], 14	; 0000000eH
  0095e	0f 84 16 fc ff
	ff		 je	 $LN886@inflate
$LN415@inflate:

; 878  :         case COPY_:
; 879  :             state->mode = COPY;

  00964	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$LN417@inflate:

; 880  :         case COPY:
; 881  :             copy = state->length;

  0096a	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 882  :             if (copy) {

  0096d	85 c0		 test	 eax, eax
  0096f	0f 84 ee 06 00
	00		 je	 $LN418@inflate

; 883  :                 if (copy > have) copy = have;

  00975	3b c3		 cmp	 eax, ebx
  00977	0f 47 c3	 cmova	 eax, ebx

; 884  :                 if (copy > left) copy = left;

  0097a	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  0097d	0f 47 45 e8	 cmova	 eax, DWORD PTR _left$1$[ebp]
  00981	89 45 c8	 mov	 DWORD PTR _copy$7$[ebp], eax

; 885  :                 if (copy == 0) goto inf_leave;

  00984	85 c0		 test	 eax, eax
  00986	0f 84 ee fb ff
	ff		 je	 $LN886@inflate

; 886  :                 zmemcpy(put, next, copy);

  0098c	50		 push	 eax
  0098d	57		 push	 edi
  0098e	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  00991	e8 00 00 00 00	 call	 _memcpy

; 887  :                 have -= copy;

  00996	8b 45 c8	 mov	 eax, DWORD PTR _copy$7$[ebp]
  00999	83 c4 0c	 add	 esp, 12			; 0000000cH

; 888  :                 next += copy;
; 889  :                 left -= copy;
; 890  :                 put += copy;
; 891  :                 state->length -= copy;

  0099c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0099f	2b d8		 sub	 ebx, eax
  009a1	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  009a4	03 f8		 add	 edi, eax
  009a6	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax
  009a9	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  009ac	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  009af	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 892  :                 break;

  009b2	e9 62 01 00 00	 jmp	 $LN887@inflate
$LN155@inflate:

; 893  :             }
; 894  :             Tracev((stderr, "inflate:       stored end\n"));
; 895  :             state->mode = TYPE;
; 896  :             break;
; 897  :         case TABLE:
; 898  :             NEEDBITS(14);

  009b7	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  009ba	73 2b		 jae	 SHORT $LN153@inflate
  009bc	0f 1f 40 00	 npad	 4
$LL156@inflate:
  009c0	85 db		 test	 ebx, ebx
  009c2	0f 84 b2 fb ff
	ff		 je	 $LN886@inflate
  009c8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  009cb	8b ce		 mov	 ecx, esi
  009cd	d3 e0		 shl	 eax, cl
  009cf	4b		 dec	 ebx
  009d0	03 d0		 add	 edx, eax
  009d2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  009d5	47		 inc	 edi
  009d6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  009d9	83 c6 08	 add	 esi, 8
  009dc	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  009df	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  009e2	72 dc		 jb	 SHORT $LL156@inflate
  009e4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN153@inflate:

; 899  :             state->nlen = BITS(5) + 257;

  009e7	8b c2		 mov	 eax, edx

; 900  :             DROPBITS(5);
; 901  :             state->ndist = BITS(5) + 1;
; 902  :             DROPBITS(5);
; 903  :             state->ncode = BITS(4) + 4;
; 904  :             DROPBITS(4);

  009e9	83 ee 0e	 sub	 esi, 14			; 0000000eH
  009ec	83 e0 1f	 and	 eax, 31			; 0000001fH
  009ef	c1 ea 05	 shr	 edx, 5
  009f2	05 01 01 00 00	 add	 eax, 257		; 00000101H
  009f7	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009fa	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  009fd	8b c2		 mov	 eax, edx
  009ff	83 e0 1f	 and	 eax, 31			; 0000001fH
  00a02	c1 ea 05	 shr	 edx, 5
  00a05	40		 inc	 eax
  00a06	89 41 64	 mov	 DWORD PTR [ecx+100], eax
  00a09	8b c2		 mov	 eax, edx
  00a0b	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a0e	c1 ea 04	 shr	 edx, 4
  00a11	83 c0 04	 add	 eax, 4
  00a14	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 905  : #ifndef PKZIP_BUG_WORKAROUND
; 906  :             if (state->nlen > 286 || state->ndist > 30) {

  00a17	81 79 60 1e 01
	00 00		 cmp	 DWORD PTR [ecx+96], 286	; 0000011eH
  00a1e	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
  00a21	0f 87 0e 01 00
	00		 ja	 $LN425@inflate
  00a27	83 79 64 1e	 cmp	 DWORD PTR [ecx+100], 30	; 0000001eH
  00a2b	0f 87 04 01 00
	00		 ja	 $LN425@inflate

; 908  :                 state->mode = BAD;
; 909  :                 break;
; 910  :             }
; 911  : #endif
; 912  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 913  :             state->have = 0;

  00a31	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 914  :             state->mode = LENLENS;

  00a38	c7 01 11 00 00
	00		 mov	 DWORD PTR [ecx], 17	; 00000011H
$LN531@inflate:

; 915  :         case LENLENS:
; 916  :             while (state->have < state->ncode) {

  00a3e	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00a41	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00a44	73 65		 jae	 SHORT $LN533@inflate
$LL170@inflate:

; 917  :                 NEEDBITS(3);

  00a46	83 fe 03	 cmp	 esi, 3
  00a49	73 29		 jae	 SHORT $LN172@inflate
  00a4b	0f 1f 44 00 00	 npad	 5
$LL175@inflate:
  00a50	85 db		 test	 ebx, ebx
  00a52	0f 84 22 fb ff
	ff		 je	 $LN886@inflate
  00a58	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a5b	8b ce		 mov	 ecx, esi
  00a5d	d3 e0		 shl	 eax, cl
  00a5f	4b		 dec	 ebx
  00a60	03 d0		 add	 edx, eax
  00a62	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a65	47		 inc	 edi
  00a66	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a69	83 c6 08	 add	 esi, 8
  00a6c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00a6f	83 fe 03	 cmp	 esi, 3
  00a72	72 dc		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 918  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00a74	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a77	8b ca		 mov	 ecx, edx
  00a79	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00a7c	83 e1 07	 and	 ecx, 7

; 919  :                 DROPBITS(3);

  00a7f	c1 ea 03	 shr	 edx, 3
  00a82	83 ee 03	 sub	 esi, 3
  00a85	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a88	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00a8b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a8e	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00a96	66 89 4c 47 70	 mov	 WORD PTR [edi+eax*2+112], cx
  00a9b	8b cf		 mov	 ecx, edi
  00a9d	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00aa0	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00aa3	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00aa6	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00aa9	72 9b		 jb	 SHORT $LL170@inflate
$LN533@inflate:

; 920  :             }
; 921  :             while (state->have < 19)

  00aab	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00aaf	73 1b		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 922  :                 state->lens[order[state->have++]] = 0;

  00ab1	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00ab4	33 d2		 xor	 edx, edx
  00ab6	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00abe	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00ac3	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00ac6	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00aca	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 923  :             state->next = state->codes;
; 924  :             state->lencode = (const code FAR *)(state->next);

  00acc	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00acf	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00ad5	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00ad8	89 42 4c	 mov	 DWORD PTR [edx+76], eax
  00adb	89 01		 mov	 DWORD PTR [ecx], eax

; 925  :             state->lenbits = 7;
; 926  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00add	8d 82 f0 02 00
	00		 lea	 eax, DWORD PTR [edx+752]
  00ae3	50		 push	 eax
  00ae4	8d 42 54	 lea	 eax, DWORD PTR [edx+84]
  00ae7	c7 42 54 07 00
	00 00		 mov	 DWORD PTR [edx+84], 7
  00aee	50		 push	 eax
  00aef	51		 push	 ecx
  00af0	6a 13		 push	 19			; 00000013H
  00af2	83 c2 70	 add	 edx, 112		; 00000070H
  00af5	33 c9		 xor	 ecx, ecx
  00af7	e8 00 00 00 00	 call	 _inflate_table

; 930  :                 state->mode = BAD;

  00afc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00aff	83 c4 10	 add	 esp, 16			; 00000010H
  00b02	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00b05	85 c0		 test	 eax, eax
  00b07	74 3e		 je	 SHORT $LN428@inflate

; 927  :                                 &(state->lenbits), state->work);
; 928  :             if (ret) {
; 929  :                 strm->msg = (char *)"invalid code lengths set";

  00b09	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b0c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
$LN931@inflate:

; 990  :                 state->mode = BAD;

  00b13	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN887@inflate:
  00b19	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN8@inflate:

; 638  :     for (;;)
; 639  :         switch (state->mode) {

  00b1c	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b1e	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00b21	0f 86 6a f5 ff
	ff		 jbe	 $LL5@inflate
$LN498@inflate:
  00b27	5f		 pop	 edi
  00b28	5e		 pop	 esi

; 1216 :             goto inf_leave;
; 1217 :         case MEM:
; 1218 :             return Z_MEM_ERROR;
; 1219 :         case SYNC:
; 1220 :         default:
; 1221 :             return Z_STREAM_ERROR;

  00b29	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00b2e	5b		 pop	 ebx

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  00b2f	8b e5		 mov	 esp, ebp
  00b31	5d		 pop	 ebp
  00b32	c2 08 00	 ret	 8
$LN425@inflate:

; 907  :                 strm->msg = (char *)"too many length or distance symbols";

  00b35	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b38	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00b3f	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00b45	eb d5		 jmp	 SHORT $LN8@inflate
$LN428@inflate:

; 931  :                 break;
; 932  :             }
; 933  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 934  :             state->have = 0;

  00b47	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 935  :             state->mode = CODELENS;

  00b4e	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
$LN534@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  00b54	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00b57	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00b5a	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00b5d	89 55 d8	 mov	 DWORD PTR tv2696[ebp], edx
  00b60	3b d0		 cmp	 edx, eax
  00b62	0f 83 12 02 00
	00		 jae	 $LN186@inflate
  00b68	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL185@inflate:

; 938  :                 for (;;) {
; 939  :                     here = state->lencode[BITS(state->lenbits)];

  00b70	8b 45 d0	 mov	 eax, DWORD PTR tv2779[ebp]
  00b73	ba 01 00 00 00	 mov	 edx, 1
  00b78	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b7a	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b7d	d3 e2		 shl	 edx, cl
  00b7f	4a		 dec	 edx
  00b80	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00b83	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00b86	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 940  :                     if ((unsigned)(here.bits) <= bits) break;

  00b89	8b c8		 mov	 ecx, eax
  00b8b	c1 e9 08	 shr	 ecx, 8
  00b8e	0f b6 c9	 movzx	 ecx, cl
  00b91	89 45 c8	 mov	 DWORD PTR _here$[ebp], eax
  00b94	3b ce		 cmp	 ecx, esi
  00b96	76 45		 jbe	 SHORT $LN561@inflate
$LL187@inflate:

; 941  :                     PULLBYTE();

  00b98	85 db		 test	 ebx, ebx
  00b9a	0f 84 da f9 ff
	ff		 je	 $LN886@inflate
  00ba0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00ba3	8b ce		 mov	 ecx, esi
  00ba5	d3 e0		 shl	 eax, cl
  00ba7	ba 01 00 00 00	 mov	 edx, 1
  00bac	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00baf	4b		 dec	 ebx
  00bb0	8b 45 d0	 mov	 eax, DWORD PTR tv2779[ebp]
  00bb3	47		 inc	 edi
  00bb4	83 c6 08	 add	 esi, 8
  00bb7	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00bba	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00bbd	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bbf	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bc2	d3 e2		 shl	 edx, cl
  00bc4	4a		 dec	 edx
  00bc5	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00bc8	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00bcb	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00bce	8b c8		 mov	 ecx, eax
  00bd0	c1 e9 08	 shr	 ecx, 8
  00bd3	0f b6 c9	 movzx	 ecx, cl
  00bd6	89 45 c8	 mov	 DWORD PTR _here$[ebp], eax
  00bd9	3b ce		 cmp	 ecx, esi
  00bdb	77 bb		 ja	 SHORT $LL187@inflate
$LN561@inflate:

; 942  :                 }
; 943  :                 if (here.val < 16) {

  00bdd	8b d0		 mov	 edx, eax
  00bdf	c1 ea 10	 shr	 edx, 16			; 00000010H
  00be2	66 83 fa 10	 cmp	 dx, 16			; 00000010H
  00be6	73 21		 jae	 SHORT $LN928@inflate

; 944  :                     DROPBITS(here.bits);

  00be8	c1 e8 08	 shr	 eax, 8
  00beb	0f b6 c8	 movzx	 ecx, al
  00bee	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  00bf1	2b f1		 sub	 esi, ecx

; 945  :                     state->lens[state->have++] = here.val;

  00bf3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00bf6	8b 45 d8	 mov	 eax, DWORD PTR tv2696[ebp]
  00bf9	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00bfc	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00c01	ff 41 68	 inc	 DWORD PTR [ecx+104]

; 946  :                 }

  00c04	e9 5d 01 00 00	 jmp	 $LN609@inflate
$LN928@inflate:

; 947  :                 else {
; 948  :                     if (here.val == 16) {

  00c09	75 70		 jne	 SHORT $LN434@inflate

; 949  :                         NEEDBITS(here.bits + 2);

  00c0b	8b c8		 mov	 ecx, eax
  00c0d	c1 e9 08	 shr	 ecx, 8
  00c10	0f b6 c9	 movzx	 ecx, cl
  00c13	83 c1 02	 add	 ecx, 2
  00c16	89 4d c8	 mov	 DWORD PTR $T1[ebp], ecx
  00c19	3b f1		 cmp	 esi, ecx
  00c1b	73 25		 jae	 SHORT $LN196@inflate
  00c1d	0f 1f 00	 npad	 3
$LL199@inflate:
  00c20	85 db		 test	 ebx, ebx
  00c22	0f 84 52 f9 ff
	ff		 je	 $LN886@inflate
  00c28	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00c2b	8b ce		 mov	 ecx, esi
  00c2d	d3 e2		 shl	 edx, cl
  00c2f	4b		 dec	 ebx
  00c30	01 55 fc	 add	 DWORD PTR _hold$1$[ebp], edx
  00c33	47		 inc	 edi
  00c34	83 c6 08	 add	 esi, 8
  00c37	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c3a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c3d	3b 75 c8	 cmp	 esi, DWORD PTR $T1[ebp]
  00c40	72 de		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 950  :                         DROPBITS(here.bits);

  00c42	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00c45	0f b6 cc	 movzx	 ecx, ah

; 951  :                         if (state->have == 0) {

  00c48	8b 45 d8	 mov	 eax, DWORD PTR tv2696[ebp]
  00c4b	2b f1		 sub	 esi, ecx
  00c4d	d3 ea		 shr	 edx, cl

; 953  :                             state->mode = BAD;
; 954  :                             break;
; 955  :                         }
; 956  :                         len = state->lens[state->have - 1];

  00c4f	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c52	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c55	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c58	85 c0		 test	 eax, eax
  00c5a	0f 84 3c 01 00
	00		 je	 $LN566@inflate
  00c60	0f b7 44 41 6e	 movzx	 eax, WORD PTR [ecx+eax*2+110]

; 957  :                         copy = 3 + BITS(2);

  00c65	8b ca		 mov	 ecx, edx
  00c67	83 e1 03	 and	 ecx, 3

; 958  :                         DROPBITS(2);

  00c6a	c1 ea 02	 shr	 edx, 2
  00c6d	83 c1 03	 add	 ecx, 3
  00c70	89 45 c8	 mov	 DWORD PTR _len$5$[ebp], eax
  00c73	83 ee 02	 sub	 esi, 2

; 959  :                     }

  00c76	e9 ac 00 00 00	 jmp	 $LN929@inflate
$LN434@inflate:

; 960  :                     else if (here.val == 17) {

  00c7b	66 83 7d ca 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H
  00c80	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 961  :                         NEEDBITS(here.bits + 3);

  00c83	0f b6 cc	 movzx	 ecx, ah
  00c86	75 4a		 jne	 SHORT $LN226@inflate
  00c88	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00c8b	89 4d ec	 mov	 DWORD PTR tv2678[ebp], ecx
  00c8e	3b f0		 cmp	 esi, eax
  00c90	73 29		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00c92	85 db		 test	 ebx, ebx
  00c94	0f 84 e0 f8 ff
	ff		 je	 $LN886@inflate
  00c9a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c9d	8b ce		 mov	 ecx, esi
  00c9f	d3 e0		 shl	 eax, cl
  00ca1	4b		 dec	 ebx
  00ca2	8b 4d ec	 mov	 ecx, DWORD PTR tv2678[ebp]
  00ca5	03 d0		 add	 edx, eax
  00ca7	47		 inc	 edi
  00ca8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00cab	83 c6 08	 add	 esi, 8
  00cae	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cb1	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00cb4	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00cb7	3b f0		 cmp	 esi, eax
  00cb9	72 d7		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 962  :                         DROPBITS(here.bits);

  00cbb	d3 ea		 shr	 edx, cl

; 963  :                         len = 0;
; 964  :                         copy = 3 + BITS(3);
; 965  :                         DROPBITS(3);

  00cbd	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00cc2	8b ca		 mov	 ecx, edx
  00cc4	c1 ea 03	 shr	 edx, 3
  00cc7	83 e1 07	 and	 ecx, 7
  00cca	83 c1 03	 add	 ecx, 3
  00ccd	2b 45 ec	 sub	 eax, DWORD PTR tv2678[ebp]

; 966  :                     }

  00cd0	eb 4c		 jmp	 SHORT $LN930@inflate
$LN226@inflate:

; 967  :                     else {
; 968  :                         NEEDBITS(here.bits + 7);

  00cd2	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00cd5	89 4d ec	 mov	 DWORD PTR tv2677[ebp], ecx
  00cd8	3b f0		 cmp	 esi, eax
  00cda	73 2d		 jae	 SHORT $LN224@inflate
  00cdc	0f 1f 40 00	 npad	 4
$LL227@inflate:
  00ce0	85 db		 test	 ebx, ebx
  00ce2	0f 84 92 f8 ff
	ff		 je	 $LN886@inflate
  00ce8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00ceb	8b ce		 mov	 ecx, esi
  00ced	d3 e0		 shl	 eax, cl
  00cef	4b		 dec	 ebx
  00cf0	8b 4d ec	 mov	 ecx, DWORD PTR tv2677[ebp]
  00cf3	03 d0		 add	 edx, eax
  00cf5	47		 inc	 edi
  00cf6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00cf9	83 c6 08	 add	 esi, 8
  00cfc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cff	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00d02	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00d05	3b f0		 cmp	 esi, eax
  00d07	72 d7		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 969  :                         DROPBITS(here.bits);

  00d09	d3 ea		 shr	 edx, cl

; 970  :                         len = 0;
; 971  :                         copy = 11 + BITS(7);
; 972  :                         DROPBITS(7);

  00d0b	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00d10	8b ca		 mov	 ecx, edx
  00d12	c1 ea 07	 shr	 edx, 7
  00d15	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00d18	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00d1b	2b 45 ec	 sub	 eax, DWORD PTR tv2677[ebp]
$LN930@inflate:
  00d1e	03 f0		 add	 esi, eax
  00d20	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _len$5$[ebp], 0
$LN929@inflate:

; 973  :                     }
; 974  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d27	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00d2a	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00d2d	89 4d cc	 mov	 DWORD PTR _copy$8$[ebp], ecx
  00d30	03 4d d8	 add	 ecx, DWORD PTR tv2696[ebp]
  00d33	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00d36	03 47 60	 add	 eax, DWORD PTR [edi+96]
  00d39	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00d3c	3b c8		 cmp	 ecx, eax
  00d3e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d41	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d44	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00d47	77 53		 ja	 SHORT $LN566@inflate

; 975  :                         strm->msg = (char *)"invalid bit length repeat";
; 976  :                         state->mode = BAD;
; 977  :                         break;
; 978  :                     }
; 979  :                     while (copy--)

  00d49	8b 55 cc	 mov	 edx, DWORD PTR _copy$8$[ebp]
  00d4c	85 d2		 test	 edx, edx
  00d4e	74 16		 je	 SHORT $LN609@inflate
  00d50	8b 5d c8	 mov	 ebx, DWORD PTR _len$5$[ebp]
$LL238@inflate:

; 980  :                         state->lens[state->have++] = (unsigned short)len;

  00d53	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00d56	66 89 5c 41 70	 mov	 WORD PTR [ecx+eax*2+112], bx
  00d5b	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00d5e	83 ea 01	 sub	 edx, 1
  00d61	75 f0		 jne	 SHORT $LL238@inflate
  00d63	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN609@inflate:

; 936  :         case CODELENS:
; 937  :             while (state->have < state->nlen + state->ndist) {

  00d66	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00d69	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00d6c	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00d6f	89 55 d8	 mov	 DWORD PTR tv2696[ebp], edx
  00d72	3b d0		 cmp	 edx, eax
  00d74	0f 82 f6 fd ff
	ff		 jb	 $LL185@inflate
$LN186@inflate:

; 981  :                 }
; 982  :             }
; 983  : 
; 984  :             /* handle error breaks in while */
; 985  :             if (state->mode == BAD) break;

  00d7a	83 39 1d	 cmp	 DWORD PTR [ecx], 29	; 0000001dH
  00d7d	0f 84 96 fd ff
	ff		 je	 $LN887@inflate

; 986  : 
; 987  :             /* check for end-of-block code (better have one) */
; 988  :             if (state->lens[256] == 0) {

  00d83	66 83 b9 70 02
	00 00 00	 cmp	 WORD PTR [ecx+624], 0
  00d8b	75 24		 jne	 SHORT $LN444@inflate

; 989  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00d8d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d90	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 991  :                 break;

  00d97	e9 77 fd ff ff	 jmp	 $LN931@inflate
$LN566@inflate:

; 952  :                             strm->msg = (char *)"invalid bit length repeat";

  00d9c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d9f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00da6	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00dac	e9 6b fd ff ff	 jmp	 $LN8@inflate
$LN444@inflate:

; 992  :             }
; 993  : 
; 994  :             /* build code tables -- note: do not change the lenbits or distbits
; 995  :                values here (9 and 6) without reading the comments in inftrees.h
; 996  :                concerning the ENOUGH constants, which depend on those values */
; 997  :             state->next = state->codes;

  00db1	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]

; 998  :             state->lencode = (const code FAR *)(state->next);
; 999  :             state->lenbits = 9;

  00db4	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9
  00dbb	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00dc1	89 55 c8	 mov	 DWORD PTR tv2690[ebp], edx
  00dc4	89 02		 mov	 DWORD PTR [edx], eax
  00dc6	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1000 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00dc9	8d 81 f0 02 00
	00		 lea	 eax, DWORD PTR [ecx+752]
  00dcf	50		 push	 eax
  00dd0	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  00dd3	50		 push	 eax
  00dd4	52		 push	 edx
  00dd5	ff 71 60	 push	 DWORD PTR [ecx+96]
  00dd8	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]
  00ddb	b9 01 00 00 00	 mov	 ecx, 1
  00de0	e8 00 00 00 00	 call	 _inflate_table

; 1004 :                 state->mode = BAD;

  00de5	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00de8	83 c4 10	 add	 esp, 16			; 00000010H
  00deb	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00dee	85 c0		 test	 eax, eax
  00df0	74 0f		 je	 SHORT $LN445@inflate

; 1001 :                                 &(state->lenbits), state->work);
; 1002 :             if (ret) {
; 1003 :                 strm->msg = (char *)"invalid literal/lengths set";

  00df2	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00df5	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 1005 :                 break;

  00dfc	e9 12 fd ff ff	 jmp	 $LN931@inflate
$LN445@inflate:

; 1006 :             }
; 1007 :             state->distcode = (const code FAR *)(state->next);

  00e01	8b 55 c8	 mov	 edx, DWORD PTR tv2690[ebp]

; 1008 :             state->distbits = 6;

  00e04	c7 41 58 06 00
	00 00		 mov	 DWORD PTR [ecx+88], 6
  00e0b	8b 02		 mov	 eax, DWORD PTR [edx]
  00e0d	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1009 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00e10	8d 81 f0 02 00
	00		 lea	 eax, DWORD PTR [ecx+752]
  00e16	50		 push	 eax
  00e17	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e1a	50		 push	 eax
  00e1b	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00e1e	52		 push	 edx
  00e1f	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e22	83 c1 70	 add	 ecx, 112		; 00000070H
  00e25	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00e28	b9 02 00 00 00	 mov	 ecx, 2
  00e2d	e8 00 00 00 00	 call	 _inflate_table

; 1013 :                 state->mode = BAD;

  00e32	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e35	83 c4 10	 add	 esp, 16			; 00000010H
  00e38	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e3b	85 c0		 test	 eax, eax
  00e3d	74 0f		 je	 SHORT $LN446@inflate

; 1010 :                             &(state->next), &(state->distbits), state->work);
; 1011 :             if (ret) {
; 1012 :                 strm->msg = (char *)"invalid distances set";

  00e3f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e42	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1014 :                 break;

  00e49	e9 c5 fc ff ff	 jmp	 $LN931@inflate
$LN446@inflate:

; 1015 :             }
; 1016 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1017 :             state->mode = LEN_;
; 1018 :             if (flush == Z_TREES) goto inf_leave;

  00e4e	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00e51	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00e57	83 fa 06	 cmp	 edx, 6
  00e5a	0f 84 16 07 00
	00		 je	 $LN862@inflate
  00e60	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN447@inflate:

; 1019 :         case LEN_:
; 1020 :             state->mode = LEN;

  00e63	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
$LN449@inflate:

; 1021 :         case LEN:
; 1022 :             if (have >= 6 && left >= 258) {

  00e69	83 fb 06	 cmp	 ebx, 6
  00e6c	72 71		 jb	 SHORT $LN450@inflate
  00e6e	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00e75	72 68		 jb	 SHORT $LN450@inflate

; 1023 :                 RESTORE();

  00e77	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e7a	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  00e7d	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00e80	8b 7d e8	 mov	 edi, DWORD PTR _left$1$[ebp]
  00e83	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00e86	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e89	89 38		 mov	 DWORD PTR [eax], edi
  00e8b	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00e8e	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 1024 :                 inflate_fast(strm, out);

  00e91	8b 55 dc	 mov	 edx, DWORD PTR _out$1$[ebp]
  00e94	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  00e97	8b c8		 mov	 ecx, eax
  00e99	e8 00 00 00 00	 call	 _inflate_fast

; 1025 :                 LOAD();

  00e9e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ea1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00ea4	8b 38		 mov	 edi, DWORD PTR [eax]
  00ea6	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00ea9	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00eac	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00eaf	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00eb2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00eb5	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00eb8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1026 :                 if (state->mode == TYPE)

  00ebb	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  00ebe	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00ec1	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00ec4	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ec7	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00eca	0f 85 4c fc ff
	ff		 jne	 $LN8@inflate

; 1027 :                     state->back = -1;

  00ed0	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 1028 :                 break;

  00eda	e9 3d fc ff ff	 jmp	 $LN8@inflate
$LN450@inflate:

; 1029 :             }
; 1030 :             state->back = 0;
; 1031 :             for (;;) {
; 1032 :                 here = state->lencode[BITS(state->lenbits)];

  00edf	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00ee2	c7 81 c4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7108], 0
  00eec	8b 4d d0	 mov	 ecx, DWORD PTR tv2779[ebp]
  00eef	89 45 cc	 mov	 DWORD PTR tv2688[ebp], eax
  00ef2	b8 01 00 00 00	 mov	 eax, 1
  00ef7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00ef9	d3 e0		 shl	 eax, cl
  00efb	8b 4d cc	 mov	 ecx, DWORD PTR tv2688[ebp]
  00efe	48		 dec	 eax
  00eff	23 c2		 and	 eax, edx
  00f01	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1033 :                 if ((unsigned)(here.bits) <= bits) break;

  00f04	8b c8		 mov	 ecx, eax
  00f06	c1 e9 08	 shr	 ecx, 8
  00f09	0f b6 c9	 movzx	 ecx, cl
  00f0c	3b ce		 cmp	 ecx, esi
  00f0e	76 47		 jbe	 SHORT $LN568@inflate
$LL246@inflate:

; 1034 :                 PULLBYTE();

  00f10	85 db		 test	 ebx, ebx
  00f12	0f 84 62 f6 ff
	ff		 je	 $LN886@inflate
  00f18	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00f1b	8b ce		 mov	 ecx, esi
  00f1d	d3 e0		 shl	 eax, cl
  00f1f	4b		 dec	 ebx
  00f20	03 d0		 add	 edx, eax
  00f22	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00f25	8b 45 d0	 mov	 eax, DWORD PTR tv2779[ebp]
  00f28	47		 inc	 edi
  00f29	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f2c	83 c6 08	 add	 esi, 8
  00f2f	ba 01 00 00 00	 mov	 edx, 1
  00f34	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00f37	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f39	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00f3c	d3 e2		 shl	 edx, cl
  00f3e	4a		 dec	 edx
  00f3f	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00f42	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00f45	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00f48	8b c8		 mov	 ecx, eax
  00f4a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00f4d	c1 e9 08	 shr	 ecx, 8
  00f50	0f b6 c9	 movzx	 ecx, cl
  00f53	3b ce		 cmp	 ecx, esi
  00f55	77 b9		 ja	 SHORT $LL246@inflate
$LN568@inflate:

; 1035 :             }
; 1036 :             if (here.op && (here.op & 0xf0) == 0) {

  00f57	84 c0		 test	 al, al
  00f59	0f 84 be 00 00
	00		 je	 $LN263@inflate
  00f5f	a8 f0		 test	 al, 240			; 000000f0H
  00f61	0f 85 b6 00 00
	00		 jne	 $LN263@inflate

; 1037 :                 last = here;
; 1038 :                 for (;;) {
; 1039 :                     here = state->lencode[last.val +

  00f67	8b c8		 mov	 ecx, eax
  00f69	bb 01 00 00 00	 mov	 ebx, 1
  00f6e	c1 e9 08	 shr	 ecx, 8
  00f71	8b d0		 mov	 edx, eax
  00f73	0f b6 f9	 movzx	 edi, cl
  00f76	89 4d d8	 mov	 DWORD PTR tv2687[ebp], ecx
  00f79	0f b6 c8	 movzx	 ecx, al
  00f7c	03 cf		 add	 ecx, edi
  00f7e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00f81	d3 e3		 shl	 ebx, cl
  00f83	8b cf		 mov	 ecx, edi
  00f85	4b		 dec	 ebx
  00f86	89 55 c8	 mov	 DWORD PTR _last$[ebp], edx
  00f89	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00f8c	d3 eb		 shr	 ebx, cl
  00f8e	8b 4d cc	 mov	 ecx, DWORD PTR tv2688[ebp]
  00f91	03 d8		 add	 ebx, eax
  00f93	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1040 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1041 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00f96	8b c8		 mov	 ecx, eax
  00f98	c1 e9 08	 shr	 ecx, 8
  00f9b	0f b6 f9	 movzx	 edi, cl
  00f9e	8b 4d d8	 mov	 ecx, DWORD PTR tv2687[ebp]
  00fa1	0f b6 c9	 movzx	 ecx, cl
  00fa4	03 f9		 add	 edi, ecx
  00fa6	3b fe		 cmp	 edi, esi
  00fa8	76 5d		 jbe	 SHORT $LN260@inflate
  00faa	66 0f 1f 44 00
	00		 npad	 6
$LL252@inflate:

; 1042 :                     PULLBYTE();

  00fb0	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  00fb3	85 c0		 test	 eax, eax
  00fb5	0f 84 c2 f5 ff
	ff		 je	 $LN896@inflate
  00fbb	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00fbe	48		 dec	 eax
  00fbf	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  00fc2	8b ce		 mov	 ecx, esi
  00fc4	bf 01 00 00 00	 mov	 edi, 1
  00fc9	83 c6 08	 add	 esi, 8
  00fcc	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00fcf	43		 inc	 ebx
  00fd0	d3 e0		 shl	 eax, cl
  00fd2	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00fd5	0f b7 45 ca	 movzx	 eax, WORD PTR _last$[ebp+2]
  00fd9	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00fdc	0f b6 de	 movzx	 ebx, dh
  00fdf	0f b6 ca	 movzx	 ecx, dl
  00fe2	03 cb		 add	 ecx, ebx
  00fe4	d3 e7		 shl	 edi, cl
  00fe6	8b cb		 mov	 ecx, ebx
  00fe8	4f		 dec	 edi
  00fe9	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  00fec	d3 ef		 shr	 edi, cl
  00fee	03 f8		 add	 edi, eax
  00ff0	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ff3	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00ff6	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00ff9	8b c8		 mov	 ecx, eax
  00ffb	c1 e9 08	 shr	 ecx, 8
  00ffe	0f b6 c9	 movzx	 ecx, cl
  01001	03 cb		 add	 ecx, ebx
  01003	3b ce		 cmp	 ecx, esi
  01005	77 a9		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1043 :                 }
; 1044 :                 DROPBITS(last.bits);
; 1045 :                 state->back += last.bits;

  01007	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0100a	0f b6 ce	 movzx	 ecx, dh
  0100d	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01010	d3 ea		 shr	 edx, cl
  01012	2b f1		 sub	 esi, ecx
  01014	89 8b c4 1b 00
	00		 mov	 DWORD PTR [ebx+7108], ecx
  0101a	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN263@inflate:

; 1046 :             }
; 1047 :             DROPBITS(here.bits);
; 1048 :             state->back += here.bits;

  0101d	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  01020	8b c8		 mov	 ecx, eax
  01022	c1 e9 08	 shr	 ecx, 8
  01025	0f b6 c9	 movzx	 ecx, cl
  01028	d3 ea		 shr	 edx, cl
  0102a	2b f1		 sub	 esi, ecx
  0102c	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx

; 1049 :             state->length = (unsigned)here.val;

  01032	8b c8		 mov	 ecx, eax
  01034	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01037	89 4f 40	 mov	 DWORD PTR [edi+64], ecx

; 1050 :             if ((int)(here.op) == 0) {

  0103a	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1051 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1052 :                         "inflate:         literal '%c'\n" :
; 1053 :                         "inflate:         literal 0x%02x\n", here.val));
; 1054 :                 state->mode = LIT;

  0103d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01040	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01043	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01046	84 c0		 test	 al, al
  01048	75 0b		 jne	 SHORT $LN457@inflate
  0104a	c7 01 19 00 00
	00		 mov	 DWORD PTR [ecx], 25	; 00000019H

; 1055 :                 break;

  01050	e9 c7 fa ff ff	 jmp	 $LN8@inflate
$LN457@inflate:

; 1056 :             }
; 1057 :             if (here.op & 32) {

  01055	a8 20		 test	 al, 32			; 00000020H
  01057	74 15		 je	 SHORT $LN458@inflate

; 1058 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1059 :                 state->back = -1;

  01059	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1
$LN418@inflate:

; 1060 :                 state->mode = TYPE;

  01063	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1061 :                 break;

  01069	e9 ae fa ff ff	 jmp	 $LN8@inflate
$LN458@inflate:

; 1062 :             }
; 1063 :             if (here.op & 64) {

  0106e	a8 40		 test	 al, 64			; 00000040H
  01070	74 15		 je	 SHORT $LN459@inflate

; 1064 :                 strm->msg = (char *)"invalid literal/length code";

  01072	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01075	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  0107c	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  01082	e9 95 fa ff ff	 jmp	 $LN8@inflate
$LN459@inflate:

; 1065 :                 state->mode = BAD;
; 1066 :                 break;
; 1067 :             }
; 1068 :             state->extra = (unsigned)(here.op) & 15;

  01087	0f b6 c0	 movzx	 eax, al
  0108a	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1069 :             state->mode = LENEXT;

  0108d	c7 01 15 00 00
	00		 mov	 DWORD PTR [ecx], 21	; 00000015H
  01093	89 41 48	 mov	 DWORD PTR [ecx+72], eax
$LN460@inflate:

; 1070 :         case LENEXT:
; 1071 :             if (state->extra) {

  01096	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01099	89 45 c8	 mov	 DWORD PTR tv2666[ebp], eax
  0109c	85 c0		 test	 eax, eax
  0109e	74 50		 je	 SHORT $LN461@inflate

; 1072 :                 NEEDBITS(state->extra);

  010a0	3b f0		 cmp	 esi, eax
  010a2	73 24		 jae	 SHORT $LN264@inflate
$LL267@inflate:
  010a4	85 db		 test	 ebx, ebx
  010a6	0f 84 ce f4 ff
	ff		 je	 $LN886@inflate
  010ac	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  010af	8b ce		 mov	 ecx, esi
  010b1	d3 e0		 shl	 eax, cl
  010b3	4b		 dec	 ebx
  010b4	03 d0		 add	 edx, eax
  010b6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  010b9	47		 inc	 edi
  010ba	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  010bd	83 c6 08	 add	 esi, 8
  010c0	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  010c3	3b 75 c8	 cmp	 esi, DWORD PTR tv2666[ebp]
  010c6	72 dc		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1073 :                 state->length += BITS(state->extra);

  010c8	8b 4d c8	 mov	 ecx, DWORD PTR tv2666[ebp]
  010cb	b8 01 00 00 00	 mov	 eax, 1
  010d0	d3 e0		 shl	 eax, cl
  010d2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010d5	48		 dec	 eax
  010d6	23 c2		 and	 eax, edx
  010d8	01 41 40	 add	 DWORD PTR [ecx+64], eax

; 1074 :                 DROPBITS(state->extra);

  010db	8b 45 c8	 mov	 eax, DWORD PTR tv2666[ebp]
  010de	8b c8		 mov	 ecx, eax
  010e0	d3 ea		 shr	 edx, cl
  010e2	2b f0		 sub	 esi, eax

; 1075 :                 state->back += state->extra;

  010e4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010e7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  010ea	01 81 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], eax
$LN461@inflate:

; 1076 :             }
; 1077 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1078 :             state->was = state->length;

  010f0	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  010f3	89 81 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], eax

; 1079 :             state->mode = DIST;

  010f9	c7 01 16 00 00
	00		 mov	 DWORD PTR [ecx], 22	; 00000016H
$LN463@inflate:

; 1080 :         case DIST:
; 1081 :             for (;;) {
; 1082 :                 here = state->distcode[BITS(state->distbits)];

  010ff	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  01102	8b 4d c0	 mov	 ecx, DWORD PTR tv2776[ebp]
  01105	89 45 cc	 mov	 DWORD PTR tv2664[ebp], eax
  01108	b8 01 00 00 00	 mov	 eax, 1
  0110d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0110f	d3 e0		 shl	 eax, cl
  01111	8b 4d cc	 mov	 ecx, DWORD PTR tv2664[ebp]
  01114	48		 dec	 eax
  01115	23 c2		 and	 eax, edx
  01117	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1083 :                 if ((unsigned)(here.bits) <= bits) break;

  0111a	8b c8		 mov	 ecx, eax
  0111c	c1 e9 08	 shr	 ecx, 8
  0111f	0f b6 c9	 movzx	 ecx, cl
  01122	3b ce		 cmp	 ecx, esi
  01124	76 47		 jbe	 SHORT $LN573@inflate
$LL275@inflate:

; 1084 :                 PULLBYTE();

  01126	85 db		 test	 ebx, ebx
  01128	0f 84 4c f4 ff
	ff		 je	 $LN886@inflate
  0112e	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01131	8b ce		 mov	 ecx, esi
  01133	d3 e0		 shl	 eax, cl
  01135	4b		 dec	 ebx
  01136	03 d0		 add	 edx, eax
  01138	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0113b	8b 45 c0	 mov	 eax, DWORD PTR tv2776[ebp]
  0113e	47		 inc	 edi
  0113f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01142	83 c6 08	 add	 esi, 8
  01145	ba 01 00 00 00	 mov	 edx, 1
  0114a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0114d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0114f	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  01152	d3 e2		 shl	 edx, cl
  01154	4a		 dec	 edx
  01155	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  01158	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0115b	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0115e	8b c8		 mov	 ecx, eax
  01160	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01163	c1 e9 08	 shr	 ecx, 8
  01166	0f b6 c9	 movzx	 ecx, cl
  01169	3b ce		 cmp	 ecx, esi
  0116b	77 b9		 ja	 SHORT $LL275@inflate
$LN573@inflate:

; 1085 :             }
; 1086 :             if ((here.op & 0xf0) == 0) {

  0116d	a8 f0		 test	 al, 240			; 000000f0H
  0116f	0f 85 b7 00 00
	00		 jne	 $LN891@inflate

; 1087 :                 last = here;
; 1088 :                 for (;;) {
; 1089 :                     here = state->distcode[last.val +

  01175	8b c8		 mov	 ecx, eax
  01177	bb 01 00 00 00	 mov	 ebx, 1
  0117c	c1 e9 08	 shr	 ecx, 8
  0117f	8b d0		 mov	 edx, eax
  01181	0f b6 f9	 movzx	 edi, cl
  01184	89 4d d8	 mov	 DWORD PTR tv2686[ebp], ecx
  01187	0f b6 c8	 movzx	 ecx, al
  0118a	03 cf		 add	 ecx, edi
  0118c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0118f	d3 e3		 shl	 ebx, cl
  01191	8b cf		 mov	 ecx, edi
  01193	4b		 dec	 ebx
  01194	89 55 c8	 mov	 DWORD PTR _last$[ebp], edx
  01197	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  0119a	d3 eb		 shr	 ebx, cl
  0119c	8b 4d cc	 mov	 ecx, DWORD PTR tv2664[ebp]
  0119f	03 d8		 add	 ebx, eax
  011a1	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1090 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1091 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  011a4	8b c8		 mov	 ecx, eax
  011a6	c1 e9 08	 shr	 ecx, 8
  011a9	0f b6 f9	 movzx	 edi, cl
  011ac	8b 4d d8	 mov	 ecx, DWORD PTR tv2686[ebp]
  011af	0f b6 c9	 movzx	 ecx, cl
  011b2	03 f9		 add	 edi, ecx
  011b4	3b fe		 cmp	 edi, esi
  011b6	76 5f		 jbe	 SHORT $LN289@inflate
  011b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL281@inflate:

; 1092 :                     PULLBYTE();

  011c0	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  011c3	85 c0		 test	 eax, eax
  011c5	0f 84 b2 f3 ff
	ff		 je	 $LN896@inflate
  011cb	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  011ce	48		 dec	 eax
  011cf	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  011d2	8b ce		 mov	 ecx, esi
  011d4	bf 01 00 00 00	 mov	 edi, 1
  011d9	83 c6 08	 add	 esi, 8
  011dc	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  011df	43		 inc	 ebx
  011e0	d3 e0		 shl	 eax, cl
  011e2	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  011e5	0f b7 45 ca	 movzx	 eax, WORD PTR _last$[ebp+2]
  011e9	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  011ec	0f b6 de	 movzx	 ebx, dh
  011ef	0f b6 ca	 movzx	 ecx, dl
  011f2	03 cb		 add	 ecx, ebx
  011f4	d3 e7		 shl	 edi, cl
  011f6	8b cb		 mov	 ecx, ebx
  011f8	4f		 dec	 edi
  011f9	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  011fc	d3 ef		 shr	 edi, cl
  011fe	03 f8		 add	 edi, eax
  01200	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  01203	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  01206	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01209	8b c8		 mov	 ecx, eax
  0120b	c1 e9 08	 shr	 ecx, 8
  0120e	0f b6 c9	 movzx	 ecx, cl
  01211	03 cb		 add	 ecx, ebx
  01213	3b ce		 cmp	 ecx, esi
  01215	77 a9		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1093 :                 }
; 1094 :                 DROPBITS(last.bits);
; 1095 :                 state->back += last.bits;

  01217	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0121a	0f b6 ce	 movzx	 ecx, dh
  0121d	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01220	2b f1		 sub	 esi, ecx
  01222	d3 ea		 shr	 edx, cl
  01224	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  0122a	eb 03		 jmp	 SHORT $LN292@inflate
$LN891@inflate:
  0122c	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN292@inflate:

; 1102 :                 break;

  0122f	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01232	8b c8		 mov	 ecx, eax
  01234	c1 e9 08	 shr	 ecx, 8
  01237	0f b6 c9	 movzx	 ecx, cl
  0123a	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  01240	2b f1		 sub	 esi, ecx
  01242	d3 ea		 shr	 edx, cl
  01244	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01247	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0124a	a8 40		 test	 al, 64			; 00000040H
  0124c	74 1b		 je	 SHORT $LN469@inflate

; 1096 :             }
; 1097 :             DROPBITS(here.bits);
; 1098 :             state->back += here.bits;
; 1099 :             if (here.op & 64) {
; 1100 :                 strm->msg = (char *)"invalid distance code";
; 1101 :                 state->mode = BAD;

  0124e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01251	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1102 :                 break;

  01254	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01257	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  0125e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  01264	e9 b3 f8 ff ff	 jmp	 $LN8@inflate
$LN469@inflate:

; 1103 :             }
; 1104 :             state->offset = (unsigned)here.val;

  01269	8b c8		 mov	 ecx, eax

; 1105 :             state->extra = (unsigned)(here.op) & 15;

  0126b	0f b6 c0	 movzx	 eax, al
  0126e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01271	83 e0 0f	 and	 eax, 15			; 0000000fH
  01274	89 4b 44	 mov	 DWORD PTR [ebx+68], ecx
  01277	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0127a	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0127d	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1106 :             state->mode = DISTEXT;

  01280	c7 01 17 00 00
	00		 mov	 DWORD PTR [ecx], 23	; 00000017H
$LN470@inflate:

; 1107 :         case DISTEXT:
; 1108 :             if (state->extra) {

  01286	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01289	89 45 c8	 mov	 DWORD PTR tv2665[ebp], eax
  0128c	85 c0		 test	 eax, eax
  0128e	74 53		 je	 SHORT $LN471@inflate

; 1109 :                 NEEDBITS(state->extra);

  01290	3b f0		 cmp	 esi, eax
  01292	73 24		 jae	 SHORT $LN293@inflate
$LL296@inflate:
  01294	85 db		 test	 ebx, ebx
  01296	0f 84 de f2 ff
	ff		 je	 $LN886@inflate
  0129c	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0129f	8b ce		 mov	 ecx, esi
  012a1	d3 e0		 shl	 eax, cl
  012a3	4b		 dec	 ebx
  012a4	03 d0		 add	 edx, eax
  012a6	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  012a9	47		 inc	 edi
  012aa	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  012ad	83 c6 08	 add	 esi, 8
  012b0	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  012b3	3b 75 c8	 cmp	 esi, DWORD PTR tv2665[ebp]
  012b6	72 dc		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1110 :                 state->offset += BITS(state->extra);

  012b8	8b 4d c8	 mov	 ecx, DWORD PTR tv2665[ebp]
  012bb	b8 01 00 00 00	 mov	 eax, 1
  012c0	d3 e0		 shl	 eax, cl
  012c2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012c5	48		 dec	 eax
  012c6	23 c2		 and	 eax, edx
  012c8	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1111 :                 DROPBITS(state->extra);

  012cb	8b 45 c8	 mov	 eax, DWORD PTR tv2665[ebp]
  012ce	8b c8		 mov	 ecx, eax
  012d0	d3 ea		 shr	 edx, cl
  012d2	2b f0		 sub	 esi, eax

; 1112 :                 state->back += state->extra;

  012d4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012d7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  012da	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  012dd	01 81 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], eax
$LN471@inflate:

; 1113 :             }
; 1114 : #ifdef INFLATE_STRICT
; 1115 :             if (state->offset > state->dmax) {
; 1116 :                 strm->msg = (char *)"invalid distance too far back";
; 1117 :                 state->mode = BAD;
; 1118 :                 break;
; 1119 :             }
; 1120 : #endif
; 1121 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1122 :             state->mode = MATCH;

  012e3	c7 01 18 00 00
	00		 mov	 DWORD PTR [ecx], 24	; 00000018H
$LN473@inflate:

; 1123 :         case MATCH:
; 1124 :             if (left == 0) goto inf_leave;

  012e9	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  012ed	0f 84 87 f2 ff
	ff		 je	 $LN886@inflate

; 1125 :             copy = out - left;

  012f3	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  012f6	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  012f9	89 45 c8	 mov	 DWORD PTR _copy$9$[ebp], eax

; 1126 :             if (state->offset > copy) {         /* copy from window */

  012fc	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  012ff	3b 45 c8	 cmp	 eax, DWORD PTR _copy$9$[ebp]
  01302	76 54		 jbe	 SHORT $LN475@inflate

; 1127 :                 copy = state->offset - copy;

  01304	2b 45 c8	 sub	 eax, DWORD PTR _copy$9$[ebp]

; 1128 :                 if (copy > state->whave) {

  01307	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  0130a	76 1e		 jbe	 SHORT $LN478@inflate

; 1129 :                     if (state->sane) {

  0130c	83 b9 c0 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7104], 0
  01313	74 15		 je	 SHORT $LN478@inflate

; 1130 :                         strm->msg = (char *)"invalid distance too far back";

  01315	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01318	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  0131f	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  01325	e9 f2 f7 ff ff	 jmp	 $LN8@inflate
$LN478@inflate:

; 1131 :                         state->mode = BAD;
; 1132 :                         break;
; 1133 :                     }
; 1134 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1135 :                     Trace((stderr, "inflate.c too far\n"));
; 1136 :                     copy -= state->whave;
; 1137 :                     if (copy > state->length) copy = state->length;
; 1138 :                     if (copy > left) copy = left;
; 1139 :                     left -= copy;
; 1140 :                     state->length -= copy;
; 1141 :                     do {
; 1142 :                         *put++ = 0;
; 1143 :                     } while (--copy);
; 1144 :                     if (state->length == 0) state->mode = LEN;
; 1145 :                     break;
; 1146 : #endif
; 1147 :                 }
; 1148 :                 if (copy > state->wnext) {

  0132a	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  0132d	76 10		 jbe	 SHORT $LN479@inflate

; 1149 :                     copy -= state->wnext;
; 1150 :                     from = state->window + (state->wsize - copy);

  0132f	8b 79 34	 mov	 edi, DWORD PTR [ecx+52]
  01332	2b 41 30	 sub	 eax, DWORD PTR [ecx+48]
  01335	03 79 28	 add	 edi, DWORD PTR [ecx+40]
  01338	2b f8		 sub	 edi, eax
  0133a	89 7d d8	 mov	 DWORD PTR _from$1$[ebp], edi

; 1151 :                 }

  0133d	eb 0b		 jmp	 SHORT $LN480@inflate
$LN479@inflate:

; 1152 :                 else
; 1153 :                     from = state->window + (state->wnext - copy);

  0133f	8b 59 34	 mov	 ebx, DWORD PTR [ecx+52]
  01342	2b d8		 sub	 ebx, eax
  01344	03 59 30	 add	 ebx, DWORD PTR [ecx+48]
  01347	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
$LN480@inflate:

; 1154 :                 if (copy > state->length) copy = state->length;

  0134a	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  0134d	89 7d c8	 mov	 DWORD PTR tv2620[ebp], edi
  01350	3b c7		 cmp	 eax, edi
  01352	76 13		 jbe	 SHORT $LN476@inflate
  01354	8b c7		 mov	 eax, edi

; 1155 :             }

  01356	eb 0f		 jmp	 SHORT $LN476@inflate
$LN475@inflate:

; 1156 :             else {                              /* copy from output */
; 1157 :                 from = put - state->offset;

  01358	8b 5d e0	 mov	 ebx, DWORD PTR _put$1$[ebp]
  0135b	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
  0135e	29 45 d8	 sub	 DWORD PTR _from$1$[ebp], eax

; 1158 :                 copy = state->length;

  01361	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  01364	89 45 c8	 mov	 DWORD PTR tv2620[ebp], eax
$LN476@inflate:

; 1159 :             }
; 1160 :             if (copy > left) copy = left;

  01367	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  0136a	3b c3		 cmp	 eax, ebx
  0136c	0f 47 c3	 cmova	 eax, ebx

; 1161 :             left -= copy;

  0136f	2b d8		 sub	 ebx, eax
  01371	89 45 cc	 mov	 DWORD PTR _copy$11$[ebp], eax
  01374	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx
  01377	8b f8		 mov	 edi, eax

; 1162 :             state->length -= copy;

  01379	8b 5d c8	 mov	 ebx, DWORD PTR tv2620[ebp]
  0137c	2b d8		 sub	 ebx, eax
  0137e	89 59 40	 mov	 DWORD PTR [ecx+64], ebx

; 1165 :             } while (--copy);

  01381	8b 5d d8	 mov	 ebx, DWORD PTR _from$1$[ebp]
  01384	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01387	2b d9		 sub	 ebx, ecx
  01389	0f 1f 80 00 00
	00 00		 npad	 7
$LL306@inflate:

; 1163 :             do {
; 1164 :                 *put++ = *from++;

  01390	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  01393	88 01		 mov	 BYTE PTR [ecx], al
  01395	41		 inc	 ecx

; 1165 :             } while (--copy);

  01396	83 ef 01	 sub	 edi, 1
  01399	75 f5		 jne	 SHORT $LL306@inflate

; 1166 :             if (state->length == 0) state->mode = LEN;

  0139b	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0139e	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  013a1	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  013a4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013a7	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  013ab	0f 85 6b f7 ff
	ff		 jne	 $LN8@inflate
  013b1	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 1167 :             break;

  013b7	e9 60 f7 ff ff	 jmp	 $LN8@inflate
$LN484@inflate:

; 1168 :         case LIT:
; 1169 :             if (left == 0) goto inf_leave;

  013bc	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  013c0	0f 84 b4 f1 ff
	ff		 je	 $LN886@inflate

; 1170 :             *put++ = (unsigned char)(state->length);

  013c6	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  013c9	8a 41 40	 mov	 al, BYTE PTR [ecx+64]
  013cc	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1171 :             left--;

  013cf	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  013d2	88 07		 mov	 BYTE PTR [edi], al

; 1172 :             state->mode = LEN;
; 1173 :             break;

  013d4	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  013d7	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
  013dd	e9 3a f7 ff ff	 jmp	 $LN8@inflate
$LN486@inflate:

; 1174 :         case CHECK:
; 1175 :             if (state->wrap) {

  013e2	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  013e6	0f 84 d4 00 00
	00		 je	 $LN316@inflate

; 1176 :                 NEEDBITS(32);

  013ec	83 fe 20	 cmp	 esi, 32			; 00000020H
  013ef	73 2a		 jae	 SHORT $LN307@inflate
$LL310@inflate:
  013f1	85 db		 test	 ebx, ebx
  013f3	0f 84 81 f1 ff
	ff		 je	 $LN886@inflate
  013f9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  013fc	8b ce		 mov	 ecx, esi
  013fe	d3 e0		 shl	 eax, cl
  01400	83 c6 08	 add	 esi, 8
  01403	4b		 dec	 ebx
  01404	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01407	03 d0		 add	 edx, eax
  01409	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0140c	47		 inc	 edi
  0140d	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01410	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01413	83 fe 20	 cmp	 esi, 32			; 00000020H
  01416	72 d9		 jb	 SHORT $LL310@inflate
  01418	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 1177 :                 out -= left;

  0141b	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  0141e	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1178 :                 strm->total_out += out;

  01421	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01424	8b 7d dc	 mov	 edi, DWORD PTR _out$1$[ebp]
  01427	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1179 :                 state->total += out;

  0142a	8b c7		 mov	 eax, edi
  0142c	01 41 1c	 add	 DWORD PTR [ecx+28], eax

; 1180 :                 if (out)

  0142f	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01432	85 c0		 test	 eax, eax
  01434	74 2c		 je	 SHORT $LN489@inflate

; 1181 :                     strm->adler = state->check =

  01436	50		 push	 eax
  01437	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  0143a	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  0143d	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01441	50		 push	 eax
  01442	ff 71 18	 push	 DWORD PTR [ecx+24]
  01445	74 07		 je	 SHORT $LN510@inflate
  01447	e8 00 00 00 00	 call	 _crc32@12
  0144c	eb 05		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  0144e	e8 00 00 00 00	 call	 _adler32@12
$LN511@inflate:
  01453	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01456	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01459	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0145c	89 42 30	 mov	 DWORD PTR [edx+48], eax
  0145f	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN489@inflate:

; 1182 :                         UPDATE(state->check, put - out, out);
; 1183 :                 out = left;
; 1184 :                 if ((
; 1185 : #ifdef GUNZIP
; 1186 :                      state->flags ? hold :
; 1187 : #endif
; 1188 :                      ZSWAP32(hold)) != state->check) {

  01462	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01466	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  01469	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  0146c	8b c2		 mov	 eax, edx
  0146e	75 2c		 jne	 SHORT $LN513@inflate
  01470	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01475	89 45 d8	 mov	 DWORD PTR tv2786[ebp], eax
  01478	8b c2		 mov	 eax, edx
  0147a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0147d	01 45 d8	 add	 DWORD PTR tv2786[ebp], eax
  01480	8b c2		 mov	 eax, edx
  01482	c1 65 d8 08	 shl	 DWORD PTR tv2786[ebp], 8
  01486	c1 e8 08	 shr	 eax, 8
  01489	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0148e	01 45 d8	 add	 DWORD PTR tv2786[ebp], eax
  01491	8b c2		 mov	 eax, edx
  01493	c1 e8 18	 shr	 eax, 24			; 00000018H
  01496	01 45 d8	 add	 DWORD PTR tv2786[ebp], eax
  01499	8b 45 d8	 mov	 eax, DWORD PTR tv2786[ebp]
$LN513@inflate:
  0149c	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  0149f	74 15		 je	 SHORT $LN317@inflate

; 1189 :                     strm->msg = (char *)"incorrect data check";

  014a1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014a4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  014ab	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  014b1	e9 66 f6 ff ff	 jmp	 $LN8@inflate
$LN317@inflate:

; 1190 :                     state->mode = BAD;
; 1191 :                     break;
; 1192 :                 }
; 1193 :                 INITBITS();

  014b6	33 d2		 xor	 edx, edx
  014b8	33 f6		 xor	 esi, esi
  014ba	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  014bd	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1194 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1195 :             }
; 1196 : #ifdef GUNZIP
; 1197 :             state->mode = LENGTH;

  014c0	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH
$LN491@inflate:

; 1198 :         case LENGTH:
; 1199 :             if (state->wrap && state->flags) {

  014c6	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  014ca	0f 84 88 00 00
	00		 je	 $LN327@inflate
  014d0	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  014d4	0f 84 7e 00 00
	00		 je	 $LN327@inflate

; 1200 :                 NEEDBITS(32);

  014da	83 fe 20	 cmp	 esi, 32			; 00000020H
  014dd	73 2b		 jae	 SHORT $LN318@inflate
  014df	90		 npad	 1
$LL321@inflate:
  014e0	85 db		 test	 ebx, ebx
  014e2	0f 84 92 f0 ff
	ff		 je	 $LN886@inflate
  014e8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  014eb	8b ce		 mov	 ecx, esi
  014ed	d3 e0		 shl	 eax, cl
  014ef	83 c6 08	 add	 esi, 8
  014f2	4b		 dec	 ebx
  014f3	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  014f6	03 d0		 add	 edx, eax
  014f8	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  014fb	47		 inc	 edi
  014fc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  014ff	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01502	83 fe 20	 cmp	 esi, 32			; 00000020H
  01505	72 d9		 jb	 SHORT $LL321@inflate
  01507	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN318@inflate:

; 1201 :                 if (hold != (state->total & 0xffffffffUL)) {

  0150a	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  0150d	74 40		 je	 SHORT $LN328@inflate

; 1202 :                     strm->msg = (char *)"incorrect length check";

  0150f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01512	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  01519	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  0151f	e9 f8 f5 ff ff	 jmp	 $LN8@inflate
$LN585@inflate:

; 821  :                 RESTORE();

  01524	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01527	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0152a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0152d	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  01530	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01533	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01536	89 38		 mov	 DWORD PTR [eax], edi
  01538	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 822  :                 return Z_NEED_DICT;

  0153b	b8 02 00 00 00	 mov	 eax, 2
  01540	5f		 pop	 edi
  01541	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  01544	5e		 pop	 esi
  01545	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  01548	5b		 pop	 ebx

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  01549	8b e5		 mov	 esp, ebp
  0154b	5d		 pop	 ebp
  0154c	c2 08 00	 ret	 8
$LN328@inflate:

; 1203 :                     state->mode = BAD;
; 1204 :                     break;
; 1205 :                 }
; 1206 :                 INITBITS();

  0154f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  01556	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1207 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1208 :             }
; 1209 : #endif
; 1210 :             state->mode = DONE;

  01558	c7 01 1c 00 00
	00		 mov	 DWORD PTR [ecx], 28	; 0000001cH
$LN495@inflate:

; 1211 :         case DONE:
; 1212 :             ret = Z_STREAM_END;

  0155e	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1213 :             goto inf_leave;

  01565	e9 10 f0 ff ff	 jmp	 $LN886@inflate
$LN496@inflate:

; 1214 :         case BAD:
; 1215 :             ret = Z_DATA_ERROR;

  0156a	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  01571	e9 04 f0 ff ff	 jmp	 $LN886@inflate
$LN862@inflate:
  01576	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01579	e9 02 f0 ff ff	 jmp	 $inf_leave$937
$LN502@inflate:

; 1237 :         }
; 1238 :     in -= strm->avail_in;

  0157e	8b 45 c4	 mov	 eax, DWORD PTR _in$1$[ebp]
  01581	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1239 :     out -= strm->avail_out;

  01584	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1240 :     strm->total_in += in;

  01587	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1241 :     strm->total_out += out;

  0158a	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1242 :     state->total += out;

  0158d	01 73 1c	 add	 DWORD PTR [ebx+28], esi

; 1243 :     if (state->wrap && out)

  01590	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  01594	89 45 c4	 mov	 DWORD PTR _in$1$[ebp], eax
  01597	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  0159a	74 26		 je	 SHORT $LN503@inflate
  0159c	85 f6		 test	 esi, esi
  0159e	74 22		 je	 SHORT $LN503@inflate

; 1244 :         strm->adler = state->check =

  015a0	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  015a3	56		 push	 esi
  015a4	2b c6		 sub	 eax, esi
  015a6	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  015aa	50		 push	 eax
  015ab	ff 73 18	 push	 DWORD PTR [ebx+24]
  015ae	74 07		 je	 SHORT $LN514@inflate
  015b0	e8 00 00 00 00	 call	 _crc32@12
  015b5	eb 05		 jmp	 SHORT $LN515@inflate
$LN514@inflate:
  015b7	e8 00 00 00 00	 call	 _adler32@12
$LN515@inflate:
  015bc	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  015bf	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN503@inflate:

; 1245 :             UPDATE(state->check, strm->next_out - out, out);
; 1246 :     strm->data_type = state->bits + (state->last ? 64 : 0) +

  015c2	8b 13		 mov	 edx, DWORD PTR [ebx]
  015c4	83 fa 13	 cmp	 edx, 19			; 00000013H
  015c7	74 09		 je	 SHORT $LN516@inflate
  015c9	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  015cc	74 04		 je	 SHORT $LN516@inflate
  015ce	33 f6		 xor	 esi, esi
  015d0	eb 05		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  015d2	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN517@inflate:
  015d7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  015da	f7 d9		 neg	 ecx
  015dc	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv2648[ebp], 128 ; 00000080H
  015e3	1b c9		 sbb	 ecx, ecx
  015e5	33 c0		 xor	 eax, eax
  015e7	83 e1 40	 and	 ecx, 64			; 00000040H
  015ea	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  015ed	0f 44 45 08	 cmove	 eax, DWORD PTR tv2648[ebp]
  015f1	03 ce		 add	 ecx, esi
  015f3	03 c1		 add	 eax, ecx
  015f5	03 43 3c	 add	 eax, DWORD PTR [ebx+60]
  015f8	89 47 2c	 mov	 DWORD PTR [edi+44], eax

; 1247 :                       (state->mode == TYPE ? 128 : 0) +
; 1248 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1249 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  015fb	8b 45 c4	 mov	 eax, DWORD PTR _in$1$[ebp]
  015fe	85 c0		 test	 eax, eax
  01600	75 05		 jne	 SHORT $LN506@inflate
  01602	39 45 dc	 cmp	 DWORD PTR _out$1$[ebp], eax
  01605	74 06		 je	 SHORT $LN505@inflate
$LN506@inflate:
  01607	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0160b	75 16		 jne	 SHORT $LN894@inflate
$LN505@inflate:
  0160d	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01610	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  01615	5f		 pop	 edi
  01616	85 c0		 test	 eax, eax
  01618	5e		 pop	 esi
  01619	0f 44 c1	 cmove	 eax, ecx
  0161c	5b		 pop	 ebx

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  0161d	8b e5		 mov	 esp, ebp
  0161f	5d		 pop	 ebp
  01620	c2 08 00	 ret	 8
$LN894@inflate:
  01623	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01626	5f		 pop	 edi
  01627	5e		 pop	 esi
  01628	5b		 pop	 ebx
  01629	8b e5		 mov	 esp, ebp
  0162b	5d		 pop	 ebp
  0162c	c2 08 00	 ret	 8
$LN333@inflate:

; 629  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 630  :         return Z_STREAM_ERROR;

  0162f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1250 :         ret = Z_BUF_ERROR;
; 1251 :     return ret;
; 1252 : }

  01634	8b e5		 mov	 esp, ebp
  01636	5d		 pop	 ebp
  01637	c2 08 00	 ret	 8
  0163a	66 90		 npad	 2
$LN935@inflate:
  0163c	00 00 00 00	 DD	 $LN335@inflate
  01640	00 00 00 00	 DD	 $LN32@inflate
  01644	00 00 00 00	 DD	 $LN46@inflate
  01648	00 00 00 00	 DD	 $LN60@inflate
  0164c	00 00 00 00	 DD	 $LN360@inflate
  01650	00 00 00 00	 DD	 $LN367@inflate
  01654	00 00 00 00	 DD	 $LN374@inflate
  01658	00 00 00 00	 DD	 $LN383@inflate
  0165c	00 00 00 00	 DD	 $LN392@inflate
  01660	00 00 00 00	 DD	 $LN105@inflate
  01664	00 00 00 00	 DD	 $LN399@inflate
  01668	00 00 00 00	 DD	 $LN401@inflate
  0166c	00 00 00 00	 DD	 $LN402@inflate
  01670	00 00 00 00	 DD	 $LN141@inflate
  01674	00 00 00 00	 DD	 $LN415@inflate
  01678	00 00 00 00	 DD	 $LN417@inflate
  0167c	00 00 00 00	 DD	 $LN155@inflate
  01680	00 00 00 00	 DD	 $LN531@inflate
  01684	00 00 00 00	 DD	 $LN534@inflate
  01688	00 00 00 00	 DD	 $LN447@inflate
  0168c	00 00 00 00	 DD	 $LN449@inflate
  01690	00 00 00 00	 DD	 $LN460@inflate
  01694	00 00 00 00	 DD	 $LN463@inflate
  01698	00 00 00 00	 DD	 $LN470@inflate
  0169c	00 00 00 00	 DD	 $LN473@inflate
  016a0	00 00 00 00	 DD	 $LN484@inflate
  016a4	00 00 00 00	 DD	 $LN486@inflate
  016a8	00 00 00 00	 DD	 $LN491@inflate
  016ac	00 00 00 00	 DD	 $LN495@inflate
  016b0	00 00 00 00	 DD	 $LN496@inflate
  016b4	00 00 00 00	 DD	 $LN497@inflate
$LN936@inflate:
  016b8	00 00 00 00	 DD	 $LN407@inflate
  016bc	00 00 00 00	 DD	 $LN408@inflate
  016c0	00 00 00 00	 DD	 $LN410@inflate
  016c4	00 00 00 00	 DD	 $LN411@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1257 :     struct inflate_state FAR *state;
; 1258 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 3a		 je	 SHORT $LN3@inflateEnd
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 33		 je	 SHORT $LN3@inflateEnd
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 2c		 je	 SHORT $LN3@inflateEnd

; 1260 :     state = (struct inflate_state FAR *)strm->state;
; 1261 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00019	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0001c	85 c0		 test	 eax, eax
  0001e	74 09		 je	 SHORT $LN4@inflateEnd
  00020	50		 push	 eax
  00021	ff 76 28	 push	 DWORD PTR [esi+40]
  00024	ff d1		 call	 ecx
  00026	83 c4 08	 add	 esp, 8
$LN4@inflateEnd:

; 1262 :     ZFREE(strm, strm->state);

  00029	ff 76 1c	 push	 DWORD PTR [esi+28]
  0002c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002f	ff 76 28	 push	 DWORD PTR [esi+40]
  00032	ff d0		 call	 eax
  00034	83 c4 08	 add	 esp, 8

; 1263 :     strm->state = Z_NULL;

  00037	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1264 :     Tracev((stderr, "inflate: end\n"));
; 1265 :     return Z_OK;

  0003e	33 c0		 xor	 eax, eax
  00040	5e		 pop	 esi

; 1266 : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN3@inflateEnd:

; 1259 :         return Z_STREAM_ERROR;

  00045	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004a	5e		 pop	 esi

; 1266 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 8d 00 00
	00		 je	 $LN3@inflateRes
  0000e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00011	85 c9		 test	 ecx, ecx
  00013	0f 84 82 00 00
	00		 je	 $LN3@inflateRes

; 110  :     state = (struct inflate_state FAR *)strm->state;
; 111  :     strm->total_in = strm->total_out = state->total = 0;

  00019	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00020	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 112  :     strm->msg = Z_NULL;

  0002e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 113  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	85 d2		 test	 edx, edx
  0003a	74 06		 je	 SHORT $LN4@inflateRes

; 114  :         strm->adler = state->wrap & 1;

  0003c	83 e2 01	 and	 edx, 1
  0003f	89 50 30	 mov	 DWORD PTR [eax+48], edx
$LN4@inflateRes:

; 115  :     state->mode = HEAD;
; 116  :     state->last = 0;
; 117  :     state->havedict = 0;
; 118  :     state->dmax = 32768U;
; 119  :     state->head = Z_NULL;
; 120  :     state->hold = 0;
; 121  :     state->bits = 0;
; 122  :     state->lencode = state->distcode = state->next = state->codes;

  00042	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00048	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0004e	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00051	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00054	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 123  :     state->sane = 1;
; 124  :     state->back = -1;
; 125  :     Tracev((stderr, "inflate: reset\n"));
; 126  :     return Z_OK;

  00057	33 c0		 xor	 eax, eax
  00059	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00060	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00067	c7 41 14 00 80
	00 00		 mov	 DWORD PTR [ecx+20], 32768 ; 00008000H
  0006e	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00075	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  0007c	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00083	c7 81 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7104], 1
  0008d	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 127  : }

  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
$LN3@inflateRes:

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0009b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 127  : }

  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 146  :     int wrap;
; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     /* get the state */
; 150  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	57		 push	 edi
  00007	85 c0		 test	 eax, eax
  00009	74 73		 je	 SHORT $LN3@inflateRes
  0000b	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  0000e	85 ff		 test	 edi, edi
  00010	74 6c		 je	 SHORT $LN3@inflateRes

; 151  :     state = (struct inflate_state FAR *)strm->state;
; 152  : 
; 153  :     /* extract wrap request from windowBits parameter */
; 154  :     if (windowBits < 0) {

  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	79 06		 jns	 SHORT $LN4@inflateRes

; 155  :         wrap = 0;

  0001b	33 db		 xor	 ebx, ebx

; 156  :         windowBits = -windowBits;

  0001d	f7 de		 neg	 esi

; 157  :     }

  0001f	eb 0e		 jmp	 SHORT $LN6@inflateRes
$LN4@inflateRes:

; 158  :     else {
; 159  :         wrap = (windowBits >> 4) + 1;

  00021	8b de		 mov	 ebx, esi
  00023	c1 fb 04	 sar	 ebx, 4
  00026	43		 inc	 ebx

; 160  : #ifdef GUNZIP
; 161  :         if (windowBits < 48)

  00027	83 fe 30	 cmp	 esi, 48			; 00000030H
  0002a	7d 03		 jge	 SHORT $LN6@inflateRes

; 162  :             windowBits &= 15;

  0002c	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN6@inflateRes:

; 163  : #endif
; 164  :     }
; 165  : 
; 166  :     /* set number of window bits, free window if different */
; 167  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0002f	85 f6		 test	 esi, esi
  00031	74 16		 je	 SHORT $LN7@inflateRes
  00033	83 fe 08	 cmp	 esi, 8
  00036	7c 05		 jl	 SHORT $LN8@inflateRes
  00038	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003b	7e 0c		 jle	 SHORT $LN7@inflateRes
$LN8@inflateRes:
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 168  :         return Z_STREAM_ERROR;

  0003f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00044	5f		 pop	 edi

; 178  : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN7@inflateRes:

; 169  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00049	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0004c	85 c9		 test	 ecx, ecx
  0004e	74 1b		 je	 SHORT $LN9@inflateRes
  00050	39 77 24	 cmp	 DWORD PTR [edi+36], esi
  00053	74 16		 je	 SHORT $LN9@inflateRes

; 170  :         ZFREE(strm, state->window);

  00055	51		 push	 ecx
  00056	ff 70 28	 push	 DWORD PTR [eax+40]
  00059	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0005c	ff d0		 call	 eax
  0005e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00061	83 c4 08	 add	 esp, 8

; 171  :         state->window = Z_NULL;

  00064	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
$LN9@inflateRes:

; 172  :     }
; 173  : 
; 174  :     /* update state and reset the rest of it */
; 175  :     state->wrap = wrap;
; 176  :     state->wbits = (unsigned)windowBits;
; 177  :     return inflateReset(strm);

  0006b	50		 push	 eax
  0006c	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0006f	89 77 24	 mov	 DWORD PTR [edi+36], esi
  00072	e8 00 00 00 00	 call	 _inflateReset@4
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	5f		 pop	 edi

; 178  : }

  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
$LN3@inflateRes:

; 146  :     int wrap;
; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     /* get the state */
; 150  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0007e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00083	5f		 pop	 edi

; 178  : }

  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 227  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 228  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 5c		 je	 SHORT $LN3@inflatePri
  0000a	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0000d	85 d2		 test	 edx, edx
  0000f	74 55		 je	 SHORT $LN3@inflatePri

; 238  :     state = (struct inflate_state FAR *)strm->state;
; 239  :     if (bits < 0) {

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	79 14		 jns	 SHORT $LN4@inflatePri

; 240  :         state->hold = 0;

  00018	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 241  :         state->bits = 0;
; 242  :         return Z_OK;

  0001f	33 c0		 xor	 eax, eax
  00021	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 249  : }

  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflatePri:
  0002c	56		 push	 esi
  0002d	57		 push	 edi

; 243  :     }
; 244  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0002e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00031	7f 28		 jg	 SHORT $LN6@inflatePri
  00033	8b 72 3c	 mov	 esi, DWORD PTR [edx+60]
  00036	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00039	83 ff 20	 cmp	 edi, 32			; 00000020H
  0003c	77 1d		 ja	 SHORT $LN6@inflatePri

; 245  :     value &= (1L << bits) - 1;

  0003e	b8 01 00 00 00	 mov	 eax, 1

; 246  :     state->hold += value << state->bits;
; 247  :     state->bits += bits;

  00043	89 7a 3c	 mov	 DWORD PTR [edx+60], edi
  00046	d3 e0		 shl	 eax, cl
  00048	8b ce		 mov	 ecx, esi
  0004a	48		 dec	 eax
  0004b	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  0004e	d3 e0		 shl	 eax, cl
  00050	01 42 38	 add	 DWORD PTR [edx+56], eax

; 248  :     return Z_OK;

  00053	33 c0		 xor	 eax, eax
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 249  : }

  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflatePri:
  0005b	5f		 pop	 edi

; 243  :     }
; 244  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0005c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00061	5e		 pop	 esi

; 249  : }

  00062	5d		 pop	 ebp
  00063	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:

; 235  :     struct inflate_state FAR *state;
; 236  : 
; 237  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00066	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 249  : }

  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 264  : #ifdef BUILDFIXED
; 265  :     static int virgin = 1;
; 266  :     static code *lenfix, *distfix;
; 267  :     static code fixed[544];
; 268  : 
; 269  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 270  :     if (virgin) {
; 271  :         unsigned sym, bits;
; 272  :         static code *next;
; 273  : 
; 274  :         /* literal/length table */
; 275  :         sym = 0;
; 276  :         while (sym < 144) state->lens[sym++] = 8;
; 277  :         while (sym < 256) state->lens[sym++] = 9;
; 278  :         while (sym < 280) state->lens[sym++] = 7;
; 279  :         while (sym < 288) state->lens[sym++] = 8;
; 280  :         next = fixed;
; 281  :         lenfix = next;
; 282  :         bits = 9;
; 283  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 284  : 
; 285  :         /* distance table */
; 286  :         sym = 0;
; 287  :         while (sym < 32) state->lens[sym++] = 5;
; 288  :         distfix = next;
; 289  :         bits = 5;
; 290  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 291  : 
; 292  :         /* do this just once */
; 293  :         virgin = 0;
; 294  :     }
; 295  : #else /* !BUILDFIXED */
; 296  : #   include "inffixed.h"
; 297  : #endif /* BUILDFIXED */
; 298  :     state->lencode = lenfix;

  00000	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 299  :     state->lenbits = 9;

  00007	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 300  :     state->distcode = distfix;

  0000e	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 301  :     state->distbits = 5;

  00015	c7 41 58 05 00
	00 00		 mov	 DWORD PTR [ecx+88], 5

; 302  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_end$1$ = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c2		 mov	 eax, edx
  00006	8b d1		 mov	 edx, ecx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	89 45 fc	 mov	 DWORD PTR _end$1$[ebp], eax

; 384  :     struct inflate_state FAR *state;
; 385  :     unsigned dist;
; 386  : 
; 387  :     state = (struct inflate_state FAR *)strm->state;
; 388  : 
; 389  :     /* if it hasn't been done already, allocate space for the window */
; 390  :     if (state->window == Z_NULL) {

  0000d	bf 01 00 00 00	 mov	 edi, 1
  00012	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  00015	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  00019	75 26		 jne	 SHORT $LN3@updatewind

; 391  :         state->window = (unsigned char FAR *)

  0001b	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0001e	8b c7		 mov	 eax, edi
  00020	d3 e0		 shl	 eax, cl
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	ff 72 28	 push	 DWORD PTR [edx+40]
  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002a	ff d0		 call	 eax
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 392  :                         ZALLOC(strm, 1U << state->wbits,
; 393  :                                sizeof(unsigned char));
; 394  :         if (state->window == Z_NULL) return 1;

  00032	85 c0		 test	 eax, eax
  00034	75 08		 jne	 SHORT $LN13@updatewind
  00036	8b c7		 mov	 eax, edi
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 427  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN13@updatewind:
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
$LN3@updatewind:

; 395  :     }
; 396  : 
; 397  :     /* if window not in use yet, initialize */
; 398  :     if (state->wsize == 0) {

  00041	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00045	75 16		 jne	 SHORT $LN4@updatewind

; 399  :         state->wsize = 1U << state->wbits;

  00047	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0004a	d3 e7		 shl	 edi, cl
  0004c	89 7e 28	 mov	 DWORD PTR [esi+40], edi

; 400  :         state->wnext = 0;

  0004f	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 401  :         state->whave = 0;

  00056	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN4@updatewind:

; 402  :     }
; 403  : 
; 404  :     /* copy state->wsize or less output bytes into the circular window */
; 405  :     if (copy >= state->wsize) {

  0005d	8b 7e 28	 mov	 edi, DWORD PTR [esi+40]
  00060	53		 push	 ebx
  00061	8b 5d 08	 mov	 ebx, DWORD PTR _copy$[ebp]
  00064	3b df		 cmp	 ebx, edi
  00066	72 25		 jb	 SHORT $LN5@updatewind

; 406  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00068	57		 push	 edi
  00069	2b c7		 sub	 eax, edi
  0006b	50		 push	 eax
  0006c	ff 76 34	 push	 DWORD PTR [esi+52]
  0006f	e8 00 00 00 00	 call	 _memcpy

; 407  :         state->wnext = 0;
; 408  :         state->whave = state->wsize;

  00074	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  0007a	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 424  :         }
; 425  :     }
; 426  :     return 0;

  0007d	33 c0		 xor	 eax, eax
  0007f	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  00086	5b		 pop	 ebx
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 427  : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN5@updatewind:

; 409  :     }
; 410  :     else {
; 411  :         dist = state->wsize - state->wnext;

  0008d	2b 7e 30	 sub	 edi, DWORD PTR [esi+48]

; 412  :         if (dist > copy) dist = copy;

  00090	3b fb		 cmp	 edi, ebx
  00092	0f 47 fb	 cmova	 edi, ebx

; 413  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00095	2b c3		 sub	 eax, ebx
  00097	57		 push	 edi
  00098	50		 push	 eax
  00099	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0009c	03 46 30	 add	 eax, DWORD PTR [esi+48]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _memcpy
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 414  :         copy -= dist;

  000a8	2b df		 sub	 ebx, edi

; 415  :         if (copy) {

  000aa	74 24		 je	 SHORT $LN8@updatewind

; 416  :             zmemcpy(state->window, end - copy, copy);

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
  000af	53		 push	 ebx
  000b0	2b c3		 sub	 eax, ebx
  000b2	50		 push	 eax
  000b3	ff 76 34	 push	 DWORD PTR [esi+52]
  000b6	e8 00 00 00 00	 call	 _memcpy

; 417  :             state->wnext = copy;
; 418  :             state->whave = state->wsize;

  000bb	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 5e 30	 mov	 DWORD PTR [esi+48], ebx

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  000c4	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 424  :         }
; 425  :     }
; 426  :     return 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	5b		 pop	 ebx
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi

; 427  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
$LN8@updatewind:

; 419  :         }
; 420  :         else {
; 421  :             state->wnext += dist;

  000d0	01 7e 30	 add	 DWORD PTR [esi+48], edi

; 422  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d3	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  000d6	39 4e 30	 cmp	 DWORD PTR [esi+48], ecx
  000d9	75 07		 jne	 SHORT $LN10@updatewind
  000db	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN10@updatewind:

; 423  :             if (state->whave < state->wsize) state->whave += dist;

  000e2	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000e5	3b c1		 cmp	 eax, ecx
  000e7	73 05		 jae	 SHORT $LN11@updatewind
  000e9	03 c7		 add	 eax, edi
  000eb	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN11@updatewind:

; 424  :         }
; 425  :     }
; 426  :     return 0;

  000ee	5b		 pop	 ebx
  000ef	5f		 pop	 edi
  000f0	33 c0		 xor	 eax, eax
  000f2	5e		 pop	 esi

; 427  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1272 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1273 :     struct inflate_state FAR *state;
; 1274 : 
; 1275 :     /* check state */
; 1276 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 52		 je	 SHORT $LN3@inflateGet
  0000b	8b 76 1c	 mov	 esi, DWORD PTR [esi+28]
  0000e	85 f6		 test	 esi, esi
  00010	74 4b		 je	 SHORT $LN3@inflateGet

; 1277 :     state = (struct inflate_state FAR *)strm->state;
; 1278 : 
; 1279 :     /* copy dictionary */
; 1280 :     if (state->whave && dictionary != Z_NULL) {

  00012	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00015	85 c0		 test	 eax, eax
  00017	74 31		 je	 SHORT $LN4@inflateGet
  00019	57		 push	 edi
  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  0001d	85 ff		 test	 edi, edi
  0001f	74 28		 je	 SHORT $LN7@inflateGet

; 1281 :         zmemcpy(dictionary, state->window + state->wnext,

  00021	2b 46 30	 sub	 eax, DWORD PTR [esi+48]
  00024	50		 push	 eax
  00025	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00028	03 46 30	 add	 eax, DWORD PTR [esi+48]
  0002b	50		 push	 eax
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 _memcpy

; 1282 :                 state->whave - state->wnext);
; 1283 :         zmemcpy(dictionary + state->whave - state->wnext,

  00032	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00035	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00038	51		 push	 ecx
  00039	ff 76 34	 push	 DWORD PTR [esi+52]
  0003c	2b c1		 sub	 eax, ecx
  0003e	03 c7		 add	 eax, edi
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _memcpy
  00046	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@inflateGet:
  00049	5f		 pop	 edi
$LN4@inflateGet:

; 1284 :                 state->window, state->wnext);
; 1285 :     }
; 1286 :     if (dictLength != Z_NULL)

  0004a	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 05		 je	 SHORT $LN5@inflateGet

; 1287 :         *dictLength = state->whave;

  00051	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00054	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@inflateGet:

; 1288 :     return Z_OK;

  00056	33 c0		 xor	 eax, eax
  00058	5e		 pop	 esi

; 1289 : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflateGet:

; 1273 :     struct inflate_state FAR *state;
; 1274 : 
; 1275 :     /* check state */
; 1276 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0005d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00062	5e		 pop	 esi

; 1289 : }

  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	0f 84 84 00 00
	00		 je	 $LN3@inflateSet
  00010	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00013	85 f6		 test	 esi, esi
  00015	74 7d		 je	 SHORT $LN3@inflateSet

; 1302 :     state = (struct inflate_state FAR *)strm->state;
; 1303 :     if (state->wrap != 0 && state->mode != DICT)

  00017	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0001b	53		 push	 ebx
  0001c	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  0001f	74 11		 je	 SHORT $LN4@inflateSet
  00021	83 3e 0a	 cmp	 DWORD PTR [esi], 10	; 0000000aH
  00024	74 11		 je	 SHORT $LN9@inflateSet

; 1304 :         return Z_STREAM_ERROR;

  00026	5b		 pop	 ebx
  00027	5f		 pop	 edi
  00028	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002d	5e		 pop	 esi

; 1324 : }

  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflateSet:

; 1305 : 
; 1306 :     /* check for correct dictionary identifier */
; 1307 :     if (state->mode == DICT) {

  00032	83 3e 0a	 cmp	 DWORD PTR [esi], 10	; 0000000aH
  00035	75 26		 jne	 SHORT $LN6@inflateSet
$LN9@inflateSet:

; 1308 :         dictid = adler32(0L, Z_NULL, 0);
; 1309 :         dictid = adler32(dictid, dictionary, dictLength);

  00037	53		 push	 ebx
  00038	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	e8 00 00 00 00	 call	 _adler32@12
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _adler32@12

; 1310 :         if (dictid != state->check)

  0004c	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  0004f	74 0c		 je	 SHORT $LN6@inflateSet

; 1311 :             return Z_DATA_ERROR;

  00051	5b		 pop	 ebx
  00052	5f		 pop	 edi
  00053	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00058	5e		 pop	 esi

; 1324 : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:

; 1312 :     }
; 1313 : 
; 1314 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1315 :        existing dictionary if appropriate */
; 1316 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0005d	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  00060	8b cf		 mov	 ecx, edi
  00062	53		 push	 ebx
  00063	8d 14 1a	 lea	 edx, DWORD PTR [edx+ebx]
  00066	e8 00 00 00 00	 call	 _updatewindow
  0006b	83 c4 04	 add	 esp, 4

; 1317 :     if (ret) {

  0006e	85 c0		 test	 eax, eax
  00070	74 12		 je	 SHORT $LN7@inflateSet

; 1318 :         state->mode = MEM;

  00072	5b		 pop	 ebx
  00073	5f		 pop	 edi
  00074	c7 06 1e 00 00
	00		 mov	 DWORD PTR [esi], 30	; 0000001eH

; 1319 :         return Z_MEM_ERROR;

  0007a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007f	5e		 pop	 esi

; 1324 : }

  00080	5d		 pop	 ebp
  00081	c2 0c 00	 ret	 12			; 0000000cH
$LN7@inflateSet:
  00084	5b		 pop	 ebx
  00085	5f		 pop	 edi

; 1320 :     }
; 1321 :     state->havedict = 1;

  00086	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1

; 1322 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1323 :     return Z_OK;

  0008d	33 c0		 xor	 eax, eax
  0008f	5e		 pop	 esi

; 1324 : }

  00090	5d		 pop	 ebp
  00091	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflateSet:
  00094	5f		 pop	 edi

; 1296 :     struct inflate_state FAR *state;
; 1297 :     unsigned long dictid;
; 1298 :     int ret;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00095	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0009a	5e		 pop	 esi

; 1324 : }

  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 20		 je	 SHORT $LN3@inflateGet
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 19		 je	 SHORT $LN3@inflateGet

; 1334 :     state = (struct inflate_state FAR *)strm->state;
; 1335 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 41 08 02	 test	 BYTE PTR [ecx+8], 2
  00015	74 13		 je	 SHORT $LN3@inflateGet

; 1336 : 
; 1337 :     /* save header structure */
; 1338 :     state->head = head;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1339 :     head->done = 0;

  0001d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1340 :     return Z_OK;

  00024	33 c0		 xor	 eax, eax

; 1341 : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
$LN3@inflateGet:

; 1330 :     struct inflate_state FAR *state;
; 1331 : 
; 1332 :     /* check state */
; 1333 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1341 : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1359 :     unsigned got;
; 1360 :     unsigned next;
; 1361 : 
; 1362 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1363 :     next = 0;
; 1364 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1365 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1366 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1367 :         else if (buf[next])
; 1368 :             got = 0;
; 1369 :         else
; 1370 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1371 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1372 :     }
; 1373 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1374 :     return next;

  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi

; 1375 : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1372 :     }
; 1373 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1374 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 1375 : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_in$1$ = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 db		 test	 ebx, ebx
  0000a	0f 84 cf 00 00
	00		 je	 $LN5@inflateSyn
  00010	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 c4 00 00
	00		 je	 $LN5@inflateSyn

; 1387 :     state = (struct inflate_state FAR *)strm->state;
; 1388 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001b	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0001f	75 11		 jne	 SHORT $LN6@inflateSyn
  00021	83 7f 3c 08	 cmp	 DWORD PTR [edi+60], 8
  00025	73 0b		 jae	 SHORT $LN6@inflateSyn
  00027	5f		 pop	 edi
  00028	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0002d	5b		 pop	 ebx

; 1418 : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN6@inflateSyn:

; 1389 : 
; 1390 :     /* if first time, start search in bit buffer */
; 1391 :     if (state->mode != SYNC) {

  00032	83 3f 1f	 cmp	 DWORD PTR [edi], 31	; 0000001fH
  00035	56		 push	 esi
  00036	74 56		 je	 SHORT $LN7@inflateSyn

; 1392 :         state->mode = SYNC;
; 1393 :         state->hold <<= state->bits & 7;

  00038	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]

; 1394 :         state->bits -= state->bits & 7;
; 1395 :         len = 0;

  0003b	33 f6		 xor	 esi, esi
  0003d	8b ca		 mov	 ecx, edx
  0003f	c7 07 1f 00 00
	00		 mov	 DWORD PTR [edi], 31	; 0000001fH
  00045	83 e1 07	 and	 ecx, 7
  00048	d3 67 38	 shl	 DWORD PTR [edi+56], cl
  0004b	2b d1		 sub	 edx, ecx
  0004d	89 57 3c	 mov	 DWORD PTR [edi+60], edx

; 1396 :         while (state->bits >= 8) {

  00050	83 fa 08	 cmp	 edx, 8
  00053	72 24		 jb	 SHORT $LN3@inflateSyn
  00055	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@inflateSyn:

; 1397 :             buf[len++] = (unsigned char)(state->hold);

  00060	8a 47 38	 mov	 al, BYTE PTR [edi+56]

; 1398 :             state->hold >>= 8;
; 1399 :             state->bits -= 8;

  00063	83 ea 08	 sub	 edx, 8
  00066	88 44 35 08	 mov	 BYTE PTR _buf$[ebp+esi], al
  0006a	46		 inc	 esi
  0006b	c1 e9 08	 shr	 ecx, 8
  0006e	89 4f 38	 mov	 DWORD PTR [edi+56], ecx
  00071	83 fa 08	 cmp	 edx, 8
  00074	73 ea		 jae	 SHORT $LL2@inflateSyn
  00076	89 57 3c	 mov	 DWORD PTR [edi+60], edx
$LN3@inflateSyn:

; 1400 :         }
; 1401 :         state->have = 0;

  00079	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]

; 1402 :         syncsearch(&(state->have), buf, len);

  0007c	8d 55 08	 lea	 edx, DWORD PTR _buf$[ebp]
  0007f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 _syncsearch
  0008b	83 c4 04	 add	 esp, 4
$LN7@inflateSyn:

; 1403 :     }
; 1404 : 
; 1405 :     /* search available input */
; 1406 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  0008e	ff 73 04	 push	 DWORD PTR [ebx+4]
  00091	8b 13		 mov	 edx, DWORD PTR [ebx]
  00093	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  00096	e8 00 00 00 00	 call	 _syncsearch

; 1407 :     strm->avail_in -= len;

  0009b	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  0009e	83 c4 04	 add	 esp, 4

; 1408 :     strm->next_in += len;

  000a1	01 03		 add	 DWORD PTR [ebx], eax

; 1409 :     strm->total_in += len;

  000a3	01 43 08	 add	 DWORD PTR [ebx+8], eax

; 1410 : 
; 1411 :     /* return no joy or set up to restart inflate() on a new block */
; 1412 :     if (state->have != 4) return Z_DATA_ERROR;

  000a6	83 7f 68 04	 cmp	 DWORD PTR [edi+104], 4
  000aa	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000ad	89 45 08	 mov	 DWORD PTR _in$1$[ebp], eax
  000b0	74 0c		 je	 SHORT $LN8@inflateSyn
  000b2	5e		 pop	 esi
  000b3	5f		 pop	 edi
  000b4	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000b9	5b		 pop	 ebx

; 1418 : }

  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN8@inflateSyn:

; 1413 :     in = strm->total_in;  out = strm->total_out;

  000be	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1414 :     inflateReset(strm);

  000c1	53		 push	 ebx
  000c2	e8 00 00 00 00	 call	 _inflateReset@4

; 1415 :     strm->total_in = in;  strm->total_out = out;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _in$1$[ebp]
  000ca	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000cd	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1416 :     state->mode = TYPE;
; 1417 :     return Z_OK;

  000d0	33 c0		 xor	 eax, eax
  000d2	5e		 pop	 esi
  000d3	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH
  000d9	5f		 pop	 edi
  000da	5b		 pop	 ebx

; 1418 : }

  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
$LN5@inflateSyn:
  000df	5f		 pop	 edi

; 1380 :     unsigned len;               /* number of bytes to look at or looked at */
; 1381 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1382 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1383 :     struct inflate_state FAR *state;
; 1384 : 
; 1385 :     /* check parameters */
; 1386 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000e0	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000e5	5b		 pop	 ebx

; 1418 : }

  000e6	5d		 pop	 ebp
  000e7	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 21		 je	 SHORT $LN3@inflateSyn
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 1a		 je	 SHORT $LN3@inflateSyn

; 1434 :     state = (struct inflate_state FAR *)strm->state;
; 1435 :     return state->mode == STORED && state->bits == 0;

  00011	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  00014	75 0f		 jne	 SHORT $LN5@inflateSyn
  00016	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0001a	75 09		 jne	 SHORT $LN5@inflateSyn
  0001c	b8 01 00 00 00	 mov	 eax, 1

; 1436 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1434 :     state = (struct inflate_state FAR *)strm->state;
; 1435 :     return state->mode == STORED && state->bits == 0;

  00025	33 c0		 xor	 eax, eax

; 1436 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN3@inflateSyn:

; 1431 :     struct inflate_state FAR *state;
; 1432 : 
; 1433 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1436 : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1442 :     struct inflate_state FAR *state;
; 1443 :     struct inflate_state FAR *copy;
; 1444 :     unsigned char FAR *window;
; 1445 :     unsigned wsize;
; 1446 : 
; 1447 :     /* check input */
; 1448 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1449 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	85 c0		 test	 eax, eax
  0000a	0f 84 44 01 00
	00		 je	 $LN3@inflateCop
  00010	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00013	85 f6		 test	 esi, esi
  00015	0f 84 39 01 00
	00		 je	 $LN3@inflateCop
  0001b	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  0001e	85 ff		 test	 edi, edi
  00020	0f 84 2e 01 00
	00		 je	 $LN3@inflateCop
  00026	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 23 01 00
	00		 je	 $LN3@inflateCop
  00031	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00035	0f 84 19 01 00
	00		 je	 $LN3@inflateCop

; 1451 :     state = (struct inflate_state FAR *)source->state;
; 1452 : 
; 1453 :     /* allocate space */
; 1454 :     copy = (struct inflate_state FAR *)

  0003b	53		 push	 ebx
  0003c	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00041	6a 01		 push	 1
  00043	ff 76 28	 push	 DWORD PTR [esi+40]
  00046	ff d0		 call	 eax
  00048	8b d8		 mov	 ebx, eax
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1455 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1456 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0004d	85 db		 test	 ebx, ebx
  0004f	74 38		 je	 SHORT $LN11@inflateCop

; 1457 :     window = Z_NULL;
; 1458 :     if (state->window != Z_NULL) {

  00051	83 7f 34 00	 cmp	 DWORD PTR [edi+52], 0
  00055	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  0005c	74 37		 je	 SHORT $LN6@inflateCop

; 1459 :         window = (unsigned char FAR *)

  0005e	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	d3 e0		 shl	 eax, cl
  00068	6a 01		 push	 1
  0006a	50		 push	 eax
  0006b	ff 76 28	 push	 DWORD PTR [esi+40]
  0006e	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00071	ff d0		 call	 eax
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1460 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1461 :         if (window == Z_NULL) {

  00079	85 c0		 test	 eax, eax
  0007b	75 18		 jne	 SHORT $LN6@inflateCop

; 1462 :             ZFREE(source, copy);

  0007d	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00080	53		 push	 ebx
  00081	ff 76 28	 push	 DWORD PTR [esi+40]
  00084	ff d0		 call	 eax
  00086	83 c4 08	 add	 esp, 8
$LN11@inflateCop:

; 1463 :             return Z_MEM_ERROR;

  00089	5b		 pop	 ebx
  0008a	5f		 pop	 edi
  0008b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00090	5e		 pop	 esi

; 1483 : }

  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
$LN6@inflateCop:

; 1464 :         }
; 1465 :     }
; 1466 : 
; 1467 :     /* copy state */
; 1468 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00095	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00098	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1469 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  0009b	68 cc 1b 00 00	 push	 7116			; 00001bccH
  000a0	57		 push	 edi
  000a1	53		 push	 ebx
  000a2	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  000a5	0f 10 46 10	 movups	 xmm0, XMMWORD PTR [esi+16]
  000a9	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  000ad	0f 10 46 20	 movups	 xmm0, XMMWORD PTR [esi+32]
  000b1	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000b5	f3 0f 7e 46 30	 movq	 xmm0, QWORD PTR [esi+48]
  000ba	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000bf	e8 00 00 00 00	 call	 _memcpy

; 1470 :     if (state->lencode >= state->codes &&

  000c4	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  000c7	8d 87 30 05 00
	00		 lea	 eax, DWORD PTR [edi+1328]
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	3b c8		 cmp	 ecx, eax
  000d2	72 38		 jb	 SHORT $LN7@inflateCop
  000d4	8d 87 bc 1b 00
	00		 lea	 eax, DWORD PTR [edi+7100]
  000da	3b c8		 cmp	 ecx, eax
  000dc	77 2e		 ja	 SHORT $LN7@inflateCop

; 1471 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1472 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000de	2b cf		 sub	 ecx, edi
  000e0	8d 81 d0 fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1328]
  000e6	c1 f8 02	 sar	 eax, 2
  000e9	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  000ee	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  000f1	89 43 4c	 mov	 DWORD PTR [ebx+76], eax

; 1473 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000f4	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  000f7	2b c7		 sub	 eax, edi
  000f9	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  000fe	c1 f8 02	 sar	 eax, 2
  00101	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  00106	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00109	89 43 50	 mov	 DWORD PTR [ebx+80], eax
$LN7@inflateCop:

; 1474 :     }
; 1475 :     copy->next = copy->codes + (state->next - state->codes);

  0010c	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]

; 1476 :     if (window != Z_NULL) {

  0010f	8b 75 0c	 mov	 esi, DWORD PTR _window$1$[ebp]
  00112	2b c7		 sub	 eax, edi
  00114	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  00119	c1 f8 02	 sar	 eax, 2
  0011c	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  00121	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00124	89 43 6c	 mov	 DWORD PTR [ebx+108], eax
  00127	85 f6		 test	 esi, esi
  00129	74 17		 je	 SHORT $LN8@inflateCop

; 1477 :         wsize = 1U << state->wbits;

  0012b	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  0012e	b8 01 00 00 00	 mov	 eax, 1
  00133	d3 e0		 shl	 eax, cl

; 1478 :         zmemcpy(window, state->window, wsize);

  00135	50		 push	 eax
  00136	ff 77 34	 push	 DWORD PTR [edi+52]
  00139	56		 push	 esi
  0013a	e8 00 00 00 00	 call	 _memcpy
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1479 :     }
; 1480 :     copy->window = window;
; 1481 :     dest->state = (struct internal_state FAR *)copy;

  00142	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00145	89 73 34	 mov	 DWORD PTR [ebx+52], esi
  00148	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 1482 :     return Z_OK;

  0014b	33 c0		 xor	 eax, eax
  0014d	5b		 pop	 ebx
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi

; 1483 : }

  00150	5d		 pop	 ebp
  00151	c2 08 00	 ret	 8
$LN3@inflateCop:
  00154	5f		 pop	 edi

; 1450 :         return Z_STREAM_ERROR;

  00155	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0015a	5e		 pop	 esi

; 1483 : }

  0015b	5d		 pop	 ebp
  0015c	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1488 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN3@inflateUnd
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 13		 je	 SHORT $LN3@inflateUnd

; 1492 :     state = (struct inflate_state FAR *)strm->state;
; 1493 :     state->sane = !subvert;
; 1494 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1495 :     return Z_OK;
; 1496 : #else
; 1497 :     state->sane = 1;

  00011	c7 80 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7104], 1

; 1498 :     return Z_DATA_ERROR;

  0001b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1499 : #endif
; 1500 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@inflateUnd:

; 1489 :     struct inflate_state FAR *state;
; 1490 : 
; 1491 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00024	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1499 : #endif
; 1500 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1504 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 4e		 je	 SHORT $LN3@inflateMar
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 47		 je	 SHORT $LN3@inflateMar

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +

  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00016	75 12		 jne	 SHORT $LN7@inflateMar
  00018	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001b	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  00021	c1 e0 10	 shl	 eax, 16			; 00000010H
  00024	03 c1		 add	 eax, ecx

; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1512 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN7@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +

  0002a	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0002d	75 18		 jne	 SHORT $LN5@inflateMar
  0002f	8b 88 c8 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7112]
  00035	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00038	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0003e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00041	03 c1		 add	 eax, ecx

; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1512 : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@inflateMar:

; 1508 :     state = (struct inflate_state FAR *)strm->state;
; 1509 :     return ((long)(state->back) << 16) +

  00047	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0004d	33 c9		 xor	 ecx, ecx
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1512 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN3@inflateMar:

; 1505 :     struct inflate_state FAR *state;
; 1506 : 
; 1507 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00058	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1510 :         (state->mode == COPY ? state->length :
; 1511 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1512 : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
END
