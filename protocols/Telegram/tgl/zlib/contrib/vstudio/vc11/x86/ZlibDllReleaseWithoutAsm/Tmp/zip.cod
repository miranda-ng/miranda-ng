; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
EXTRN	__imp___time64:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__srand:PROC
?calls@?1??crypthead@@9@9 DD 01H DUP (?)		; `crypthead'::`2'::calls
_BSS	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
PUBLIC	_zipClose@8
PUBLIC	_Write_GlobalComment
PUBLIC	_Write_EndOfCentralDirectoryRecord
PUBLIC	_Write_Zip64EndOfCentralDirectoryRecord
PUBLIC	_Write_Zip64EndOfCentralDirectoryLocator
PUBLIC	_zipCloseFileInZip@4
PUBLIC	_zipCloseFileInZipRaw64@16
PUBLIC	_zipCloseFileInZipRaw@12
PUBLIC	_zipWriteInFileInZip@12
PUBLIC	_zipOpenNewFileInZip@40
PUBLIC	_zipOpenNewFileInZip64@44
PUBLIC	_zipOpenNewFileInZip2_64@48
PUBLIC	_zipOpenNewFileInZip2@44
PUBLIC	_zipOpenNewFileInZip3_64@68
PUBLIC	_zipOpenNewFileInZip3@64
PUBLIC	_zipOpenNewFileInZip4_64@76
PUBLIC	_Write_LocalFileHeader
PUBLIC	_zipOpen64@8
PUBLIC	_zipOpen@8
PUBLIC	_zipOpen2_64@16
PUBLIC	_zipOpen2@16
PUBLIC	_zipOpen3@16
PUBLIC	_LoadCentralDirectoryRecord
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$dead$ = ecx

; 535  :             return _time64(_Time);

  00000	6a 00		 push	 0
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00008	83 c4 04	 add	 esp, 4

; 536  :         }

  0000b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\crypt.h
;	COMDAT _decrypt_byte
_TEXT	SEGMENT
_decrypt_byte PROC					; COMDAT
; _pkeys$ = ecx
; _pcrc_32_tab$dead$ = edx

; 37   :     unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
; 38   :                      * unpredictable manner on 16-bit systems; not a problem
; 39   :                      * with any known compiler so far, though */
; 40   : 
; 41   :     temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	81 e1 fd ff 00
	00		 and	 ecx, 65533		; 0000fffdH
  00009	83 c9 02	 or	 ecx, 2

; 42   :     return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);

  0000c	8b c1		 mov	 eax, ecx
  0000e	83 f0 01	 xor	 eax, 1
  00011	0f af c1	 imul	 eax, ecx
  00014	c1 e8 08	 shr	 eax, 8
  00017	0f b6 c0	 movzx	 eax, al

; 43   : }

  0001a	c3		 ret	 0
_decrypt_byte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\crypt.h
;	COMDAT _update_keys
_TEXT	SEGMENT
_pkeys$1$ = -4						; size = 4
_c$ = 8							; size = 4
_update_keys PROC					; COMDAT
; _pkeys$ = ecx
; _pcrc_32_tab$ = edx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 50   :     (*(pkeys+0)) = CRC32((*(pkeys+0)), c);

  00006	8b 31		 mov	 esi, DWORD PTR [ecx]
  00008	8b da		 mov	 ebx, edx

; 51   :     (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
; 52   :     (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
; 53   :     {
; 54   :       register int keyshift = (int)((*(pkeys+1)) >> 24);
; 55   :       (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);

  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	8b c6		 mov	 eax, esi
  0000f	33 45 08	 xor	 eax, DWORD PTR _c$[ebp]
  00012	0f b6 c0	 movzx	 eax, al
  00015	c1 ee 08	 shr	 esi, 8
  00018	89 4d fc	 mov	 DWORD PTR _pkeys$1$[ebp], ecx
  0001b	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  0001e	33 c6		 xor	 eax, esi
  00020	89 01		 mov	 DWORD PTR [ecx], eax
  00022	0f b6 c0	 movzx	 eax, al
  00025	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00028	69 c0 05 84 08
	08		 imul	 eax, eax, 134775813
  0002e	5e		 pop	 esi
  0002f	40		 inc	 eax
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00033	c1 e8 18	 shr	 eax, 24			; 00000018H
  00036	33 c2		 xor	 eax, edx
  00038	c1 ea 08	 shr	 edx, 8
  0003b	0f b6 c8	 movzx	 ecx, al
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _pkeys$1$[ebp]
  00041	33 14 8b	 xor	 edx, DWORD PTR [ebx+ecx*4]
  00044	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 56   :     }
; 57   :     return c;

  00047	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0004a	5b		 pop	 ebx

; 58   : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_update_keys ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\crypt.h
;	COMDAT _init_keys
_TEXT	SEGMENT
_pcrc_32_tab$ = 8					; size = 4
_init_keys PROC						; COMDAT
; _passwd$ = ecx
; _pkeys$ = edx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b fa		 mov	 edi, edx
  00007	8b f1		 mov	 esi, ecx

; 67   :     *(pkeys+0) = 305419896L;

  00009	c7 07 78 56 34
	12		 mov	 DWORD PTR [edi], 305419896 ; 12345678H

; 68   :     *(pkeys+1) = 591751049L;

  0000f	c7 47 04 89 67
	45 23		 mov	 DWORD PTR [edi+4], 591751049 ; 23456789H

; 69   :     *(pkeys+2) = 878082192L;

  00016	c7 47 08 90 78
	56 34		 mov	 DWORD PTR [edi+8], 878082192 ; 34567890H

; 70   :     while (*passwd != '\0') {

  0001d	8a 06		 mov	 al, BYTE PTR [esi]
  0001f	84 c0		 test	 al, al
  00021	74 1f		 je	 SHORT $LN3@init_keys
  00023	53		 push	 ebx
  00024	8b 5d 08	 mov	 ebx, DWORD PTR _pcrc_32_tab$[ebp]
$LL2@init_keys:

; 71   :         update_keys(pkeys,pcrc_32_tab,(int)*passwd);

  00027	0f be c0	 movsx	 eax, al
  0002a	8b d3		 mov	 edx, ebx
  0002c	50		 push	 eax
  0002d	8b cf		 mov	 ecx, edi
  0002f	e8 00 00 00 00	 call	 _update_keys
  00034	8a 46 01	 mov	 al, BYTE PTR [esi+1]

; 72   :         passwd++;

  00037	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  0003a	83 c4 04	 add	 esp, 4
  0003d	84 c0		 test	 al, al
  0003f	75 e6		 jne	 SHORT $LL2@init_keys
  00041	5b		 pop	 ebx
$LN3@init_keys:
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 73   :     }
; 74   : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_init_keys ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\crypt.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\crypt.h
;	COMDAT _crypthead
_TEXT	SEGMENT
_header$ = -28						; size = 10
tv254 = -16						; size = 4
_t$3$ = -16						; size = 4
_passwd$1$ = -16					; size = 4
_c$1$ = -12						; size = 4
_buf$1$ = -8						; size = 4
tv247 = -1						; size = 1
_bufSize$dead$ = 8					; size = 4
_pkeys$ = 12						; size = 4
_pcrc_32_tab$ = 16					; size = 4
_crcForCrypting$ = 20					; size = 4
_crypthead PROC						; COMDAT
; _passwd$ = ecx
; _buf$ = edx

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 97   :     int n;                       /* index in random header */
; 98   :     int t;                       /* temporary */
; 99   :     int c;                       /* random byte */
; 100  :     unsigned char header[RAND_HEAD_LEN-2]; /* random header */
; 101  :     static unsigned calls = 0;   /* ensure different random header each time */
; 102  : 
; 103  :     if (bufSize<RAND_HEAD_LEN)
; 104  :       return 0;
; 105  : 
; 106  :     /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
; 107  :      * output of rand() to get less predictability, since rand() is
; 108  :      * often poorly implemented.
; 109  :      */
; 110  :     if (++calls == 1)

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?calls@?1??crypthead@@9@9
  0000b	53		 push	 ebx
  0000c	40		 inc	 eax
  0000d	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?calls@?1??crypthead@@9@9, eax
  00015	8b d9		 mov	 ebx, ecx
  00017	89 5d f0	 mov	 DWORD PTR _passwd$1$[ebp], ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	83 f8 01	 cmp	 eax, 1
  0001f	75 17		 jne	 SHORT $LN9@crypthead
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00021	6a 00		 push	 0
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\crypt.h

; 112  :         srand((unsigned)(time(NULL) ^ ZCR_SEED2));

  00029	35 4e e6 40 bb	 xor	 eax, -1153374642	; bb40e64eH
  0002e	50		 push	 eax
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  00035	83 c4 08	 add	 esp, 8
$LN9@crypthead:

; 113  :     }
; 114  :     init_keys(passwd, pkeys, pcrc_32_tab);

  00038	ff 75 10	 push	 DWORD PTR _pcrc_32_tab$[ebp]
  0003b	8b 7d 0c	 mov	 edi, DWORD PTR _pkeys$[ebp]
  0003e	8b cb		 mov	 ecx, ebx
  00040	8b d7		 mov	 edx, edi
  00042	e8 00 00 00 00	 call	 _init_keys
  00047	83 c4 04	 add	 esp, 4

; 115  :     for (n = 0; n < RAND_HEAD_LEN-2; n++)

  0004a	33 f6		 xor	 esi, esi
  0004c	0f 1f 40 00	 npad	 4
$LL4@crypthead:

; 116  :     {
; 117  :         c = (rand() >> 7) & 0xff;

  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00056	c1 f8 07	 sar	 eax, 7

; 118  :         header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);

  00059	8b cf		 mov	 ecx, edi
  0005b	0f b6 d0	 movzx	 edx, al
  0005e	89 55 f4	 mov	 DWORD PTR _c$1$[ebp], edx
  00061	e8 00 00 00 00	 call	 _decrypt_byte
  00066	52		 push	 edx
  00067	8b 55 10	 mov	 edx, DWORD PTR _pcrc_32_tab$[ebp]
  0006a	8b cf		 mov	 ecx, edi
  0006c	8b d8		 mov	 ebx, eax
  0006e	e8 00 00 00 00	 call	 _update_keys
  00073	8b 45 f4	 mov	 eax, DWORD PTR _c$1$[ebp]
  00076	83 c4 04	 add	 esp, 4
  00079	32 c3		 xor	 al, bl
  0007b	88 44 35 e4	 mov	 BYTE PTR _header$[ebp+esi], al
  0007f	46		 inc	 esi
  00080	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00083	7c cb		 jl	 SHORT $LL4@crypthead

; 119  :     }
; 120  :     /* Encrypt random header (last two bytes is high word of crc) */
; 121  :     init_keys(passwd, pkeys, pcrc_32_tab);

  00085	ff 75 10	 push	 DWORD PTR _pcrc_32_tab$[ebp]
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _passwd$1$[ebp]
  0008b	8b d7		 mov	 edx, edi
  0008d	e8 00 00 00 00	 call	 _init_keys

; 122  :     for (n = 0; n < RAND_HEAD_LEN-2; n++)

  00092	8b 45 f8	 mov	 eax, DWORD PTR _buf$1$[ebp]
  00095	8d 4d e4	 lea	 ecx, DWORD PTR _header$[ebp]
  00098	83 c4 04	 add	 esp, 4
  0009b	33 f6		 xor	 esi, esi
  0009d	2b c1		 sub	 eax, ecx
  0009f	89 45 f0	 mov	 DWORD PTR tv254[ebp], eax
$LL7@crypthead:

; 123  :     {
; 124  :         buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);

  000a2	8b cf		 mov	 ecx, edi
  000a4	e8 00 00 00 00	 call	 _decrypt_byte
  000a9	0f b6 4c 35 e4	 movzx	 ecx, BYTE PTR _header$[ebp+esi]
  000ae	8b d8		 mov	 ebx, eax
  000b0	8b 55 10	 mov	 edx, DWORD PTR _pcrc_32_tab$[ebp]
  000b3	51		 push	 ecx
  000b4	8b cf		 mov	 ecx, edi
  000b6	e8 00 00 00 00	 call	 _update_keys
  000bb	8b 45 f0	 mov	 eax, DWORD PTR tv254[ebp]
  000be	83 c4 04	 add	 esp, 4
  000c1	8a 4c 35 e4	 mov	 cl, BYTE PTR _header$[ebp+esi]
  000c5	03 c6		 add	 eax, esi
  000c7	32 cb		 xor	 cl, bl
  000c9	46		 inc	 esi
  000ca	88 4c 05 e4	 mov	 BYTE PTR _header$[ebp+eax], cl
  000ce	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  000d1	7c cf		 jl	 SHORT $LL7@crypthead

; 125  :     }
; 126  :     buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);

  000d3	8b cf		 mov	 ecx, edi
  000d5	e8 00 00 00 00	 call	 _decrypt_byte
  000da	8b 7d 14	 mov	 edi, DWORD PTR _crcForCrypting$[ebp]
  000dd	8b df		 mov	 ebx, edi
  000df	8b 55 10	 mov	 edx, DWORD PTR _pcrc_32_tab$[ebp]
  000e2	c1 eb 10	 shr	 ebx, 16			; 00000010H
  000e5	0f b6 cb	 movzx	 ecx, bl
  000e8	51		 push	 ecx
  000e9	8b 4d 0c	 mov	 ecx, DWORD PTR _pkeys$[ebp]
  000ec	89 45 f0	 mov	 DWORD PTR _t$3$[ebp], eax
  000ef	e8 00 00 00 00	 call	 _update_keys
  000f4	8b 45 f8	 mov	 eax, DWORD PTR _buf$1$[ebp]
  000f7	32 5d f0	 xor	 bl, BYTE PTR _t$3$[ebp]

; 127  :     buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);

  000fa	8b 4d 0c	 mov	 ecx, DWORD PTR _pkeys$[ebp]
  000fd	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  00100	e8 00 00 00 00	 call	 _decrypt_byte
  00105	8b 55 10	 mov	 edx, DWORD PTR _pcrc_32_tab$[ebp]
  00108	8b d8		 mov	 ebx, eax
  0010a	8b 4d 0c	 mov	 ecx, DWORD PTR _pkeys$[ebp]
  0010d	c1 ef 18	 shr	 edi, 24			; 00000018H
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 _update_keys
  00116	8b 4d f8	 mov	 ecx, DWORD PTR _buf$1$[ebp]
  00119	83 c4 08	 add	 esp, 8
  0011c	8b c7		 mov	 eax, edi
  0011e	32 c3		 xor	 al, bl
  00120	88 44 0e 01	 mov	 BYTE PTR [esi+ecx+1], al
  00124	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx

; 128  :     return n;
; 129  : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
_crypthead ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _allocate_new_datablock
_TEXT	SEGMENT
_allocate_new_datablock PROC				; COMDAT

; 191  :     linkedlist_datablock_internal* ldi;
; 192  :     ldi = (linkedlist_datablock_internal*)

  00000	68 00 10 00 00	 push	 4096			; 00001000H
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000b	83 c4 04	 add	 esp, 4

; 193  :                  ALLOC(sizeof(linkedlist_datablock_internal));
; 194  :     if (ldi!=NULL)

  0000e	85 c0		 test	 eax, eax
  00010	74 14		 je	 SHORT $LN2@allocate_n

; 195  :     {
; 196  :         ldi->next_datablock = NULL ;

  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 197  :         ldi->filled_in_this_block = 0 ;

  00018	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 198  :         ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;

  0001f	c7 40 04 f0 0f
	00 00		 mov	 DWORD PTR [eax+4], 4080	; 00000ff0H
$LN2@allocate_n:

; 199  :     }
; 200  :     return ldi;
; 201  : }

  00026	c3		 ret	 0
_allocate_new_datablock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _free_datablock
_TEXT	SEGMENT
_free_datablock PROC					; COMDAT
; _ldi$ = ecx

; 205  :     while (ldi!=NULL)

  00000	85 c9		 test	 ecx, ecx
  00002	74 1c		 je	 SHORT $LN3@free_datab
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  0000c	0f 1f 40 00	 npad	 4
$LL2@free_datab:

; 206  :     {
; 207  :         linkedlist_datablock_internal* ldinext = ldi->next_datablock;

  00010	8b 31		 mov	 esi, DWORD PTR [ecx]

; 208  :         TRYFREE(ldi);

  00012	51		 push	 ecx
  00013	ff d7		 call	 edi
  00015	83 c4 04	 add	 esp, 4

; 209  :         ldi = ldinext;

  00018	8b ce		 mov	 ecx, esi
  0001a	85 f6		 test	 esi, esi
  0001c	75 f2		 jne	 SHORT $LL2@free_datab
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
$LN3@free_datab:

; 210  :     }
; 211  : }

  00020	c3		 ret	 0
_free_datablock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _init_linkedlist
_TEXT	SEGMENT
_init_linkedlist PROC					; COMDAT
; _ll$ = ecx

; 215  :     ll->first_block = ll->last_block = NULL;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00007	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 216  : }

  0000d	c3		 ret	 0
_init_linkedlist ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _free_linkedlist
_TEXT	SEGMENT
_free_linkedlist PROC					; COMDAT
; _ll$ = ecx

; 219  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 220  :     free_datablock(ll->first_block);

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	e8 00 00 00 00	 call	 _free_datablock

; 221  :     ll->first_block = ll->last_block = NULL;

  0000a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00017	5e		 pop	 esi

; 222  : }

  00018	c3		 ret	 0
_free_linkedlist ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _add_data_in_datablock
_TEXT	SEGMENT
_ll$1$ = -8						; size = 4
_from_copy$1$ = -4					; size = 4
_len$ = 8						; size = 4
_add_data_in_datablock PROC				; COMDAT
; _ll$ = ecx
; _buf$ = edx

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	89 55 fc	 mov	 DWORD PTR _from_copy$1$[ebp], edx
  0000c	89 7d f8	 mov	 DWORD PTR _ll$1$[ebp], edi

; 227  :     linkedlist_datablock_internal* ldi;
; 228  :     const unsigned char* from_copy;
; 229  : 
; 230  :     if (ll==NULL)

  0000f	85 ff		 test	 edi, edi
  00011	75 0a		 jne	 SHORT $LN7@add_data_i
$LN29@add_data_i:

; 231  :         return ZIP_INTERNALERROR;

  00013	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H
  00018	5f		 pop	 edi

; 274  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN7@add_data_i:

; 232  : 
; 233  :     if (ll->last_block == NULL)

  0001d	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00021	75 0e		 jne	 SHORT $LN9@add_data_i

; 234  :     {
; 235  :         ll->first_block = ll->last_block = allocate_new_datablock();

  00023	e8 00 00 00 00	 call	 _allocate_new_datablock
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0002b	89 07		 mov	 DWORD PTR [edi], eax

; 236  :         if (ll->first_block == NULL)

  0002d	85 c0		 test	 eax, eax
  0002f	74 e2		 je	 SHORT $LN29@add_data_i
$LN9@add_data_i:
  00031	53		 push	 ebx

; 237  :             return ZIP_INTERNALERROR;
; 238  :     }
; 239  : 
; 240  :     ldi = ll->last_block;
; 241  :     from_copy = (unsigned char*)buf;
; 242  : 
; 243  :     while (len>0)

  00032	8b 5d 08	 mov	 ebx, DWORD PTR _len$[ebp]
  00035	56		 push	 esi
  00036	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00039	85 db		 test	 ebx, ebx
  0003b	74 59		 je	 SHORT $LN26@add_data_i
  0003d	0f 1f 00	 npad	 3
$LL2@add_data_i:

; 244  :     {
; 245  :         uInt copy_this;
; 246  :         uInt i;
; 247  :         unsigned char* to_copy;
; 248  : 
; 249  :         if (ldi->avail_in_this_block==0)

  00040	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00044	75 10		 jne	 SHORT $LN10@add_data_i

; 250  :         {
; 251  :             ldi->next_datablock = allocate_new_datablock();

  00046	e8 00 00 00 00	 call	 _allocate_new_datablock
  0004b	89 06		 mov	 DWORD PTR [esi], eax

; 252  :             if (ldi->next_datablock == NULL)

  0004d	85 c0		 test	 eax, eax
  0004f	74 4e		 je	 SHORT $LN17@add_data_i

; 254  :             ldi = ldi->next_datablock ;

  00051	8b f0		 mov	 esi, eax

; 255  :             ll->last_block = ldi;

  00053	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN10@add_data_i:

; 256  :         }
; 257  : 
; 258  :         if (ldi->avail_in_this_block < len)

  00056	39 5e 04	 cmp	 DWORD PTR [esi+4], ebx
  00059	8b d3		 mov	 edx, ebx

; 259  :             copy_this = (uInt)ldi->avail_in_this_block;
; 260  :         else
; 261  :             copy_this = (uInt)len;
; 262  : 
; 263  :         to_copy = &(ldi->data[ldi->filled_in_this_block]);

  0005b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0005e	0f 42 56 04	 cmovb	 edx, DWORD PTR [esi+4]
  00062	83 c0 10	 add	 eax, 16			; 00000010H
  00065	03 c6		 add	 eax, esi

; 264  : 
; 265  :         for (i=0;i<copy_this;i++)

  00067	85 d2		 test	 edx, edx
  00069	74 1b		 je	 SHORT $LN5@add_data_i
  0006b	8b 5d fc	 mov	 ebx, DWORD PTR _from_copy$1$[ebp]
  0006e	8b fa		 mov	 edi, edx
  00070	2b d8		 sub	 ebx, eax
$LL20@add_data_i:

; 266  :             *(to_copy+i)=*(from_copy+i);

  00072	8a 0c 03	 mov	 cl, BYTE PTR [ebx+eax]
  00075	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00078	88 48 ff	 mov	 BYTE PTR [eax-1], cl
  0007b	83 ef 01	 sub	 edi, 1
  0007e	75 f2		 jne	 SHORT $LL20@add_data_i
  00080	8b 5d 08	 mov	 ebx, DWORD PTR _len$[ebp]
  00083	8b 7d f8	 mov	 edi, DWORD PTR _ll$1$[ebp]
$LN5@add_data_i:

; 267  : 
; 268  :         ldi->filled_in_this_block += copy_this;

  00086	01 56 08	 add	 DWORD PTR [esi+8], edx

; 269  :         ldi->avail_in_this_block -= copy_this;

  00089	29 56 04	 sub	 DWORD PTR [esi+4], edx

; 270  :         from_copy += copy_this ;

  0008c	01 55 fc	 add	 DWORD PTR _from_copy$1$[ebp], edx

; 271  :         len -= copy_this;

  0008f	2b da		 sub	 ebx, edx
  00091	89 5d 08	 mov	 DWORD PTR _len$[ebp], ebx
  00094	75 aa		 jne	 SHORT $LL2@add_data_i
$LN26@add_data_i:
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 272  :     }
; 273  :     return ZIP_OK;

  00098	33 c0		 xor	 eax, eax
  0009a	5f		 pop	 edi

; 274  : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN17@add_data_i:
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx

; 253  :                 return ZIP_INTERNALERROR;

  000a1	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H
  000a6	5f		 pop	 edi

; 274  : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_add_data_in_datablock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_putValue
_TEXT	SEGMENT
_filestream$1$ = -8					; size = 4
_pzlib_filefunc_def$1$ = -4				; size = 4
_buf$ = 8						; size = 8
_x$ = 8							; size = 8
_nbByte$ = 16						; size = 4
_zip64local_putValue PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = edx

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 289  :     unsigned char buf[8];
; 290  :     int n;
; 291  :     for (n = 0; n < nbByte; n++)

  00006	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp+4]
  00009	53		 push	 ebx
  0000a	8b 5d 10	 mov	 ebx, DWORD PTR _nbByte$[ebp]
  0000d	56		 push	 esi
  0000e	89 55 f8	 mov	 DWORD PTR _filestream$1$[ebp], edx
  00011	33 f6		 xor	 esi, esi
  00013	8b d1		 mov	 edx, ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00018	89 55 fc	 mov	 DWORD PTR _pzlib_filefunc_def$1$[ebp], edx
  0001b	85 db		 test	 ebx, ebx
  0001d	7e 11		 jle	 SHORT $LN3@zip64local
  0001f	90		 npad	 1
$LL16@zip64local:

; 292  :     {
; 293  :         buf[n] = (unsigned char)(x & 0xff);

  00020	88 4c 35 08	 mov	 BYTE PTR _buf$[ebp+esi], cl
  00024	46		 inc	 esi

; 294  :         x >>= 8;

  00025	0f ac c1 08	 shrd	 ecx, eax, 8
  00029	c1 e8 08	 shr	 eax, 8
  0002c	3b f3		 cmp	 esi, ebx
  0002e	7c f0		 jl	 SHORT $LL16@zip64local
$LN3@zip64local:

; 295  :     }
; 296  :     if (x != 0)

  00030	0b c8		 or	 ecx, eax
  00032	74 1f		 je	 SHORT $LN6@zip64local

; 297  :       {     /* data overflow - hack for ZIP64 (X Roche) */
; 298  :       for (n = 0; n < nbByte; n++)

  00034	85 db		 test	 ebx, ebx
  00036	7e 1b		 jle	 SHORT $LN6@zip64local

; 299  :         {
; 300  :           buf[n] = 0xff;

  00038	57		 push	 edi
  00039	8b cb		 mov	 ecx, ebx
  0003b	8d 7d 08	 lea	 edi, DWORD PTR _buf$[ebp]
  0003e	8b d1		 mov	 edx, ecx
  00040	83 c8 ff	 or	 eax, -1
  00043	c1 e9 02	 shr	 ecx, 2
  00046	f3 ab		 rep stosd
  00048	8b ca		 mov	 ecx, edx
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  0004d	83 e1 03	 and	 ecx, 3
  00050	f3 aa		 rep stosb
  00052	5f		 pop	 edi
$LN6@zip64local:

; 301  :         }
; 302  :       }
; 303  : 
; 304  :     if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)

  00053	53		 push	 ebx
  00054	8d 45 08	 lea	 eax, DWORD PTR _buf$[ebp]
  00057	50		 push	 eax
  00058	ff 75 f8	 push	 DWORD PTR _filestream$1$[ebp]
  0005b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005e	ff 72 1c	 push	 DWORD PTR [edx+28]
  00061	ff d0		 call	 eax
  00063	83 c4 10	 add	 esp, 16			; 00000010H
  00066	2b c3		 sub	 eax, ebx
  00068	f7 d8		 neg	 eax
  0006a	1b c0		 sbb	 eax, eax
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx

; 305  :         return ZIP_ERRNO;
; 306  :     else
; 307  :         return ZIP_OK;
; 308  : }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_zip64local_putValue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_putValue_inmemory
_TEXT	SEGMENT
_x$ = 8							; size = 8
_zip64local_putValue_inmemory PROC			; COMDAT
; _dest$ = ecx
; _nbByte$ = edx

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  :     unsigned char* buf=(unsigned char*)dest;
; 314  :     int n;
; 315  :     for (n = 0; n < nbByte; n++) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	33 f6		 xor	 esi, esi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000f	85 d2		 test	 edx, edx
  00011	7e 0f		 jle	 SHORT $LN3@zip64local
$LL14@zip64local:

; 316  :         buf[n] = (unsigned char)(x & 0xff);

  00013	88 0c 3e	 mov	 BYTE PTR [esi+edi], cl
  00016	46		 inc	 esi

; 317  :         x >>= 8;

  00017	0f ac c1 08	 shrd	 ecx, eax, 8
  0001b	c1 e8 08	 shr	 eax, 8
  0001e	3b f2		 cmp	 esi, edx
  00020	7c f1		 jl	 SHORT $LL14@zip64local
$LN3@zip64local:

; 318  :     }
; 319  : 
; 320  :     if (x != 0)

  00022	0b c8		 or	 ecx, eax
  00024	74 15		 je	 SHORT $LN6@zip64local

; 321  :     {     /* data overflow - hack for ZIP64 */
; 322  :        for (n = 0; n < nbByte; n++)

  00026	85 d2		 test	 edx, edx
  00028	7e 11		 jle	 SHORT $LN6@zip64local

; 323  :        {
; 324  :           buf[n] = 0xff;

  0002a	8b ca		 mov	 ecx, edx
  0002c	83 c8 ff	 or	 eax, -1
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	f3 ab		 rep stosd
  00034	8b ca		 mov	 ecx, edx
  00036	83 e1 03	 and	 ecx, 3
  00039	f3 aa		 rep stosb
$LN6@zip64local:
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 325  :        }
; 326  :     }
; 327  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_zip64local_putValue_inmemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_TmzDateToDosDate
_TEXT	SEGMENT
_zip64local_TmzDateToDosDate PROC			; COMDAT
; _ptm$ = ecx

; 333  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 334  :     uLong year = (uLong)ptm->tm_year;

  00003	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 335  :     if (year>=1980)

  00006	81 fa bc 07 00
	00		 cmp	 edx, 1980		; 000007bcH
  0000c	72 08		 jb	 SHORT $LN2@zip64local

; 336  :         year-=1980;

  0000e	81 ea bc 07 00
	00		 sub	 edx, 1980		; 000007bcH
  00014	eb 08		 jmp	 SHORT $LN4@zip64local
$LN2@zip64local:

; 337  :     else if (year>=80)

  00016	83 fa 50	 cmp	 edx, 80			; 00000050H
  00019	72 03		 jb	 SHORT $LN4@zip64local

; 338  :         year-=80;

  0001b	83 ea 50	 sub	 edx, 80			; 00000050H
$LN4@zip64local:

; 339  :     return

  0001e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00021	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00023	c1 e0 06	 shl	 eax, 6
  00026	03 46 04	 add	 eax, DWORD PTR [esi+4]
  00029	d1 e9		 shr	 ecx, 1
  0002b	c1 e0 05	 shl	 eax, 5
  0002e	03 c1		 add	 eax, ecx
  00030	c1 e2 04	 shl	 edx, 4
  00033	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00036	41		 inc	 ecx
  00037	03 ca		 add	 ecx, edx
  00039	c1 e1 05	 shl	 ecx, 5
  0003c	03 4e 0c	 add	 ecx, DWORD PTR [esi+12]
  0003f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00042	0b c1		 or	 eax, ecx
  00044	5e		 pop	 esi

; 340  :       (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
; 341  :         ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
; 342  : }

  00045	c3		 ret	 0
_zip64local_TmzDateToDosDate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_getByte
_TEXT	SEGMENT
_c$ = -1						; size = 1
_pi$ = 8						; size = 4
_zip64local_getByte PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = edx

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 351  :     unsigned char c;
; 352  :     int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);

  00006	6a 01		 push	 1
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 45 ff	 lea	 eax, DWORD PTR _c$[ebp]
  0000d	50		 push	 eax
  0000e	8b fa		 mov	 edi, edx
  00010	57		 push	 edi
  00011	ff 76 1c	 push	 DWORD PTR [esi+28]
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	ff d0		 call	 eax
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 353  :     if (err==1)

  0001c	83 f8 01	 cmp	 eax, 1
  0001f	75 11		 jne	 SHORT $LN2@zip64local

; 354  :     {
; 355  :         *pi = (int)c;

  00021	8b 45 08	 mov	 eax, DWORD PTR _pi$[ebp]
  00024	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 356  :         return ZIP_OK;

  0002c	33 c0		 xor	 eax, eax

; 361  :             return ZIP_ERRNO;
; 362  :         else
; 363  :             return ZIP_EOF;
; 364  :     }
; 365  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN2@zip64local:

; 357  :     }
; 358  :     else
; 359  :     {
; 360  :         if (ZERROR64(*pzlib_filefunc_def,filestream))

  00032	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00035	57		 push	 edi
  00036	ff 76 1c	 push	 DWORD PTR [esi+28]
  00039	ff d0		 call	 eax
  0003b	83 c4 08	 add	 esp, 8
  0003e	f7 d8		 neg	 eax
  00040	1b c0		 sbb	 eax, eax
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi

; 361  :             return ZIP_ERRNO;
; 362  :         else
; 363  :             return ZIP_EOF;
; 364  :     }
; 365  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_zip64local_getByte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_getShort
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pX$ = 8						; size = 4
_zip64local_getShort PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = edx

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 375  :     uLong x ;
; 376  :     int i = 0;
; 377  :     int err;
; 378  : 
; 379  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00007	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00011	50		 push	 eax
  00012	8b f2		 mov	 esi, edx
  00014	8b f9		 mov	 edi, ecx
  00016	e8 00 00 00 00	 call	 _zip64local_getByte

; 380  :     x = (uLong)i;

  0001b	8b 5d fc	 mov	 ebx, DWORD PTR _i$[ebp]
  0001e	8b d0		 mov	 edx, eax
  00020	83 c4 04	 add	 esp, 4

; 381  : 
; 382  :     if (err==ZIP_OK)

  00023	85 d2		 test	 edx, edx
  00025	75 2c		 jne	 SHORT $LN3@zip64local

; 383  :         err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00027	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0002a	8b d6		 mov	 edx, esi
  0002c	50		 push	 eax
  0002d	8b cf		 mov	 ecx, edi
  0002f	e8 00 00 00 00	 call	 _zip64local_getByte
  00034	8b d0		 mov	 edx, eax
  00036	83 c4 04	 add	 esp, 4

; 384  :     x += ((uLong)i)<<8;
; 385  : 
; 386  :     if (err==ZIP_OK)

  00039	85 d2		 test	 edx, edx
  0003b	75 16		 jne	 SHORT $LN3@zip64local

; 387  :         *pX = x;

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00040	8b 45 08	 mov	 eax, DWORD PTR _pX$[ebp]
  00043	c1 e1 08	 shl	 ecx, 8
  00046	5f		 pop	 edi
  00047	03 cb		 add	 ecx, ebx
  00049	5e		 pop	 esi
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 390  :     return err;

  0004c	8b c2		 mov	 eax, edx
  0004e	5b		 pop	 ebx

; 391  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN3@zip64local:

; 388  :     else
; 389  :         *pX = 0;

  00053	8b 45 08	 mov	 eax, DWORD PTR _pX$[ebp]
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 390  :     return err;

  0005f	8b c2		 mov	 eax, edx

; 391  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_zip64local_getShort ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_getLong
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pX$ = 8						; size = 4
_zip64local_getLong PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = edx

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 397  :     uLong x ;
; 398  :     int i = 0;
; 399  :     int err;
; 400  : 
; 401  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00007	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00011	50		 push	 eax
  00012	8b fa		 mov	 edi, edx
  00014	8b d9		 mov	 ebx, ecx
  00016	e8 00 00 00 00	 call	 _zip64local_getByte

; 402  :     x = (uLong)i;

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001e	8b d0		 mov	 edx, eax
  00020	83 c4 04	 add	 esp, 4
  00023	8b f1		 mov	 esi, ecx

; 403  : 
; 404  :     if (err==ZIP_OK)

  00025	85 d2		 test	 edx, edx
  00027	75 15		 jne	 SHORT $LN2@zip64local

; 405  :         err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00029	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0002c	8b d7		 mov	 edx, edi
  0002e	50		 push	 eax
  0002f	8b cb		 mov	 ecx, ebx
  00031	e8 00 00 00 00	 call	 _zip64local_getByte
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00039	83 c4 04	 add	 esp, 4
  0003c	8b d0		 mov	 edx, eax
$LN2@zip64local:

; 406  :     x += ((uLong)i)<<8;

  0003e	8b c1		 mov	 eax, ecx
  00040	c1 e0 08	 shl	 eax, 8
  00043	03 f0		 add	 esi, eax

; 407  : 
; 408  :     if (err==ZIP_OK)

  00045	85 d2		 test	 edx, edx
  00047	75 15		 jne	 SHORT $LN3@zip64local

; 409  :         err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00049	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0004c	8b d7		 mov	 edx, edi
  0004e	50		 push	 eax
  0004f	8b cb		 mov	 ecx, ebx
  00051	e8 00 00 00 00	 call	 _zip64local_getByte
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00059	83 c4 04	 add	 esp, 4
  0005c	8b d0		 mov	 edx, eax
$LN3@zip64local:

; 410  :     x += ((uLong)i)<<16;

  0005e	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00061	03 f1		 add	 esi, ecx

; 411  : 
; 412  :     if (err==ZIP_OK)

  00063	85 d2		 test	 edx, edx
  00065	75 2c		 jne	 SHORT $LN5@zip64local

; 413  :         err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00067	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0006a	8b d7		 mov	 edx, edi
  0006c	50		 push	 eax
  0006d	8b cb		 mov	 ecx, ebx
  0006f	e8 00 00 00 00	 call	 _zip64local_getByte
  00074	8b d0		 mov	 edx, eax
  00076	83 c4 04	 add	 esp, 4

; 414  :     x += ((uLong)i)<<24;
; 415  : 
; 416  :     if (err==ZIP_OK)

  00079	85 d2		 test	 edx, edx
  0007b	75 16		 jne	 SHORT $LN5@zip64local

; 417  :         *pX = x;

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00080	8b 45 08	 mov	 eax, DWORD PTR _pX$[ebp]
  00083	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00086	5f		 pop	 edi
  00087	03 ce		 add	 ecx, esi
  00089	5e		 pop	 esi
  0008a	89 08		 mov	 DWORD PTR [eax], ecx

; 420  :     return err;

  0008c	8b c2		 mov	 eax, edx
  0008e	5b		 pop	 ebx

; 421  : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN5@zip64local:

; 418  :     else
; 419  :         *pX = 0;

  00093	8b 45 08	 mov	 eax, DWORD PTR _pX$[ebp]
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 420  :     return err;

  0009f	8b c2		 mov	 eax, edx

; 421  : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_zip64local_getLong ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_getLong64
_TEXT	SEGMENT
_pzlib_filefunc_def$1$ = -12				; size = 4
_filestream$1$ = -8					; size = 4
_i$ = -4						; size = 4
_pX$ = 8						; size = 4
_zip64local_getLong64 PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = edx

; 427  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b c2		 mov	 eax, edx
  00009	89 4d f4	 mov	 DWORD PTR _pzlib_filefunc_def$1$[ebp], ecx
  0000c	56		 push	 esi

; 428  :   ZPOS64_T x;
; 429  :   int i = 0;
; 430  :   int err;
; 431  : 
; 432  :   err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  0000d	8d 55 fc	 lea	 edx, DWORD PTR _i$[ebp]
  00010	89 45 f8	 mov	 DWORD PTR _filestream$1$[ebp], eax
  00013	57		 push	 edi
  00014	52		 push	 edx
  00015	8b d0		 mov	 edx, eax
  00017	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001e	e8 00 00 00 00	 call	 _zip64local_getByte

; 433  :   x = (ZPOS64_T)i;

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00026	8b f0		 mov	 esi, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	83 c4 04	 add	 esp, 4
  0002d	99		 cdq
  0002e	8b f8		 mov	 edi, eax
  00030	8b da		 mov	 ebx, edx

; 434  : 
; 435  :   if (err==ZIP_OK)

  00032	85 f6		 test	 esi, esi
  00034	75 17		 jne	 SHORT $LN2@zip64local

; 436  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00036	8b 55 f8	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  00039	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _zip64local_getByte
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00048	83 c4 04	 add	 esp, 4
  0004b	8b f0		 mov	 esi, eax
$LN2@zip64local:

; 437  :   x += ((ZPOS64_T)i)<<8;

  0004d	8b c1		 mov	 eax, ecx
  0004f	99		 cdq
  00050	0f a4 c2 08	 shld	 edx, eax, 8
  00054	c1 e0 08	 shl	 eax, 8
  00057	03 f8		 add	 edi, eax
  00059	13 da		 adc	 ebx, edx

; 438  : 
; 439  :   if (err==ZIP_OK)

  0005b	85 f6		 test	 esi, esi
  0005d	75 17		 jne	 SHORT $LN3@zip64local

; 440  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  0005f	8b 55 f8	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  00062	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _zip64local_getByte
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00071	83 c4 04	 add	 esp, 4
  00074	8b f0		 mov	 esi, eax
$LN3@zip64local:

; 441  :   x += ((ZPOS64_T)i)<<16;

  00076	8b c1		 mov	 eax, ecx
  00078	99		 cdq
  00079	0f a4 c2 10	 shld	 edx, eax, 16
  0007d	c1 e0 10	 shl	 eax, 16			; 00000010H
  00080	03 f8		 add	 edi, eax
  00082	13 da		 adc	 ebx, edx

; 442  : 
; 443  :   if (err==ZIP_OK)

  00084	85 f6		 test	 esi, esi
  00086	75 17		 jne	 SHORT $LN4@zip64local

; 444  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00088	8b 55 f8	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  0008b	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _zip64local_getByte
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0009a	83 c4 04	 add	 esp, 4
  0009d	8b f0		 mov	 esi, eax
$LN4@zip64local:

; 445  :   x += ((ZPOS64_T)i)<<24;

  0009f	8b c1		 mov	 eax, ecx
  000a1	99		 cdq
  000a2	0f a4 c2 18	 shld	 edx, eax, 24
  000a6	c1 e0 18	 shl	 eax, 24			; 00000018H
  000a9	03 f8		 add	 edi, eax
  000ab	13 da		 adc	 ebx, edx

; 446  : 
; 447  :   if (err==ZIP_OK)

  000ad	85 f6		 test	 esi, esi
  000af	75 17		 jne	 SHORT $LN5@zip64local

; 448  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  000b1	8b 55 f8	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  000b4	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _zip64local_getByte
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000c3	83 c4 04	 add	 esp, 4
  000c6	8b f0		 mov	 esi, eax
$LN5@zip64local:

; 449  :   x += ((ZPOS64_T)i)<<32;

  000c8	8b c1		 mov	 eax, ecx
  000ca	83 c7 00	 add	 edi, 0
  000cd	99		 cdq
  000ce	13 d8		 adc	 ebx, eax

; 450  : 
; 451  :   if (err==ZIP_OK)

  000d0	85 f6		 test	 esi, esi
  000d2	75 17		 jne	 SHORT $LN6@zip64local

; 452  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  000d4	8b 55 f8	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  000d7	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  000da	8b 4d f4	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _zip64local_getByte
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e6	83 c4 04	 add	 esp, 4
  000e9	8b f0		 mov	 esi, eax
$LN6@zip64local:

; 453  :   x += ((ZPOS64_T)i)<<40;

  000eb	8b c1		 mov	 eax, ecx
  000ed	99		 cdq
  000ee	c1 e0 08	 shl	 eax, 8
  000f1	83 c7 00	 add	 edi, 0
  000f4	13 d8		 adc	 ebx, eax

; 454  : 
; 455  :   if (err==ZIP_OK)

  000f6	85 f6		 test	 esi, esi
  000f8	75 17		 jne	 SHORT $LN7@zip64local

; 456  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  000fa	8b 55 f8	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  000fd	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  00100	8b 4d f4	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _zip64local_getByte
  00109	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010c	83 c4 04	 add	 esp, 4
  0010f	8b f0		 mov	 esi, eax
$LN7@zip64local:

; 457  :   x += ((ZPOS64_T)i)<<48;

  00111	8b c1		 mov	 eax, ecx
  00113	99		 cdq
  00114	c1 e0 10	 shl	 eax, 16			; 00000010H
  00117	83 c7 00	 add	 edi, 0
  0011a	13 d8		 adc	 ebx, eax

; 458  : 
; 459  :   if (err==ZIP_OK)

  0011c	85 f6		 test	 esi, esi
  0011e	75 36		 jne	 SHORT $LN9@zip64local

; 460  :     err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);

  00120	8b 55 f8	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  00123	8d 45 fc	 lea	 eax, DWORD PTR _i$[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _zip64local_getByte
  0012f	8b f0		 mov	 esi, eax
  00131	83 c4 04	 add	 esp, 4

; 461  :   x += ((ZPOS64_T)i)<<56;
; 462  : 
; 463  :   if (err==ZIP_OK)

  00134	85 f6		 test	 esi, esi
  00136	75 1e		 jne	 SHORT $LN9@zip64local

; 464  :     *pX = x;

  00138	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR _pX$[ebp]
  0013e	99		 cdq
  0013f	33 d2		 xor	 edx, edx
  00141	c1 e0 18	 shl	 eax, 24			; 00000018H
  00144	03 d7		 add	 edx, edi
  00146	89 11		 mov	 DWORD PTR [ecx], edx
  00148	13 c3		 adc	 eax, ebx
  0014a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 467  : 
; 468  :   return err;

  0014d	8b c6		 mov	 eax, esi

; 469  : }

  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
$LN9@zip64local:

; 465  :   else
; 466  :     *pX = 0;

  00156	8b 45 08	 mov	 eax, DWORD PTR _pX$[ebp]

; 469  : }

  00159	5f		 pop	 edi
  0015a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00160	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00167	8b c6		 mov	 eax, esi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
_zip64local_getLong64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_SearchCentralDir
_TEXT	SEGMENT
_uPosFound$ = -48					; size = 8
_uReadPos$1$ = -44					; size = 4
_uBackRead$2$ = -40					; size = 4
_uReadPos$2$ = -36					; size = 4
_pzlib_filefunc_def$1$ = -32				; size = 4
_filestream$1$ = -28					; size = 4
_uSizeFile$1$ = -24					; size = 4
_uSizeFile$2$ = -20					; size = 4
_uPosFound$1$ = -16					; size = 4
_uPosFound$2$ = -12					; size = 4
_uMaxBack$1$ = -8					; size = 4
_uMaxBack$2$ = -4					; size = 4
_zip64local_SearchCentralDir PROC			; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = edx

; 481  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 482  :   unsigned char* buf;
; 483  :   ZPOS64_T uSizeFile;
; 484  :   ZPOS64_T uBackRead;
; 485  :   ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */

  00009	33 c0		 xor	 eax, eax
  0000b	8b f2		 mov	 esi, edx

; 486  :   ZPOS64_T uPosFound=0;
; 487  : 
; 488  :   if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)

  0000d	6a 02		 push	 2
  0000f	50		 push	 eax
  00010	8b d9		 mov	 ebx, ecx
  00012	89 75 e4	 mov	 DWORD PTR _filestream$1$[ebp], esi
  00015	0f 57 c0	 xorps	 xmm0, xmm0
  00018	89 5d e0	 mov	 DWORD PTR _pzlib_filefunc_def$1$[ebp], ebx
  0001b	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  00020	89 45 fc	 mov	 DWORD PTR _uMaxBack$2$[ebp], eax
  00023	50		 push	 eax
  00024	89 7d f8	 mov	 DWORD PTR _uMaxBack$1$[ebp], edi
  00027	66 0f 13 45 d0	 movlpd	 QWORD PTR _uPosFound$[ebp], xmm0
  0002c	e8 00 00 00 00	 call	 _call_zseek64
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	85 c0		 test	 eax, eax
  00036	74 0b		 je	 SHORT $LN7@zip64local

; 489  :     return 0;

  00038	33 c0		 xor	 eax, eax
$LN43@zip64local:
  0003a	33 d2		 xor	 edx, edx

; 534  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN7@zip64local:

; 490  : 
; 491  : 
; 492  :   uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);

  00043	8b d6		 mov	 edx, esi
  00045	8b cb		 mov	 ecx, ebx
  00047	e8 00 00 00 00	 call	 _call_ztell64
  0004c	8b ca		 mov	 ecx, edx
  0004e	89 45 e8	 mov	 DWORD PTR _uSizeFile$1$[ebp], eax
  00051	89 4d ec	 mov	 DWORD PTR _uSizeFile$2$[ebp], ecx

; 493  : 
; 494  :   if (uMaxBack>uSizeFile)

  00054	85 c9		 test	 ecx, ecx
  00056	77 11		 ja	 SHORT $LN8@zip64local
  00058	72 07		 jb	 SHORT $LN33@zip64local
  0005a	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0005f	73 08		 jae	 SHORT $LN8@zip64local
$LN33@zip64local:

; 495  :     uMaxBack = uSizeFile;

  00061	8b f8		 mov	 edi, eax
  00063	89 4d fc	 mov	 DWORD PTR _uMaxBack$2$[ebp], ecx
  00066	89 7d f8	 mov	 DWORD PTR _uMaxBack$1$[ebp], edi
$LN8@zip64local:

; 496  : 
; 497  :   buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);

  00069	68 04 04 00 00	 push	 1028			; 00000404H
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00074	8b f0		 mov	 esi, eax
  00076	83 c4 04	 add	 esp, 4

; 498  :   if (buf==NULL)
; 499  :     return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	85 f6		 test	 esi, esi
  0007d	74 bb		 je	 SHORT $LN43@zip64local

; 500  : 
; 501  :   uBackRead = 4;
; 502  :   while (uBackRead<uMaxBack)

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _uMaxBack$2$[ebp]
  00082	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  00085	3b c1		 cmp	 eax, ecx
  00087	0f 87 f3 00 00
	00		 ja	 $LN42@zip64local
  0008d	72 08		 jb	 SHORT $LN40@zip64local
  0008f	3b df		 cmp	 ebx, edi
  00091	0f 83 e9 00 00
	00		 jae	 $LN42@zip64local
$LN40@zip64local:
  00097	8b 55 d4	 mov	 edx, DWORD PTR _uPosFound$[ebp+4]
  0009a	89 55 f0	 mov	 DWORD PTR _uPosFound$1$[ebp], edx
  0009d	8b 55 d0	 mov	 edx, DWORD PTR _uPosFound$[ebp]
  000a0	89 55 f4	 mov	 DWORD PTR _uPosFound$2$[ebp], edx
$LL2@zip64local:

; 503  :   {
; 504  :     uLong uReadSize;
; 505  :     ZPOS64_T uReadPos ;
; 506  :     int i;
; 507  :     if (uBackRead+BUFREADCOMMENT>uMaxBack)

  000a3	81 c3 00 04 00
	00		 add	 ebx, 1024		; 00000400H
  000a9	83 d0 00	 adc	 eax, 0
  000ac	89 45 d8	 mov	 DWORD PTR _uBackRead$2$[ebp], eax
  000af	3b c1		 cmp	 eax, ecx
  000b1	72 0d		 jb	 SHORT $LN11@zip64local
  000b3	77 04		 ja	 SHORT $LN35@zip64local
  000b5	3b df		 cmp	 ebx, edi
  000b7	76 07		 jbe	 SHORT $LN11@zip64local
$LN35@zip64local:

; 508  :       uBackRead = uMaxBack;

  000b9	8b df		 mov	 ebx, edi
  000bb	89 4d d8	 mov	 DWORD PTR _uBackRead$2$[ebp], ecx
  000be	8b c1		 mov	 eax, ecx
$LN11@zip64local:

; 509  :     else
; 510  :       uBackRead+=BUFREADCOMMENT;
; 511  :     uReadPos = uSizeFile-uBackRead ;

  000c0	8b 4d e8	 mov	 ecx, DWORD PTR _uSizeFile$1$[ebp]
  000c3	8b d1		 mov	 edx, ecx
  000c5	8b 7d ec	 mov	 edi, DWORD PTR _uSizeFile$2$[ebp]
  000c8	2b d3		 sub	 edx, ebx
  000ca	89 55 d4	 mov	 DWORD PTR _uReadPos$1$[ebp], edx
  000cd	1b f8		 sbb	 edi, eax

; 512  : 
; 513  :     uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?

  000cf	8b 45 ec	 mov	 eax, DWORD PTR _uSizeFile$2$[ebp]
  000d2	2b ca		 sub	 ecx, edx
  000d4	89 7d dc	 mov	 DWORD PTR _uReadPos$2$[ebp], edi
  000d7	1b c7		 sbb	 eax, edi
  000d9	85 c0		 test	 eax, eax
  000db	72 11		 jb	 SHORT $LN18@zip64local
  000dd	77 08		 ja	 SHORT $LN36@zip64local
  000df	81 f9 04 04 00
	00		 cmp	 ecx, 1028		; 00000404H
  000e5	76 07		 jbe	 SHORT $LN18@zip64local
$LN36@zip64local:
  000e7	bf 04 04 00 00	 mov	 edi, 1028		; 00000404H
  000ec	eb 05		 jmp	 SHORT $LN19@zip64local
$LN18@zip64local:
  000ee	8b 7d e8	 mov	 edi, DWORD PTR _uSizeFile$1$[ebp]
  000f1	2b fa		 sub	 edi, edx
$LN19@zip64local:

; 514  :       (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
; 515  :     if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)

  000f3	8b 4d e0	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  000f6	6a 00		 push	 0
  000f8	ff 75 dc	 push	 DWORD PTR _uReadPos$2$[ebp]
  000fb	52		 push	 edx
  000fc	8b 55 e4	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  000ff	e8 00 00 00 00	 call	 _call_zseek64
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH
  00107	85 c0		 test	 eax, eax
  00109	0f 85 7d 00 00
	00		 jne	 $LN37@zip64local

; 516  :       break;
; 517  : 
; 518  :     if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)

  0010f	8b 45 e0	 mov	 eax, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  00112	57		 push	 edi
  00113	56		 push	 esi
  00114	ff 75 e4	 push	 DWORD PTR _filestream$1$[ebp]
  00117	ff 70 1c	 push	 DWORD PTR [eax+28]
  0011a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011d	ff d0		 call	 eax
  0011f	83 c4 10	 add	 esp, 16			; 00000010H
  00122	3b c7		 cmp	 eax, edi
  00124	75 66		 jne	 SHORT $LN37@zip64local

; 519  :       break;
; 520  : 
; 521  :     for (i=(int)uReadSize-3; (i--)>0;)

  00126	8d 47 fd	 lea	 eax, DWORD PTR [edi-3]
  00129	85 c0		 test	 eax, eax
  0012b	7e 36		 jle	 SHORT $LN32@zip64local
  0012d	0f 1f 00	 npad	 3
$LL4@zip64local:
  00130	48		 dec	 eax

; 522  :       if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
; 523  :         ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))

  00131	80 3c 30 50	 cmp	 BYTE PTR [eax+esi], 80	; 00000050H
  00135	75 15		 jne	 SHORT $LN14@zip64local
  00137	80 7c 30 01 4b	 cmp	 BYTE PTR [eax+esi+1], 75 ; 0000004bH
  0013c	75 0e		 jne	 SHORT $LN14@zip64local
  0013e	80 7c 30 02 05	 cmp	 BYTE PTR [eax+esi+2], 5
  00143	75 07		 jne	 SHORT $LN14@zip64local
  00145	80 7c 30 03 06	 cmp	 BYTE PTR [eax+esi+3], 6
  0014a	74 06		 je	 SHORT $LN22@zip64local
$LN14@zip64local:

; 519  :       break;
; 520  : 
; 521  :     for (i=(int)uReadSize-3; (i--)>0;)

  0014c	85 c0		 test	 eax, eax
  0014e	7f e0		 jg	 SHORT $LL4@zip64local
  00150	eb 11		 jmp	 SHORT $LN32@zip64local
$LN22@zip64local:

; 524  :       {
; 525  :         uPosFound = uReadPos+i;

  00152	99		 cdq
  00153	03 45 d4	 add	 eax, DWORD PTR _uReadPos$1$[ebp]
  00156	89 45 f4	 mov	 DWORD PTR _uPosFound$2$[ebp], eax
  00159	13 55 dc	 adc	 edx, DWORD PTR _uReadPos$2$[ebp]

; 526  :         break;
; 527  :       }
; 528  : 
; 529  :       if (uPosFound!=0)

  0015c	0b c2		 or	 eax, edx
  0015e	89 55 f0	 mov	 DWORD PTR _uPosFound$1$[ebp], edx
  00161	75 29		 jne	 SHORT $LN37@zip64local
$LN32@zip64local:

; 500  : 
; 501  :   uBackRead = 4;
; 502  :   while (uBackRead<uMaxBack)

  00163	8b 45 d8	 mov	 eax, DWORD PTR _uBackRead$2$[ebp]
  00166	8b 4d fc	 mov	 ecx, DWORD PTR _uMaxBack$2$[ebp]
  00169	8b 7d f8	 mov	 edi, DWORD PTR _uMaxBack$1$[ebp]
  0016c	3b c1		 cmp	 eax, ecx
  0016e	0f 82 2f ff ff
	ff		 jb	 $LL2@zip64local
  00174	77 16		 ja	 SHORT $LN37@zip64local
  00176	3b df		 cmp	 ebx, edi
  00178	0f 82 25 ff ff
	ff		 jb	 $LL2@zip64local
  0017e	eb 0c		 jmp	 SHORT $LN37@zip64local
$LN42@zip64local:
  00180	8b 45 d4	 mov	 eax, DWORD PTR _uPosFound$[ebp+4]
  00183	89 45 f0	 mov	 DWORD PTR _uPosFound$1$[ebp], eax
  00186	8b 45 d0	 mov	 eax, DWORD PTR _uPosFound$[ebp]
  00189	89 45 f4	 mov	 DWORD PTR _uPosFound$2$[ebp], eax
$LN37@zip64local:

; 530  :         break;
; 531  :   }
; 532  :   TRYFREE(buf);

  0018c	56		 push	 esi
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 533  :   return uPosFound;

  00193	8b 45 f4	 mov	 eax, DWORD PTR _uPosFound$2$[ebp]
  00196	83 c4 04	 add	 esp, 4
  00199	8b 55 f0	 mov	 edx, DWORD PTR _uPosFound$1$[ebp]

; 534  : }

  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c3		 ret	 0
_zip64local_SearchCentralDir ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64local_SearchCentralDir64
_TEXT	SEGMENT
_relativeOffset$ = -48					; size = 8
_uPosFound$ = -48					; size = 8
_uReadPos$1$ = -44					; size = 4
_uBackRead$2$ = -40					; size = 4
_uReadPos$2$ = -36					; size = 4
_uSizeFile$1$ = -32					; size = 4
_uSizeFile$2$ = -28					; size = 4
_uPosFound$1$ = -24					; size = 4
_uPosFound$2$ = -20					; size = 4
_uMaxBack$2$ = -16					; size = 4
_filestream$1$ = -12					; size = 4
_uMaxBack$1$ = -8					; size = 4
_uL$ = -8						; size = 4
_pzlib_filefunc_def$1$ = -4				; size = 4
_zip64local_SearchCentralDir64 PROC			; COMDAT
; _pzlib_filefunc_def$ = ecx
; _filestream$ = edx

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 544  :   unsigned char* buf;
; 545  :   ZPOS64_T uSizeFile;
; 546  :   ZPOS64_T uBackRead;
; 547  :   ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */

  00009	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000e	8b da		 mov	 ebx, edx
  00010	89 45 f8	 mov	 DWORD PTR _uMaxBack$1$[ebp], eax
  00013	8b f9		 mov	 edi, ecx
  00015	33 c0		 xor	 eax, eax
  00017	89 5d f4	 mov	 DWORD PTR _filestream$1$[ebp], ebx

; 548  :   ZPOS64_T uPosFound=0;
; 549  :   uLong uL;
; 550  :   ZPOS64_T relativeOffset;
; 551  : 
; 552  :   if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)

  0001a	6a 02		 push	 2
  0001c	50		 push	 eax
  0001d	0f 57 c0	 xorps	 xmm0, xmm0
  00020	89 7d fc	 mov	 DWORD PTR _pzlib_filefunc_def$1$[ebp], edi
  00023	50		 push	 eax
  00024	89 45 f0	 mov	 DWORD PTR _uMaxBack$2$[ebp], eax
  00027	66 0f 13 45 d0	 movlpd	 QWORD PTR _uPosFound$[ebp], xmm0
  0002c	e8 00 00 00 00	 call	 _call_zseek64
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	85 c0		 test	 eax, eax
  00036	74 0b		 je	 SHORT $LN7@zip64local
$LN61@zip64local:

; 553  :     return 0;

  00038	33 c0		 xor	 eax, eax
$LN60@zip64local:
  0003a	33 d2		 xor	 edx, edx

; 638  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN7@zip64local:

; 554  : 
; 555  :   uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);

  00043	8b d3		 mov	 edx, ebx
  00045	8b cf		 mov	 ecx, edi
  00047	e8 00 00 00 00	 call	 _call_ztell64
  0004c	8b ca		 mov	 ecx, edx
  0004e	89 45 e0	 mov	 DWORD PTR _uSizeFile$1$[ebp], eax
  00051	89 4d e4	 mov	 DWORD PTR _uSizeFile$2$[ebp], ecx

; 556  : 
; 557  :   if (uMaxBack>uSizeFile)

  00054	85 c9		 test	 ecx, ecx
  00056	77 0f		 ja	 SHORT $LN8@zip64local
  00058	72 07		 jb	 SHORT $LN44@zip64local
  0005a	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0005f	73 06		 jae	 SHORT $LN8@zip64local
$LN44@zip64local:

; 558  :     uMaxBack = uSizeFile;

  00061	89 45 f8	 mov	 DWORD PTR _uMaxBack$1$[ebp], eax
  00064	89 4d f0	 mov	 DWORD PTR _uMaxBack$2$[ebp], ecx
$LN8@zip64local:

; 559  : 
; 560  :   buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);

  00067	68 04 04 00 00	 push	 1028			; 00000404H
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00072	8b f0		 mov	 esi, eax
  00074	83 c4 04	 add	 esp, 4

; 561  :   if (buf==NULL)
; 562  :     return 0;

  00077	33 c0		 xor	 eax, eax
  00079	85 f6		 test	 esi, esi
  0007b	74 bd		 je	 SHORT $LN60@zip64local

; 563  : 
; 564  :   uBackRead = 4;
; 565  :   while (uBackRead<uMaxBack)

  0007d	8b 55 f0	 mov	 edx, DWORD PTR _uMaxBack$2$[ebp]
  00080	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  00083	3b c2		 cmp	 eax, edx
  00085	0f 87 f3 01 00
	00		 ja	 $LN53@zip64local
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _uMaxBack$1$[ebp]
  0008e	72 08		 jb	 SHORT $LN51@zip64local
  00090	3b d9		 cmp	 ebx, ecx
  00092	0f 83 e6 01 00
	00		 jae	 $LN53@zip64local
$LN51@zip64local:
  00098	8b 7d d4	 mov	 edi, DWORD PTR _uPosFound$[ebp+4]
  0009b	89 7d e8	 mov	 DWORD PTR _uPosFound$1$[ebp], edi
  0009e	8b 7d d0	 mov	 edi, DWORD PTR _uPosFound$[ebp]
  000a1	89 7d ec	 mov	 DWORD PTR _uPosFound$2$[ebp], edi
$LL2@zip64local:

; 566  :   {
; 567  :     uLong uReadSize;
; 568  :     ZPOS64_T uReadPos;
; 569  :     int i;
; 570  :     if (uBackRead+BUFREADCOMMENT>uMaxBack)

  000a4	81 c3 00 04 00
	00		 add	 ebx, 1024		; 00000400H
  000aa	83 d0 00	 adc	 eax, 0
  000ad	89 45 d8	 mov	 DWORD PTR _uBackRead$2$[ebp], eax
  000b0	3b c2		 cmp	 eax, edx
  000b2	72 0d		 jb	 SHORT $LN11@zip64local
  000b4	77 04		 ja	 SHORT $LN46@zip64local
  000b6	3b d9		 cmp	 ebx, ecx
  000b8	76 07		 jbe	 SHORT $LN11@zip64local
$LN46@zip64local:

; 571  :       uBackRead = uMaxBack;

  000ba	8b d9		 mov	 ebx, ecx
  000bc	89 55 d8	 mov	 DWORD PTR _uBackRead$2$[ebp], edx
  000bf	8b c2		 mov	 eax, edx
$LN11@zip64local:

; 572  :     else
; 573  :       uBackRead+=BUFREADCOMMENT;
; 574  :     uReadPos = uSizeFile-uBackRead ;

  000c1	8b 4d e0	 mov	 ecx, DWORD PTR _uSizeFile$1$[ebp]
  000c4	8b d1		 mov	 edx, ecx
  000c6	8b 7d e4	 mov	 edi, DWORD PTR _uSizeFile$2$[ebp]
  000c9	2b d3		 sub	 edx, ebx
  000cb	89 55 d4	 mov	 DWORD PTR _uReadPos$1$[ebp], edx
  000ce	1b f8		 sbb	 edi, eax

; 575  : 
; 576  :     uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?

  000d0	8b 45 e4	 mov	 eax, DWORD PTR _uSizeFile$2$[ebp]
  000d3	2b ca		 sub	 ecx, edx
  000d5	89 7d dc	 mov	 DWORD PTR _uReadPos$2$[ebp], edi
  000d8	1b c7		 sbb	 eax, edi
  000da	85 c0		 test	 eax, eax
  000dc	72 11		 jb	 SHORT $LN29@zip64local
  000de	77 08		 ja	 SHORT $LN47@zip64local
  000e0	81 f9 04 04 00
	00		 cmp	 ecx, 1028		; 00000404H
  000e6	76 07		 jbe	 SHORT $LN29@zip64local
$LN47@zip64local:
  000e8	bf 04 04 00 00	 mov	 edi, 1028		; 00000404H
  000ed	eb 05		 jmp	 SHORT $LN30@zip64local
$LN29@zip64local:
  000ef	8b 7d e0	 mov	 edi, DWORD PTR _uSizeFile$1$[ebp]
  000f2	2b fa		 sub	 edi, edx
$LN30@zip64local:

; 577  :       (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
; 578  :     if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)

  000f4	8b 4d fc	 mov	 ecx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  000f7	6a 00		 push	 0
  000f9	ff 75 dc	 push	 DWORD PTR _uReadPos$2$[ebp]
  000fc	52		 push	 edx
  000fd	8b 55 f4	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  00100	e8 00 00 00 00	 call	 _call_zseek64
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	85 c0		 test	 eax, eax
  0010a	75 76		 jne	 SHORT $LN57@zip64local

; 579  :       break;
; 580  : 
; 581  :     if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  0010f	57		 push	 edi
  00110	56		 push	 esi
  00111	ff 75 f4	 push	 DWORD PTR _filestream$1$[ebp]
  00114	ff 70 1c	 push	 DWORD PTR [eax+28]
  00117	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011a	ff d0		 call	 eax
  0011c	83 c4 10	 add	 esp, 16			; 00000010H
  0011f	3b c7		 cmp	 eax, edi
  00121	75 5f		 jne	 SHORT $LN57@zip64local

; 582  :       break;
; 583  : 
; 584  :     for (i=(int)uReadSize-3; (i--)>0;)

  00123	8d 47 fd	 lea	 eax, DWORD PTR [edi-3]
  00126	85 c0		 test	 eax, eax
  00128	7e 3d		 jle	 SHORT $LN43@zip64local
  0012a	66 0f 1f 44 00
	00		 npad	 6
$LL4@zip64local:
  00130	48		 dec	 eax

; 585  :     {
; 586  :       // Signature "0x07064b50" Zip64 end of central directory locater
; 587  :       if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))

  00131	80 3c 30 50	 cmp	 BYTE PTR [eax+esi], 80	; 00000050H
  00135	75 15		 jne	 SHORT $LN14@zip64local
  00137	80 7c 30 01 4b	 cmp	 BYTE PTR [eax+esi+1], 75 ; 0000004bH
  0013c	75 0e		 jne	 SHORT $LN14@zip64local
  0013e	80 7c 30 02 06	 cmp	 BYTE PTR [eax+esi+2], 6
  00143	75 07		 jne	 SHORT $LN14@zip64local
  00145	80 7c 30 03 07	 cmp	 BYTE PTR [eax+esi+3], 7
  0014a	74 06		 je	 SHORT $LN33@zip64local
$LN14@zip64local:

; 582  :       break;
; 583  : 
; 584  :     for (i=(int)uReadSize-3; (i--)>0;)

  0014c	85 c0		 test	 eax, eax
  0014e	7f e0		 jg	 SHORT $LL4@zip64local
  00150	eb 15		 jmp	 SHORT $LN43@zip64local
$LN33@zip64local:

; 588  :       {
; 589  :         uPosFound = uReadPos+i;

  00152	99		 cdq
  00153	03 45 d4	 add	 eax, DWORD PTR _uReadPos$1$[ebp]
  00156	8b fa		 mov	 edi, edx

; 590  :         break;
; 591  :       }
; 592  :     }
; 593  : 
; 594  :       if (uPosFound!=0)

  00158	8b c8		 mov	 ecx, eax
  0015a	89 45 ec	 mov	 DWORD PTR _uPosFound$2$[ebp], eax
  0015d	13 7d dc	 adc	 edi, DWORD PTR _uReadPos$2$[ebp]
  00160	0b cf		 or	 ecx, edi
  00162	89 7d e8	 mov	 DWORD PTR _uPosFound$1$[ebp], edi
  00165	75 1b		 jne	 SHORT $LN57@zip64local
$LN43@zip64local:

; 563  : 
; 564  :   uBackRead = 4;
; 565  :   while (uBackRead<uMaxBack)

  00167	8b 45 d8	 mov	 eax, DWORD PTR _uBackRead$2$[ebp]
  0016a	8b 55 f0	 mov	 edx, DWORD PTR _uMaxBack$2$[ebp]
  0016d	8b 4d f8	 mov	 ecx, DWORD PTR _uMaxBack$1$[ebp]
  00170	3b c2		 cmp	 eax, edx
  00172	0f 82 2c ff ff
	ff		 jb	 $LL2@zip64local
  00178	77 08		 ja	 SHORT $LN57@zip64local
  0017a	3b d9		 cmp	 ebx, ecx
  0017c	0f 82 22 ff ff
	ff		 jb	 $LL2@zip64local
$LN57@zip64local:
  00182	8b 7d fc	 mov	 edi, DWORD PTR _pzlib_filefunc_def$1$[ebp]
$LN48@zip64local:

; 595  :         break;
; 596  :   }
; 597  : 
; 598  :   TRYFREE(buf);

  00185	56		 push	 esi
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 599  :   if (uPosFound == 0)

  0018c	8b 55 ec	 mov	 edx, DWORD PTR _uPosFound$2$[ebp]
  0018f	83 c4 04	 add	 esp, 4
  00192	8b 4d e8	 mov	 ecx, DWORD PTR _uPosFound$1$[ebp]
  00195	8b c2		 mov	 eax, edx
  00197	0b c1		 or	 eax, ecx
  00199	0f 84 99 fe ff
	ff		 je	 $LN61@zip64local

; 600  :     return 0;
; 601  : 
; 602  :   /* Zip64 end of central directory locator */
; 603  :   if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)

  0019f	8b 5d f4	 mov	 ebx, DWORD PTR _filestream$1$[ebp]
  001a2	6a 00		 push	 0
  001a4	51		 push	 ecx
  001a5	52		 push	 edx
  001a6	8b d3		 mov	 edx, ebx
  001a8	8b cf		 mov	 ecx, edi
  001aa	e8 00 00 00 00	 call	 _call_zseek64
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b2	85 c0		 test	 eax, eax
  001b4	0f 85 7e fe ff
	ff		 jne	 $LN61@zip64local

; 604  :     return 0;
; 605  : 
; 606  :   /* the signature, already checked */
; 607  :   if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)

  001ba	8d 45 f8	 lea	 eax, DWORD PTR _uL$[ebp]
  001bd	8b d3		 mov	 edx, ebx
  001bf	50		 push	 eax
  001c0	8b cf		 mov	 ecx, edi
  001c2	e8 00 00 00 00	 call	 _zip64local_getLong
  001c7	83 c4 04	 add	 esp, 4
  001ca	85 c0		 test	 eax, eax
  001cc	0f 85 66 fe ff
	ff		 jne	 $LN61@zip64local

; 608  :     return 0;
; 609  : 
; 610  :   /* number of the disk with the start of the zip64 end of  central directory */
; 611  :   if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)

  001d2	8d 45 f8	 lea	 eax, DWORD PTR _uL$[ebp]
  001d5	8b d3		 mov	 edx, ebx
  001d7	50		 push	 eax
  001d8	8b cf		 mov	 ecx, edi
  001da	e8 00 00 00 00	 call	 _zip64local_getLong
  001df	83 c4 04	 add	 esp, 4
  001e2	85 c0		 test	 eax, eax
  001e4	0f 85 4e fe ff
	ff		 jne	 $LN61@zip64local

; 612  :     return 0;
; 613  :   if (uL != 0)

  001ea	39 45 f8	 cmp	 DWORD PTR _uL$[ebp], eax
  001ed	0f 85 45 fe ff
	ff		 jne	 $LN61@zip64local

; 614  :     return 0;
; 615  : 
; 616  :   /* relative offset of the zip64 end of central directory record */
; 617  :   if (zip64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=ZIP_OK)

  001f3	8d 45 d0	 lea	 eax, DWORD PTR _relativeOffset$[ebp]
  001f6	8b d3		 mov	 edx, ebx
  001f8	50		 push	 eax
  001f9	8b cf		 mov	 ecx, edi
  001fb	e8 00 00 00 00	 call	 _zip64local_getLong64
  00200	83 c4 04	 add	 esp, 4
  00203	85 c0		 test	 eax, eax
  00205	0f 85 2d fe ff
	ff		 jne	 $LN61@zip64local

; 618  :     return 0;
; 619  : 
; 620  :   /* total number of disks */
; 621  :   if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)

  0020b	8d 45 f8	 lea	 eax, DWORD PTR _uL$[ebp]
  0020e	8b d3		 mov	 edx, ebx
  00210	50		 push	 eax
  00211	8b cf		 mov	 ecx, edi
  00213	e8 00 00 00 00	 call	 _zip64local_getLong
  00218	83 c4 04	 add	 esp, 4
  0021b	85 c0		 test	 eax, eax
  0021d	0f 85 15 fe ff
	ff		 jne	 $LN61@zip64local

; 622  :     return 0;
; 623  :   if (uL != 1)

  00223	83 7d f8 01	 cmp	 DWORD PTR _uL$[ebp], 1
  00227	0f 85 0b fe ff
	ff		 jne	 $LN61@zip64local

; 624  :     return 0;
; 625  : 
; 626  :   /* Goto Zip64 end of central directory record */
; 627  :   if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)

  0022d	8b 75 d4	 mov	 esi, DWORD PTR _relativeOffset$[ebp+4]
  00230	8b d3		 mov	 edx, ebx
  00232	8b 7d d0	 mov	 edi, DWORD PTR _relativeOffset$[ebp]
  00235	8b 5d fc	 mov	 ebx, DWORD PTR _pzlib_filefunc_def$1$[ebp]
  00238	8b cb		 mov	 ecx, ebx
  0023a	50		 push	 eax
  0023b	56		 push	 esi
  0023c	57		 push	 edi
  0023d	e8 00 00 00 00	 call	 _call_zseek64
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH
  00245	85 c0		 test	 eax, eax
  00247	0f 85 eb fd ff
	ff		 jne	 $LN61@zip64local

; 628  :     return 0;
; 629  : 
; 630  :   /* the signature */
; 631  :   if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)

  0024d	8b 55 f4	 mov	 edx, DWORD PTR _filestream$1$[ebp]
  00250	8d 45 f8	 lea	 eax, DWORD PTR _uL$[ebp]
  00253	50		 push	 eax
  00254	8b cb		 mov	 ecx, ebx
  00256	e8 00 00 00 00	 call	 _zip64local_getLong
  0025b	83 c4 04	 add	 esp, 4
  0025e	85 c0		 test	 eax, eax
  00260	0f 85 d2 fd ff
	ff		 jne	 $LN61@zip64local

; 632  :     return 0;
; 633  : 
; 634  :   if (uL != 0x06064b50) // signature of 'Zip64 end of central directory'

  00266	81 7d f8 50 4b
	06 06		 cmp	 DWORD PTR _uL$[ebp], 101075792 ; 06064b50H
  0026d	0f 85 c5 fd ff
	ff		 jne	 $LN61@zip64local

; 635  :     return 0;
; 636  : 
; 637  :   return relativeOffset;

  00273	8b c7		 mov	 eax, edi
  00275	8b d6		 mov	 edx, esi

; 638  : }

  00277	5f		 pop	 edi
  00278	5e		 pop	 esi
  00279	5b		 pop	 ebx
  0027a	8b e5		 mov	 esp, ebp
  0027c	5d		 pop	 ebp
  0027d	c3		 ret	 0
$LN53@zip64local:

; 563  : 
; 564  :   uBackRead = 4;
; 565  :   while (uBackRead<uMaxBack)

  0027e	8b 45 d4	 mov	 eax, DWORD PTR _uPosFound$[ebp+4]
  00281	89 45 e8	 mov	 DWORD PTR _uPosFound$1$[ebp], eax
  00284	8b 45 d0	 mov	 eax, DWORD PTR _uPosFound$[ebp]
  00287	89 45 ec	 mov	 DWORD PTR _uPosFound$2$[ebp], eax
  0028a	e9 f6 fe ff ff	 jmp	 $LN48@zip64local
_zip64local_SearchCentralDir64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _LoadCentralDirectoryRecord
_TEXT	SEGMENT
_size_central_dir$ = -48				; size = 8
_number_entry_CD$ = -48					; size = 8
_sizeEndOfCentralDirectory$1 = -48			; size = 8
tv537 = -44						; size = 4
_VersionNeeded$ = -44					; size = 4
_VersionMadeBy$ = -44					; size = 4
_offset_central_dir$ = -40				; size = 8
_number_entry$ = -40					; size = 8
tv538 = -36						; size = 4
tv529 = -36						; size = 4
_number_entry_CD$1$ = -32				; size = 4
_number_entry_CD$2$ = -28				; size = 4
_number_entry$1$ = -24					; size = 4
_buf_read$1$ = -24					; size = 4
_size_comment$1$ = -24					; size = 4
_size_comment$ = -24					; size = 4
_read_this$2$ = -20					; size = 4
_offset_central_dir$1$ = -20				; size = 4
_number_disk_with_CD$ = -20				; size = 4
_byte_before_the_zipfile$2$ = -16			; size = 4
_byte_before_the_zipfile$1$ = -12			; size = 4
_size_central_dir_to_read$2$ = -8			; size = 4
_number_disk$ = -8					; size = 4
_offset_central_dir$2$ = -4				; size = 4
_read_this$1$ = -4					; size = 4
_uL$ = -4						; size = 4
_LoadCentralDirectoryRecord PROC			; COMDAT
; _pziinit$ = ecx

; 641  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 642  :   int err=ZIP_OK;

  0000b	33 ff		 xor	 edi, edi

; 643  :   ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
; 644  : 
; 645  :   ZPOS64_T size_central_dir;     /* size of the central directory  */
; 646  :   ZPOS64_T offset_central_dir;   /* offset of start of central directory */
; 647  :   ZPOS64_T central_pos;
; 648  :   uLong uL;
; 649  : 
; 650  :   uLong number_disk;          /* number of the current dist, used for
; 651  :                               spaning ZIP, unsupported, always 0*/
; 652  :   uLong number_disk_with_CD;  /* number the the disk with central dir, used
; 653  :                               for spaning ZIP, unsupported, always 0*/
; 654  :   ZPOS64_T number_entry;
; 655  :   ZPOS64_T number_entry_CD;      /* total number of entries in
; 656  :                                 the central dir
; 657  :                                 (same than number_entry on nospan) */
; 658  :   uLong VersionMadeBy;
; 659  :   uLong VersionNeeded;
; 660  :   uLong size_comment;
; 661  : 
; 662  :   int hasZIP64Record = 0;
; 663  : 
; 664  :   // check first if we find a ZIP64 record
; 665  :   central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);

  0000d	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00010	e8 00 00 00 00	 call	 _zip64local_SearchCentralDir64
  00015	89 55 f4	 mov	 DWORD PTR _byte_before_the_zipfile$1$[ebp], edx
  00018	8b c8		 mov	 ecx, eax
  0001a	89 4d f0	 mov	 DWORD PTR _byte_before_the_zipfile$2$[ebp], ecx

; 666  :   if(central_pos > 0)

  0001d	85 d2		 test	 edx, edx
  0001f	0f 87 92 01 00
	00		 ja	 $LN53@LoadCentra
  00025	72 08		 jb	 SHORT $LN55@LoadCentra
  00027	85 c9		 test	 ecx, ecx
  00029	0f 85 88 01 00
	00		 jne	 $LN53@LoadCentra
$LN55@LoadCentra:

; 667  :   {
; 668  :     hasZIP64Record = 1;
; 669  :   }
; 670  :   else if(central_pos == 0)

  0002f	0b c2		 or	 eax, edx
  00031	75 12		 jne	 SHORT $LN7@LoadCentra

; 671  :   {
; 672  :     central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);

  00033	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 _zip64local_SearchCentralDir
  0003d	8b c8		 mov	 ecx, eax
  0003f	89 45 f0	 mov	 DWORD PTR _byte_before_the_zipfile$2$[ebp], eax
  00042	89 55 f4	 mov	 DWORD PTR _byte_before_the_zipfile$1$[ebp], edx
$LN7@LoadCentra:

; 733  :   }
; 734  :   else
; 735  :   {
; 736  :     // Read End of central Directory info
; 737  :     if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)

  00045	6a 00		 push	 0
  00047	52		 push	 edx
  00048	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0004b	51		 push	 ecx
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 _call_zseek64

; 738  :       err=ZIP_ERRNO;
; 739  : 
; 740  :     /* the signature, already checked */
; 741  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)

  00053	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	83 cb ff	 or	 ebx, -1
  0005c	8b ce		 mov	 ecx, esi
  0005e	85 c0		 test	 eax, eax
  00060	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  00063	50		 push	 eax
  00064	0f 45 fb	 cmovne	 edi, ebx
  00067	e8 00 00 00 00	 call	 _zip64local_getLong

; 742  :       err=ZIP_ERRNO;
; 743  : 
; 744  :     /* number of this disk */
; 745  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)

  0006c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0006f	83 c4 04	 add	 esp, 4
  00072	85 c0		 test	 eax, eax
  00074	8b ce		 mov	 ecx, esi
  00076	8d 45 f8	 lea	 eax, DWORD PTR _number_disk$[ebp]
  00079	0f 45 fb	 cmovne	 edi, ebx
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _zip64local_getShort

; 746  :       err=ZIP_ERRNO;
; 747  : 
; 748  :     /* number of the disk with the start of the central directory */
; 749  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)

  00082	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00085	83 c4 04	 add	 esp, 4
  00088	85 c0		 test	 eax, eax
  0008a	8b ce		 mov	 ecx, esi
  0008c	8d 45 ec	 lea	 eax, DWORD PTR _number_disk_with_CD$[ebp]
  0008f	0f 45 fb	 cmovne	 edi, ebx
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _zip64local_getShort

; 750  :       err=ZIP_ERRNO;
; 751  : 
; 752  :     /* total number of entries in the central dir on this disk */
; 753  :     number_entry = 0;
; 754  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)

  00098	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0009b	83 c4 04	 add	 esp, 4
  0009e	85 c0		 test	 eax, eax
  000a0	0f 57 c0	 xorps	 xmm0, xmm0
  000a3	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  000a6	66 0f 13 45 d8	 movlpd	 QWORD PTR _number_entry$[ebp], xmm0
  000ab	8b ce		 mov	 ecx, esi
  000ad	0f 45 fb	 cmovne	 edi, ebx
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _zip64local_getShort
  000b6	83 c4 04	 add	 esp, 4
  000b9	85 c0		 test	 eax, eax
  000bb	74 0d		 je	 SHORT $LN26@LoadCentra

; 755  :       err=ZIP_ERRNO;

  000bd	8b 45 dc	 mov	 eax, DWORD PTR _number_entry$[ebp+4]
  000c0	0b fb		 or	 edi, ebx
  000c2	8b 5d d8	 mov	 ebx, DWORD PTR _number_entry$[ebp]
  000c5	89 45 e8	 mov	 DWORD PTR _number_entry$1$[ebp], eax
  000c8	eb 0a		 jmp	 SHORT $LN27@LoadCentra
$LN26@LoadCentra:

; 756  :     else
; 757  :       number_entry = uL;

  000ca	8b 5d fc	 mov	 ebx, DWORD PTR _uL$[ebp]
  000cd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _number_entry$1$[ebp], 0
$LN27@LoadCentra:

; 758  : 
; 759  :     /* total number of entries in the central dir */
; 760  :     number_entry_CD = 0;
; 761  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)

  000d4	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000d7	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  000da	0f 57 c0	 xorps	 xmm0, xmm0
  000dd	8b ce		 mov	 ecx, esi
  000df	50		 push	 eax
  000e0	66 0f 13 45 d0	 movlpd	 QWORD PTR _number_entry_CD$[ebp], xmm0
  000e5	e8 00 00 00 00	 call	 _zip64local_getShort
  000ea	83 c4 04	 add	 esp, 4
  000ed	85 c0		 test	 eax, eax
  000ef	74 0b		 je	 SHORT $LN28@LoadCentra

; 762  :       err=ZIP_ERRNO;

  000f1	8b 45 d4	 mov	 eax, DWORD PTR _number_entry_CD$[ebp+4]
  000f4	83 cf ff	 or	 edi, -1
  000f7	8b 4d d0	 mov	 ecx, DWORD PTR _number_entry_CD$[ebp]
  000fa	eb 05		 jmp	 SHORT $LN66@LoadCentra
$LN28@LoadCentra:

; 763  :     else
; 764  :       number_entry_CD = uL;

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR _uL$[ebp]
  000ff	33 c0		 xor	 eax, eax
$LN66@LoadCentra:
  00101	89 45 e0	 mov	 DWORD PTR _number_entry_CD$1$[ebp], eax
  00104	89 4d e4	 mov	 DWORD PTR _number_entry_CD$2$[ebp], ecx

; 765  : 
; 766  :     if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))

  00107	3b cb		 cmp	 ecx, ebx
  00109	75 11		 jne	 SHORT $LN31@LoadCentra
  0010b	3b 45 e8	 cmp	 eax, DWORD PTR _number_entry$1$[ebp]
  0010e	75 0c		 jne	 SHORT $LN31@LoadCentra
  00110	83 7d ec 00	 cmp	 DWORD PTR _number_disk_with_CD$[ebp], 0
  00114	75 06		 jne	 SHORT $LN31@LoadCentra
  00116	83 7d f8 00	 cmp	 DWORD PTR _number_disk$[ebp], 0
  0011a	74 05		 je	 SHORT $LN30@LoadCentra
$LN31@LoadCentra:

; 767  :       err=ZIP_BADZIPFILE;

  0011c	bf 99 ff ff ff	 mov	 edi, -103		; ffffff99H
$LN30@LoadCentra:

; 768  : 
; 769  :     /* size of the central directory */
; 770  :     size_central_dir = 0;
; 771  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)

  00121	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00124	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  00127	0f 57 c0	 xorps	 xmm0, xmm0
  0012a	8b ce		 mov	 ecx, esi
  0012c	50		 push	 eax
  0012d	66 0f 13 45 d0	 movlpd	 QWORD PTR _size_central_dir$[ebp], xmm0
  00132	e8 00 00 00 00	 call	 _zip64local_getLong
  00137	83 c4 04	 add	 esp, 4
  0013a	85 c0		 test	 eax, eax
  0013c	74 0e		 je	 SHORT $LN32@LoadCentra

; 772  :       err=ZIP_ERRNO;

  0013e	8b 45 d4	 mov	 eax, DWORD PTR _size_central_dir$[ebp+4]
  00141	83 cf ff	 or	 edi, -1
  00144	8b 5d d0	 mov	 ebx, DWORD PTR _size_central_dir$[ebp]
  00147	89 45 f8	 mov	 DWORD PTR _size_central_dir_to_read$2$[ebp], eax
  0014a	eb 0a		 jmp	 SHORT $LN33@LoadCentra
$LN32@LoadCentra:

; 773  :     else
; 774  :       size_central_dir = uL;

  0014c	8b 5d fc	 mov	 ebx, DWORD PTR _uL$[ebp]
  0014f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _size_central_dir_to_read$2$[ebp], 0
$LN33@LoadCentra:

; 775  : 
; 776  :     /* offset of start of central directory with respect to the starting disk number */
; 777  :     offset_central_dir = 0;
; 778  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)

  00156	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00159	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  0015c	0f 57 c0	 xorps	 xmm0, xmm0
  0015f	8b ce		 mov	 ecx, esi
  00161	50		 push	 eax
  00162	66 0f 13 45 d8	 movlpd	 QWORD PTR _offset_central_dir$[ebp], xmm0
  00167	e8 00 00 00 00	 call	 _zip64local_getLong
  0016c	83 c4 04	 add	 esp, 4
  0016f	85 c0		 test	 eax, eax
  00171	74 0e		 je	 SHORT $LN34@LoadCentra

; 779  :       err=ZIP_ERRNO;

  00173	8b 45 dc	 mov	 eax, DWORD PTR _offset_central_dir$[ebp+4]
  00176	83 cf ff	 or	 edi, -1
  00179	89 45 ec	 mov	 DWORD PTR _offset_central_dir$1$[ebp], eax
  0017c	8b 45 d8	 mov	 eax, DWORD PTR _offset_central_dir$[ebp]
  0017f	eb 0a		 jmp	 SHORT $LN67@LoadCentra
$LN34@LoadCentra:

; 780  :     else
; 781  :       offset_central_dir = uL;

  00181	8b 45 fc	 mov	 eax, DWORD PTR _uL$[ebp]
  00184	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _offset_central_dir$1$[ebp], 0
$LN67@LoadCentra:

; 782  : 
; 783  : 
; 784  :     /* zipfile global comment length */
; 785  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)

  0018b	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0018e	8b ce		 mov	 ecx, esi
  00190	89 45 fc	 mov	 DWORD PTR _offset_central_dir$2$[ebp], eax
  00193	8d 45 e8	 lea	 eax, DWORD PTR _size_comment$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 _zip64local_getShort
  0019c	8b 55 e8	 mov	 edx, DWORD PTR _size_comment$[ebp]
  0019f	83 c4 04	 add	 esp, 4
  001a2	8b 4d fc	 mov	 ecx, DWORD PTR _offset_central_dir$2$[ebp]
  001a5	85 c0		 test	 eax, eax
  001a7	b8 ff ff ff ff	 mov	 eax, -1
  001ac	0f 45 f8	 cmovne	 edi, eax
  001af	8b 45 ec	 mov	 eax, DWORD PTR _offset_central_dir$1$[ebp]
  001b2	e9 33 01 00 00	 jmp	 $LN68@LoadCentra
$LN53@LoadCentra:

; 673  :   }
; 674  : 
; 675  : /* disable to allow appending to empty ZIP archive
; 676  :         if (central_pos==0)
; 677  :             err=ZIP_ERRNO;
; 678  : */
; 679  : 
; 680  :   if(hasZIP64Record)
; 681  :   {
; 682  :     ZPOS64_T sizeEndOfCentralDirectory;
; 683  :     if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)

  001b7	6a 00		 push	 0
  001b9	52		 push	 edx
  001ba	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001bd	51		 push	 ecx
  001be	8b ce		 mov	 ecx, esi
  001c0	e8 00 00 00 00	 call	 _call_zseek64

; 684  :       err=ZIP_ERRNO;
; 685  : 
; 686  :     /* the signature, already checked */
; 687  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)

  001c5	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cb	83 cb ff	 or	 ebx, -1
  001ce	8b ce		 mov	 ecx, esi
  001d0	85 c0		 test	 eax, eax
  001d2	8d 45 fc	 lea	 eax, DWORD PTR _uL$[ebp]
  001d5	50		 push	 eax
  001d6	0f 45 fb	 cmovne	 edi, ebx
  001d9	e8 00 00 00 00	 call	 _zip64local_getLong

; 688  :       err=ZIP_ERRNO;
; 689  : 
; 690  :     /* size of zip64 end of central directory record */
; 691  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)

  001de	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001e1	83 c4 04	 add	 esp, 4
  001e4	85 c0		 test	 eax, eax
  001e6	8b ce		 mov	 ecx, esi
  001e8	8d 45 d0	 lea	 eax, DWORD PTR _sizeEndOfCentralDirectory$1[ebp]
  001eb	0f 45 fb	 cmovne	 edi, ebx
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 _zip64local_getLong64

; 692  :       err=ZIP_ERRNO;
; 693  : 
; 694  :     /* version made by */
; 695  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)

  001f4	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001f7	83 c4 04	 add	 esp, 4
  001fa	85 c0		 test	 eax, eax
  001fc	8b ce		 mov	 ecx, esi
  001fe	8d 45 d4	 lea	 eax, DWORD PTR _VersionMadeBy$[ebp]
  00201	0f 45 fb	 cmovne	 edi, ebx
  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 _zip64local_getShort

; 696  :       err=ZIP_ERRNO;
; 697  : 
; 698  :     /* version needed to extract */
; 699  :     if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)

  0020a	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0020d	83 c4 04	 add	 esp, 4
  00210	85 c0		 test	 eax, eax
  00212	8b ce		 mov	 ecx, esi
  00214	8d 45 d4	 lea	 eax, DWORD PTR _VersionNeeded$[ebp]
  00217	0f 45 fb	 cmovne	 edi, ebx
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 _zip64local_getShort

; 700  :       err=ZIP_ERRNO;
; 701  : 
; 702  :     /* number of this disk */
; 703  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)

  00220	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00223	83 c4 04	 add	 esp, 4
  00226	85 c0		 test	 eax, eax
  00228	8b ce		 mov	 ecx, esi
  0022a	8d 45 f8	 lea	 eax, DWORD PTR _number_disk$[ebp]
  0022d	0f 45 fb	 cmovne	 edi, ebx
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 _zip64local_getLong

; 704  :       err=ZIP_ERRNO;
; 705  : 
; 706  :     /* number of the disk with the start of the central directory */
; 707  :     if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)

  00236	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00239	83 c4 04	 add	 esp, 4
  0023c	85 c0		 test	 eax, eax
  0023e	8b ce		 mov	 ecx, esi
  00240	8d 45 ec	 lea	 eax, DWORD PTR _number_disk_with_CD$[ebp]
  00243	0f 45 fb	 cmovne	 edi, ebx
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 _zip64local_getLong

; 708  :       err=ZIP_ERRNO;
; 709  : 
; 710  :     /* total number of entries in the central directory on this disk */
; 711  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)

  0024c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0024f	83 c4 04	 add	 esp, 4
  00252	85 c0		 test	 eax, eax
  00254	8b ce		 mov	 ecx, esi
  00256	8d 45 d8	 lea	 eax, DWORD PTR _number_entry$[ebp]
  00259	0f 45 fb	 cmovne	 edi, ebx
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 _zip64local_getLong64

; 712  :       err=ZIP_ERRNO;
; 713  : 
; 714  :     /* total number of entries in the central directory */
; 715  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)

  00262	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00265	83 c4 04	 add	 esp, 4
  00268	85 c0		 test	 eax, eax
  0026a	8b ce		 mov	 ecx, esi
  0026c	8d 45 d0	 lea	 eax, DWORD PTR _number_entry_CD$[ebp]
  0026f	0f 45 fb	 cmovne	 edi, ebx
  00272	50		 push	 eax
  00273	e8 00 00 00 00	 call	 _zip64local_getLong64
  00278	83 c4 04	 add	 esp, 4
  0027b	85 c0		 test	 eax, eax

; 716  :       err=ZIP_ERRNO;
; 717  : 
; 718  :     if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))

  0027d	8b 45 d0	 mov	 eax, DWORD PTR _number_entry_CD$[ebp]
  00280	0f 45 fb	 cmovne	 edi, ebx
  00283	89 45 e4	 mov	 DWORD PTR _number_entry_CD$2$[ebp], eax
  00286	3b 45 d8	 cmp	 eax, DWORD PTR _number_entry$[ebp]
  00289	8b 45 d4	 mov	 eax, DWORD PTR _number_entry_CD$[ebp+4]
  0028c	89 45 e0	 mov	 DWORD PTR _number_entry_CD$1$[ebp], eax
  0028f	75 11		 jne	 SHORT $LN19@LoadCentra
  00291	3b 45 dc	 cmp	 eax, DWORD PTR _number_entry$[ebp+4]
  00294	75 0c		 jne	 SHORT $LN19@LoadCentra
  00296	83 7d ec 00	 cmp	 DWORD PTR _number_disk_with_CD$[ebp], 0
  0029a	75 06		 jne	 SHORT $LN19@LoadCentra
  0029c	83 7d f8 00	 cmp	 DWORD PTR _number_disk$[ebp], 0
  002a0	74 05		 je	 SHORT $LN18@LoadCentra
$LN19@LoadCentra:

; 719  :       err=ZIP_BADZIPFILE;

  002a2	bf 99 ff ff ff	 mov	 edi, -103		; ffffff99H
$LN18@LoadCentra:

; 720  : 
; 721  :     /* size of the central directory */
; 722  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)

  002a7	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  002aa	8d 45 d0	 lea	 eax, DWORD PTR _size_central_dir$[ebp]
  002ad	50		 push	 eax
  002ae	8b ce		 mov	 ecx, esi
  002b0	e8 00 00 00 00	 call	 _zip64local_getLong64

; 723  :       err=ZIP_ERRNO;
; 724  : 
; 725  :     /* offset of start of central directory with respect to the
; 726  :     starting disk number */
; 727  :     if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)

  002b5	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  002b8	83 c4 04	 add	 esp, 4
  002bb	85 c0		 test	 eax, eax
  002bd	8b ce		 mov	 ecx, esi
  002bf	8d 45 d8	 lea	 eax, DWORD PTR _offset_central_dir$[ebp]
  002c2	0f 45 fb	 cmovne	 edi, ebx
  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 _zip64local_getLong64

; 728  :       err=ZIP_ERRNO;
; 729  : 
; 730  :     // TODO..
; 731  :     // read the comment from the standard central header.
; 732  :     size_comment = 0;

  002cb	8b 4d d8	 mov	 ecx, DWORD PTR _offset_central_dir$[ebp]
  002ce	83 c4 04	 add	 esp, 4
  002d1	85 c0		 test	 eax, eax
  002d3	89 4d fc	 mov	 DWORD PTR _offset_central_dir$2$[ebp], ecx
  002d6	8b 45 d4	 mov	 eax, DWORD PTR _size_central_dir$[ebp+4]
  002d9	0f 45 fb	 cmovne	 edi, ebx
  002dc	89 45 f8	 mov	 DWORD PTR _size_central_dir_to_read$2$[ebp], eax
  002df	8b 45 dc	 mov	 eax, DWORD PTR _offset_central_dir$[ebp+4]
  002e2	33 d2		 xor	 edx, edx
  002e4	8b 5d d0	 mov	 ebx, DWORD PTR _size_central_dir$[ebp]
  002e7	89 45 ec	 mov	 DWORD PTR _offset_central_dir$1$[ebp], eax
$LN68@LoadCentra:

; 786  :       err=ZIP_ERRNO;
; 787  :   }
; 788  : 
; 789  :   if ((central_pos<offset_central_dir+size_central_dir) &&

  002ea	03 cb		 add	 ecx, ebx
  002ec	89 55 e8	 mov	 DWORD PTR _size_comment$1$[ebp], edx
  002ef	89 4d dc	 mov	 DWORD PTR tv529[ebp], ecx
  002f2	13 45 f8	 adc	 eax, DWORD PTR _size_central_dir_to_read$2$[ebp]
  002f5	8b 4d f4	 mov	 ecx, DWORD PTR _byte_before_the_zipfile$1$[ebp]
  002f8	3b c8		 cmp	 ecx, eax
  002fa	0f 82 8b 01 00
	00		 jb	 $LN52@LoadCentra
  00300	77 0c		 ja	 SHORT $LN56@LoadCentra
  00302	8b 45 dc	 mov	 eax, DWORD PTR tv529[ebp]
  00305	39 45 f0	 cmp	 DWORD PTR _byte_before_the_zipfile$2$[ebp], eax
  00308	0f 82 7d 01 00
	00		 jb	 $LN52@LoadCentra
$LN56@LoadCentra:

; 790  :     (err==ZIP_OK))
; 791  :     err=ZIP_BADZIPFILE;
; 792  : 
; 793  :   if (err!=ZIP_OK)

  0030e	85 ff		 test	 edi, edi
  00310	0f 85 75 01 00
	00		 jne	 $LN52@LoadCentra

; 797  :   }
; 798  : 
; 799  :   if (size_comment>0)

  00316	85 d2		 test	 edx, edx
  00318	74 36		 je	 SHORT $LN40@LoadCentra

; 800  :   {
; 801  :     pziinit->globalcomment = (char*)ALLOC(size_comment+1);

  0031a	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0031d	50		 push	 eax
  0031e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00324	83 c4 04	 add	 esp, 4
  00327	89 86 00 01 01
	00		 mov	 DWORD PTR [esi+65792], eax

; 802  :     if (pziinit->globalcomment)

  0032d	85 c0		 test	 eax, eax
  0032f	74 1c		 je	 SHORT $LN65@LoadCentra

; 803  :     {
; 804  :       size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);

  00331	ff 75 e8	 push	 DWORD PTR _size_comment$1$[ebp]
  00334	50		 push	 eax
  00335	ff 76 2c	 push	 DWORD PTR [esi+44]
  00338	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0033b	ff 76 1c	 push	 DWORD PTR [esi+28]
  0033e	ff d0		 call	 eax

; 805  :       pziinit->globalcomment[size_comment]=0;

  00340	8b 8e 00 01 01
	00		 mov	 ecx, DWORD PTR [esi+65792]
  00346	83 c4 10	 add	 esp, 16			; 00000010H
  00349	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN65@LoadCentra:
  0034d	8b 4d f4	 mov	 ecx, DWORD PTR _byte_before_the_zipfile$1$[ebp]
$LN40@LoadCentra:

; 806  :     }
; 807  :   }
; 808  : 
; 809  :   byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);

  00350	8b 45 f0	 mov	 eax, DWORD PTR _byte_before_the_zipfile$2$[ebp]
  00353	2b 45 fc	 sub	 eax, DWORD PTR _offset_central_dir$2$[ebp]

; 810  :   pziinit->add_position_when_writting_offset = byte_before_the_zipfile;
; 811  : 
; 812  :   {
; 813  :     ZPOS64_T size_central_dir_to_read = size_central_dir;
; 814  :     size_t buf_size = SIZEDATA_INDATABLOCK;
; 815  :     void* buf_read = (void*)ALLOC(buf_size);

  00356	68 f0 0f 00 00	 push	 4080			; 00000ff0H
  0035b	1b 4d ec	 sbb	 ecx, DWORD PTR _offset_central_dir$1$[ebp]
  0035e	2b c3		 sub	 eax, ebx
  00360	89 45 f0	 mov	 DWORD PTR _byte_before_the_zipfile$2$[ebp], eax
  00363	1b 4d f8	 sbb	 ecx, DWORD PTR _size_central_dir_to_read$2$[ebp]
  00366	89 4d f4	 mov	 DWORD PTR _byte_before_the_zipfile$1$[ebp], ecx
  00369	89 86 f0 00 01
	00		 mov	 DWORD PTR [esi+65776], eax
  0036f	89 8e f4 00 01
	00		 mov	 DWORD PTR [esi+65780], ecx
  00375	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc

; 816  :     if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)

  0037b	8b 4d f0	 mov	 ecx, DWORD PTR _byte_before_the_zipfile$2$[ebp]
  0037e	83 c4 04	 add	 esp, 4
  00381	03 4d fc	 add	 ecx, DWORD PTR _offset_central_dir$2$[ebp]
  00384	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00387	89 45 e8	 mov	 DWORD PTR _buf_read$1$[ebp], eax
  0038a	8b 45 f4	 mov	 eax, DWORD PTR _byte_before_the_zipfile$1$[ebp]
  0038d	13 45 ec	 adc	 eax, DWORD PTR _offset_central_dir$1$[ebp]
  00390	6a 00		 push	 0
  00392	50		 push	 eax
  00393	89 4d d4	 mov	 DWORD PTR tv537[ebp], ecx
  00396	51		 push	 ecx
  00397	8b ce		 mov	 ecx, esi
  00399	89 45 dc	 mov	 DWORD PTR tv538[ebp], eax
  0039c	e8 00 00 00 00	 call	 _call_zseek64
  003a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a4	85 c0		 test	 eax, eax
  003a6	b8 ff ff ff ff	 mov	 eax, -1
  003ab	0f 45 f8	 cmovne	 edi, eax

; 817  :       err=ZIP_ERRNO;
; 818  : 
; 819  :     while ((size_central_dir_to_read>0) && (err==ZIP_OK))

  003ae	8b 45 f8	 mov	 eax, DWORD PTR _size_central_dir_to_read$2$[ebp]
  003b1	85 c0		 test	 eax, eax
  003b3	75 0b		 jne	 SHORT $LL2@LoadCentra
  003b5	85 db		 test	 ebx, ebx
  003b7	74 75		 je	 SHORT $LN60@LoadCentra
  003b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@LoadCentra:
  003c0	85 ff		 test	 edi, edi
  003c2	75 6a		 jne	 SHORT $LN60@LoadCentra

; 820  :     {
; 821  :       ZPOS64_T read_this = SIZEDATA_INDATABLOCK;

  003c4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _read_this$2$[ebp], 0
  003cb	bf f0 0f 00 00	 mov	 edi, 4080		; 00000ff0H
  003d0	89 7d fc	 mov	 DWORD PTR _read_this$1$[ebp], edi

; 822  :       if (read_this > size_central_dir_to_read)

  003d3	85 c0		 test	 eax, eax
  003d5	77 0e		 ja	 SHORT $LN42@LoadCentra
  003d7	72 04		 jb	 SHORT $LN58@LoadCentra
  003d9	3b df		 cmp	 ebx, edi
  003db	73 08		 jae	 SHORT $LN42@LoadCentra
$LN58@LoadCentra:

; 823  :         read_this = size_central_dir_to_read;

  003dd	8b fb		 mov	 edi, ebx
  003df	89 5d fc	 mov	 DWORD PTR _read_this$1$[ebp], ebx
  003e2	89 45 ec	 mov	 DWORD PTR _read_this$2$[ebp], eax
$LN42@LoadCentra:

; 824  : 
; 825  :       if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)

  003e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  003e8	57		 push	 edi
  003e9	ff 75 e8	 push	 DWORD PTR _buf_read$1$[ebp]
  003ec	ff 76 2c	 push	 DWORD PTR [esi+44]
  003ef	ff 76 1c	 push	 DWORD PTR [esi+28]
  003f2	ff d0		 call	 eax
  003f4	83 c4 10	 add	 esp, 16			; 00000010H
  003f7	33 c9		 xor	 ecx, ecx
  003f9	3b c7		 cmp	 eax, edi
  003fb	75 18		 jne	 SHORT $LN59@LoadCentra
  003fd	3b 4d ec	 cmp	 ecx, DWORD PTR _read_this$2$[ebp]
  00400	75 13		 jne	 SHORT $LN59@LoadCentra

; 827  : 
; 828  :       if (err==ZIP_OK)
; 829  :         err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);

  00402	8b 55 e8	 mov	 edx, DWORD PTR _buf_read$1$[ebp]
  00405	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00408	57		 push	 edi
  00409	e8 00 00 00 00	 call	 _add_data_in_datablock
  0040e	83 c4 04	 add	 esp, 4
  00411	8b f8		 mov	 edi, eax
  00413	eb 03		 jmp	 SHORT $LN44@LoadCentra
$LN59@LoadCentra:

; 826  :         err=ZIP_ERRNO;

  00415	83 cf ff	 or	 edi, -1
$LN44@LoadCentra:

; 830  : 
; 831  :       size_central_dir_to_read-=read_this;

  00418	2b 5d fc	 sub	 ebx, DWORD PTR _read_this$1$[ebp]
  0041b	8b 45 f8	 mov	 eax, DWORD PTR _size_central_dir_to_read$2$[ebp]
  0041e	1b 45 ec	 sbb	 eax, DWORD PTR _read_this$2$[ebp]
  00421	89 45 f8	 mov	 DWORD PTR _size_central_dir_to_read$2$[ebp], eax
  00424	85 c0		 test	 eax, eax
  00426	77 98		 ja	 SHORT $LL2@LoadCentra

; 817  :       err=ZIP_ERRNO;
; 818  : 
; 819  :     while ((size_central_dir_to_read>0) && (err==ZIP_OK))

  00428	72 04		 jb	 SHORT $LN60@LoadCentra
  0042a	85 db		 test	 ebx, ebx
  0042c	75 92		 jne	 SHORT $LL2@LoadCentra
$LN60@LoadCentra:

; 832  :     }
; 833  :     TRYFREE(buf_read);

  0042e	8b 45 e8	 mov	 eax, DWORD PTR _buf_read$1$[ebp]
  00431	85 c0		 test	 eax, eax
  00433	74 0a		 je	 SHORT $LN45@LoadCentra
  00435	50		 push	 eax
  00436	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0043c	83 c4 04	 add	 esp, 4
$LN45@LoadCentra:

; 834  :   }
; 835  :   pziinit->begin_pos = byte_before_the_zipfile;

  0043f	8b 45 f0	 mov	 eax, DWORD PTR _byte_before_the_zipfile$2$[ebp]

; 836  :   pziinit->number_entry = number_entry_CD;
; 837  : 
; 838  :   if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)

  00442	8b ce		 mov	 ecx, esi
  00444	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00447	89 86 e8 00 01
	00		 mov	 DWORD PTR [esi+65768], eax
  0044d	8b 45 f4	 mov	 eax, DWORD PTR _byte_before_the_zipfile$1$[ebp]
  00450	6a 00		 push	 0
  00452	ff 75 dc	 push	 DWORD PTR tv538[ebp]
  00455	89 86 ec 00 01
	00		 mov	 DWORD PTR [esi+65772], eax
  0045b	8b 45 e4	 mov	 eax, DWORD PTR _number_entry_CD$2$[ebp]
  0045e	ff 75 d4	 push	 DWORD PTR tv537[ebp]
  00461	89 86 f8 00 01
	00		 mov	 DWORD PTR [esi+65784], eax
  00467	8b 45 e0	 mov	 eax, DWORD PTR _number_entry_CD$1$[ebp]
  0046a	89 86 fc 00 01
	00		 mov	 DWORD PTR [esi+65788], eax
  00470	e8 00 00 00 00	 call	 _call_zseek64
  00475	83 c4 0c	 add	 esp, 12			; 0000000cH
  00478	85 c0		 test	 eax, eax
  0047a	b8 ff ff ff ff	 mov	 eax, -1
  0047f	0f 45 f8	 cmovne	 edi, eax

; 839  :     err=ZIP_ERRNO;
; 840  : 
; 841  :   return err;

  00482	8b c7		 mov	 eax, edi

; 842  : }

  00484	5f		 pop	 edi
  00485	5e		 pop	 esi
  00486	5b		 pop	 ebx
  00487	8b e5		 mov	 esp, ebp
  00489	5d		 pop	 ebp
  0048a	c3		 ret	 0
$LN52@LoadCentra:

; 794  :   {
; 795  :     ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);

  0048b	ff 76 2c	 push	 DWORD PTR [esi+44]
  0048e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00491	ff 76 1c	 push	 DWORD PTR [esi+28]
  00494	ff d1		 call	 ecx
  00496	83 c4 08	 add	 esp, 8

; 796  :     return ZIP_ERRNO;

  00499	83 c8 ff	 or	 eax, -1

; 842  : }

  0049c	5f		 pop	 edi
  0049d	5e		 pop	 esi
  0049e	5b		 pop	 ebx
  0049f	8b e5		 mov	 esp, ebp
  004a1	5d		 pop	 ebp
  004a2	c3		 ret	 0
_LoadCentralDirectoryRecord ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpen3@16
_TEXT	SEGMENT
_ziinit$ = -65800					; size = 65800
_globalcomment$ = 8					; size = 4
_pzlib_filefunc64_32_def$ = 12				; size = 4
_zipOpen3@16 PROC					; COMDAT
; _pathname$ = ecx
; _append$ = edx

; 850  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 0c 01 01 00	 mov	 eax, 65804		; 0001010cH
  0000b	e8 00 00 00 00	 call	 __chkstk

; 851  :     zip64_internal ziinit;
; 852  :     zip64_internal* zi;
; 853  :     int err=ZIP_OK;
; 854  : 
; 855  :     ziinit.z_filefunc.zseek32_file = NULL;
; 856  :     ziinit.z_filefunc.ztell32_file = NULL;
; 857  :     if (pzlib_filefunc64_32_def==NULL)

  00010	8b 45 0c	 mov	 eax, DWORD PTR _pzlib_filefunc64_32_def$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	33 db		 xor	 ebx, ebx
  00017	89 5c 24 34	 mov	 DWORD PTR _ziinit$[esp+65852], ebx
  0001b	89 5c 24 30	 mov	 DWORD PTR _ziinit$[esp+65848], ebx
  0001f	57		 push	 edi
  00020	8b fa		 mov	 edi, edx
  00022	8b d1		 mov	 edx, ecx
  00024	85 c0		 test	 eax, eax
  00026	75 0b		 jne	 SHORT $LN2@zipOpen3

; 858  :         fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);

  00028	8d 4c 24 10	 lea	 ecx, DWORD PTR _ziinit$[esp+65816]
  0002c	e8 00 00 00 00	 call	 _fill_fopen64_filefunc
  00031	eb 23		 jmp	 SHORT $LN3@zipOpen3
$LN2@zipOpen3:

; 859  :     else
; 860  :         ziinit.z_filefunc = *pzlib_filefunc64_32_def;

  00033	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00036	0f 11 44 24 10	 movups	 XMMWORD PTR _ziinit$[esp+65816], xmm0
  0003b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0003f	0f 11 44 24 20	 movups	 XMMWORD PTR _ziinit$[esp+65832], xmm0
  00044	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00049	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0004c	66 0f d6 44 24
	30		 movq	 QWORD PTR _ziinit$[esp+65848], xmm0
  00052	89 44 24 38	 mov	 DWORD PTR _ziinit$[esp+65856], eax
$LN3@zipOpen3:

; 861  : 
; 862  :     ziinit.filestream = ZOPEN64(ziinit.z_filefunc,

  00056	33 c0		 xor	 eax, eax
  00058	8d 4c 24 10	 lea	 ecx, DWORD PTR _ziinit$[esp+65816]
  0005c	85 ff		 test	 edi, edi
  0005e	0f 94 c0	 sete	 al
  00061	8d 04 85 07 00
	00 00		 lea	 eax, DWORD PTR [eax*4+7]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _call_zopen64
  0006e	8b f0		 mov	 esi, eax
  00070	83 c4 04	 add	 esp, 4
  00073	89 74 24 3c	 mov	 DWORD PTR _ziinit$[esp+65860], esi

; 863  :                   pathname,
; 864  :                   (append == APPEND_STATUS_CREATE) ?
; 865  :                   (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
; 866  :                     (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));
; 867  : 
; 868  :     if (ziinit.filestream == NULL)

  00077	85 f6		 test	 esi, esi
  00079	74 7e		 je	 SHORT $LN14@zipOpen3

; 869  :         return NULL;
; 870  : 
; 871  :     if (append == APPEND_STATUS_CREATEAFTER)

  0007b	83 ff 01	 cmp	 edi, 1
  0007e	75 14		 jne	 SHORT $LN5@zipOpen3

; 872  :         ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);

  00080	6a 02		 push	 2
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	8b d6		 mov	 edx, esi
  00088	8d 4c 24 1c	 lea	 ecx, DWORD PTR _ziinit$[esp+65828]
  0008c	e8 00 00 00 00	 call	 _call_zseek64
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@zipOpen3:

; 873  : 
; 874  :     ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);

  00094	8b d6		 mov	 edx, esi
  00096	8d 4c 24 10	 lea	 ecx, DWORD PTR _ziinit$[esp+65816]
  0009a	e8 00 00 00 00	 call	 _call_ztell64
  0009f	0f 57 c0	 xorps	 xmm0, xmm0
  000a2	89 84 24 f8 00
	01 00		 mov	 DWORD PTR _ziinit$[esp+131584], eax

; 875  :     ziinit.in_opened_file_inzip = 0;
; 876  :     ziinit.ci.stream_initialised = 0;
; 877  :     ziinit.number_entry = 0;
; 878  :     ziinit.add_position_when_writting_offset = 0;
; 879  :     init_linkedlist(&(ziinit.central_dir));

  000a9	8d 4c 24 40	 lea	 ecx, DWORD PTR _ziinit$[esp+65864]
  000ad	89 94 24 fc 00
	01 00		 mov	 DWORD PTR _ziinit$[esp+131588], edx
  000b4	89 5c 24 48	 mov	 DWORD PTR _ziinit$[esp+65872], ebx
  000b8	89 9c 24 88 00
	00 00		 mov	 DWORD PTR _ziinit$[esp+65936], ebx
  000bf	66 0f 13 84 24
	08 01 01 00	 movlpd	 QWORD PTR _ziinit$[esp+131600], xmm0
  000c8	66 0f 13 84 24
	00 01 01 00	 movlpd	 QWORD PTR _ziinit$[esp+131592], xmm0
  000d1	e8 00 00 00 00	 call	 _init_linkedlist

; 880  : 
; 881  : 
; 882  : 
; 883  :     zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));

  000d6	68 08 01 01 00	 push	 65800			; 00010108H
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000e1	8b f0		 mov	 esi, eax
  000e3	83 c4 04	 add	 esp, 4

; 884  :     if (zi==NULL)

  000e6	85 f6		 test	 esi, esi
  000e8	75 1a		 jne	 SHORT $LN6@zipOpen3

; 885  :     {
; 886  :         ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);

  000ea	ff 74 24 3c	 push	 DWORD PTR _ziinit$[esp+65860]
  000ee	ff 74 24 30	 push	 DWORD PTR _ziinit$[esp+65848]
  000f2	ff 54 24 2c	 call	 DWORD PTR _ziinit$[esp+65844]
  000f6	83 c4 08	 add	 esp, 8
$LN14@zipOpen3:

; 887  :         return NULL;

  000f9	33 c0		 xor	 eax, eax

; 917  :     }
; 918  : }

  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 08 00	 ret	 8
$LN6@zipOpen3:

; 888  :     }
; 889  : 
; 890  :     /* now we add file in a zipfile */
; 891  : #    ifndef NO_ADDFILEINEXISTINGZIP
; 892  :     ziinit.globalcomment = NULL;

  00104	33 c0		 xor	 eax, eax
  00106	89 84 24 10 01
	01 00		 mov	 DWORD PTR _ziinit$[esp+131608], eax

; 893  :     if (append == APPEND_STATUS_ADDINZIP)

  0010d	83 ff 02	 cmp	 edi, 2
  00110	75 12		 jne	 SHORT $LN7@zipOpen3

; 894  :     {
; 895  :       // Read and Cache Central Directory Records
; 896  :       err = LoadCentralDirectoryRecord(&ziinit);

  00112	8d 4c 24 10	 lea	 ecx, DWORD PTR _ziinit$[esp+65816]
  00116	e8 00 00 00 00	 call	 _LoadCentralDirectoryRecord
  0011b	8b d8		 mov	 ebx, eax
  0011d	8b 84 24 10 01
	01 00		 mov	 eax, DWORD PTR _ziinit$[esp+131608]
$LN7@zipOpen3:

; 897  :     }
; 898  : 
; 899  :     if (globalcomment)

  00124	8b 4d 08	 mov	 ecx, DWORD PTR _globalcomment$[ebp]
  00127	85 c9		 test	 ecx, ecx
  00129	74 02		 je	 SHORT $LN8@zipOpen3

; 900  :     {
; 901  :       *globalcomment = ziinit.globalcomment;

  0012b	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@zipOpen3:

; 902  :     }
; 903  : #    endif /* !NO_ADDFILEINEXISTINGZIP*/
; 904  : 
; 905  :     if (err != ZIP_OK)

  0012d	85 db		 test	 ebx, ebx
  0012f	74 21		 je	 SHORT $LN9@zipOpen3

; 906  :     {
; 907  : #    ifndef NO_ADDFILEINEXISTINGZIP
; 908  :         TRYFREE(ziinit.globalcomment);

  00131	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  00137	85 c0		 test	 eax, eax
  00139	74 06		 je	 SHORT $LN11@zipOpen3
  0013b	50		 push	 eax
  0013c	ff d7		 call	 edi
  0013e	83 c4 04	 add	 esp, 4
$LN11@zipOpen3:

; 909  : #    endif /* !NO_ADDFILEINEXISTINGZIP*/
; 910  :         TRYFREE(zi);

  00141	56		 push	 esi
  00142	ff d7		 call	 edi
  00144	83 c4 04	 add	 esp, 4

; 911  :         return NULL;

  00147	33 c0		 xor	 eax, eax

; 917  :     }
; 918  : }

  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx
  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 08 00	 ret	 8
$LN9@zipOpen3:

; 912  :     }
; 913  :     else
; 914  :     {
; 915  :         *zi = ziinit;

  00152	68 08 01 01 00	 push	 65800			; 00010108H
  00157	8d 44 24 14	 lea	 eax, DWORD PTR _ziinit$[esp+65820]
  0015b	50		 push	 eax
  0015c	56		 push	 esi
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 916  :         return (zipFile)zi;

  00165	8b c6		 mov	 eax, esi

; 917  :     }
; 918  : }

  00167	5f		 pop	 edi
  00168	5e		 pop	 esi
  00169	5b		 pop	 ebx
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c2 08 00	 ret	 8
_zipOpen3@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpen2@16
_TEXT	SEGMENT
_zlib_filefunc64_32_def_fill$1 = -44			; size = 44
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_globalcomment$ = 16					; size = 4
_pzlib_filefunc32_def$ = 20				; size = 4
_zipOpen2@16 PROC					; COMDAT

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 922  :     if (pzlib_filefunc32_def != NULL)

  00006	8b 55 14	 mov	 edx, DWORD PTR _pzlib_filefunc32_def$[ebp]
  00009	83 ec 30	 sub	 esp, 48			; 00000030H
  0000c	85 d2		 test	 edx, edx
  0000e	74 20		 je	 SHORT $LN2@zipOpen2

; 923  :     {
; 924  :         zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
; 925  :         fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);

  00010	8d 4c 24 04	 lea	 ecx, DWORD PTR _zlib_filefunc64_32_def_fill$1[esp+48]
  00014	e8 00 00 00 00	 call	 _fill_zlib_filefunc64_32_def_from_filefunc32

; 926  :         return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
; 927  :     }
; 928  :     else
; 929  :         return zipOpen3(pathname, append, globalcomment, NULL);

  00019	8b 55 0c	 mov	 edx, DWORD PTR _append$[ebp]
  0001c	8b c1		 mov	 eax, ecx
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00021	50		 push	 eax
  00022	ff 75 10	 push	 DWORD PTR _globalcomment$[ebp]
  00025	e8 00 00 00 00	 call	 _zipOpen3@16

; 930  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
$LN2@zipOpen2:

; 926  :         return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
; 927  :     }
; 928  :     else
; 929  :         return zipOpen3(pathname, append, globalcomment, NULL);

  00030	8b 55 0c	 mov	 edx, DWORD PTR _append$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00036	6a 00		 push	 0
  00038	ff 75 10	 push	 DWORD PTR _globalcomment$[ebp]
  0003b	e8 00 00 00 00	 call	 _zipOpen3@16

; 930  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
_zipOpen2@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpen2_64@16
_TEXT	SEGMENT
_zlib_filefunc64_32_def_fill$1 = -44			; size = 44
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_globalcomment$ = 16					; size = 4
_pzlib_filefunc_def$ = 20				; size = 4
_zipOpen2_64@16 PROC					; COMDAT

; 933  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 934  :     if (pzlib_filefunc_def != NULL)

  00006	8b 45 14	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00009	83 ec 30	 sub	 esp, 48			; 00000030H

; 940  :         return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);

  0000c	8b 55 0c	 mov	 edx, DWORD PTR _append$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00012	85 c0		 test	 eax, eax
  00014	74 34		 je	 SHORT $LN2@zipOpen2_6

; 935  :     {
; 936  :         zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
; 937  :         zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
; 938  :         zlib_filefunc64_32_def_fill.ztell32_file = NULL;

  00016	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00019	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _zlib_filefunc64_32_def_fill$1[esp+84], 0

; 939  :         zlib_filefunc64_32_def_fill.zseek32_file = NULL;

  00021	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _zlib_filefunc64_32_def_fill$1[esp+88], 0
  00029	0f 11 44 24 04	 movups	 XMMWORD PTR _zlib_filefunc64_32_def_fill$1[esp+48], xmm0
  0002e	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]

; 940  :         return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);

  00032	8d 44 24 04	 lea	 eax, DWORD PTR _zlib_filefunc64_32_def_fill$1[esp+48]
  00036	50		 push	 eax

; 941  :     }
; 942  :     else
; 943  :         return zipOpen3(pathname, append, globalcomment, NULL);

  00037	ff 75 10	 push	 DWORD PTR _globalcomment$[ebp]
  0003a	0f 11 44 24 1c	 movups	 XMMWORD PTR _zlib_filefunc64_32_def_fill$1[esp+72], xmm0
  0003f	e8 00 00 00 00	 call	 _zipOpen3@16

; 944  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 10 00	 ret	 16			; 00000010H
$LN2@zipOpen2_6:

; 941  :     }
; 942  :     else
; 943  :         return zipOpen3(pathname, append, globalcomment, NULL);

  0004a	6a 00		 push	 0
  0004c	ff 75 10	 push	 DWORD PTR _globalcomment$[ebp]
  0004f	e8 00 00 00 00	 call	 _zipOpen3@16

; 944  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 10 00	 ret	 16			; 00000010H
_zipOpen2_64@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpen@8
_TEXT	SEGMENT
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_zipOpen@8 PROC						; COMDAT

; 949  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 950  :     return zipOpen3((const void*)pathname,append,NULL,NULL);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _append$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	e8 00 00 00 00	 call	 _zipOpen3@16

; 951  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
_zipOpen@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpen64@8
_TEXT	SEGMENT
_pathname$ = 8						; size = 4
_append$ = 12						; size = 4
_zipOpen64@8 PROC					; COMDAT

; 954  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 955  :     return zipOpen3(pathname,append,NULL,NULL);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _append$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _pathname$[ebp]
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	e8 00 00 00 00	 call	 _zipOpen3@16

; 956  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
_zipOpen64@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _Write_LocalFileHeader
_TEXT	SEGMENT
_filename$1$ = -8					; size = 4
_size_extrafield_local$ = 8				; size = 4
_extrafield_local$ = 12					; size = 4
_Write_LocalFileHeader PROC				; COMDAT
; _zi$ = ecx
; _filename$ = edx

; 959  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b c2		 mov	 eax, edx
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi

; 960  :   /* write the local header */
; 961  :   int err;
; 962  :   uInt size_filename = (uInt)strlen(filename);

  0000d	8b f8		 mov	 edi, eax
  0000f	89 45 f8	 mov	 DWORD PTR _filename$1$[ebp], eax
  00012	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL26@Write_Loca:
  00015	8a 07		 mov	 al, BYTE PTR [edi]
  00017	47		 inc	 edi
  00018	84 c0		 test	 al, al
  0001a	75 f9		 jne	 SHORT $LL26@Write_Loca

; 963  :   uInt size_extrafield = size_extrafield_local;
; 964  : 
; 965  :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);

  0001c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0001f	2b f9		 sub	 edi, ecx
  00021	8b 5d 08	 mov	 ebx, DWORD PTR _size_extrafield_local$[ebp]
  00024	8b ce		 mov	 ecx, esi
  00026	6a 04		 push	 4
  00028	6a 00		 push	 0
  0002a	68 50 4b 03 04	 push	 67324752		; 04034b50H
  0002f	e8 00 00 00 00	 call	 _zip64local_putValue
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 966  : 
; 967  :   if (err==ZIP_OK)

  00037	85 c0		 test	 eax, eax
  00039	0f 85 e6 00 00
	00		 jne	 $LN15@Write_Loca

; 968  :   {
; 969  :     if(zi->ci.zip64)
; 970  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);/* version needed to extract */

  0003f	8b ce		 mov	 ecx, esi
  00041	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00044	6a 02		 push	 2
  00046	50		 push	 eax
  00047	39 86 b0 00 01
	00		 cmp	 DWORD PTR [esi+65712], eax
  0004d	74 04		 je	 SHORT $LN3@Write_Loca
  0004f	6a 2d		 push	 45			; 0000002dH
  00051	eb 02		 jmp	 SHORT $LN31@Write_Loca
$LN3@Write_Loca:

; 971  :     else
; 972  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */

  00053	6a 14		 push	 20			; 00000014H
$LN31@Write_Loca:
  00055	e8 00 00 00 00	 call	 _zip64local_putValue
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 973  :   }
; 974  : 
; 975  :   if (err==ZIP_OK)

  0005d	85 c0		 test	 eax, eax
  0005f	0f 85 c0 00 00
	00		 jne	 $LN15@Write_Loca

; 976  :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);

  00065	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00068	8b ce		 mov	 ecx, esi
  0006a	6a 02		 push	 2
  0006c	50		 push	 eax
  0006d	ff b6 98 00 00
	00		 push	 DWORD PTR [esi+152]
  00073	e8 00 00 00 00	 call	 _zip64local_putValue
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 977  : 
; 978  :   if (err==ZIP_OK)

  0007b	85 c0		 test	 eax, eax
  0007d	0f 85 a2 00 00
	00		 jne	 $LN15@Write_Loca

; 979  :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);

  00083	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00086	8b ce		 mov	 ecx, esi
  00088	6a 02		 push	 2
  0008a	50		 push	 eax
  0008b	ff b6 9c 00 00
	00		 push	 DWORD PTR [esi+156]
  00091	e8 00 00 00 00	 call	 _zip64local_putValue
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 980  : 
; 981  :   if (err==ZIP_OK)

  00099	85 c0		 test	 eax, eax
  0009b	0f 85 84 00 00
	00		 jne	 $LN15@Write_Loca

; 982  :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);

  000a1	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000a4	8b ce		 mov	 ecx, esi
  000a6	6a 04		 push	 4
  000a8	50		 push	 eax
  000a9	ff b6 a4 00 01
	00		 push	 DWORD PTR [esi+65700]
  000af	e8 00 00 00 00	 call	 _zip64local_putValue
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 983  : 
; 984  :   // CRC / Compressed size / Uncompressed size will be filled in later and rewritten later
; 985  :   if (err==ZIP_OK)

  000b7	85 c0		 test	 eax, eax
  000b9	75 6a		 jne	 SHORT $LN15@Write_Loca

; 986  :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */

  000bb	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000be	8b ce		 mov	 ecx, esi
  000c0	6a 04		 push	 4
  000c2	50		 push	 eax
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _zip64local_putValue
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 987  :   if (err==ZIP_OK)

  000cc	85 c0		 test	 eax, eax
  000ce	75 55		 jne	 SHORT $LN15@Write_Loca

; 988  :   {
; 989  :     if(zi->ci.zip64)
; 990  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* compressed size, unknown */

  000d0	8b ce		 mov	 ecx, esi
  000d2	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000d5	6a 04		 push	 4
  000d7	50		 push	 eax
  000d8	39 86 b0 00 01
	00		 cmp	 DWORD PTR [esi+65712], eax
  000de	74 04		 je	 SHORT $LN10@Write_Loca
  000e0	6a ff		 push	 -1
  000e2	eb 02		 jmp	 SHORT $LN32@Write_Loca
$LN10@Write_Loca:

; 991  :     else
; 992  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */

  000e4	6a 00		 push	 0
$LN32@Write_Loca:
  000e6	e8 00 00 00 00	 call	 _zip64local_putValue
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 993  :   }
; 994  :   if (err==ZIP_OK)

  000ee	85 c0		 test	 eax, eax
  000f0	75 33		 jne	 SHORT $LN15@Write_Loca

; 995  :   {
; 996  :     if(zi->ci.zip64)
; 997  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* uncompressed size, unknown */

  000f2	8b ce		 mov	 ecx, esi
  000f4	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000f7	6a 04		 push	 4
  000f9	50		 push	 eax
  000fa	39 86 b0 00 01
	00		 cmp	 DWORD PTR [esi+65712], eax
  00100	74 04		 je	 SHORT $LN13@Write_Loca
  00102	6a ff		 push	 -1
  00104	eb 02		 jmp	 SHORT $LN33@Write_Loca
$LN13@Write_Loca:

; 998  :     else
; 999  :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */

  00106	6a 00		 push	 0
$LN33@Write_Loca:
  00108	e8 00 00 00 00	 call	 _zip64local_putValue
  0010d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1000 :   }
; 1001 : 
; 1002 :   if (err==ZIP_OK)

  00110	85 c0		 test	 eax, eax
  00112	75 11		 jne	 SHORT $LN15@Write_Loca

; 1003 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);

  00114	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00117	8b ce		 mov	 ecx, esi
  00119	6a 02		 push	 2
  0011b	50		 push	 eax
  0011c	57		 push	 edi
  0011d	e8 00 00 00 00	 call	 _zip64local_putValue
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@Write_Loca:

; 1004 : 
; 1005 :   if(zi->ci.zip64)

  00125	83 be b0 00 01
	00 00		 cmp	 DWORD PTR [esi+65712], 0

; 1006 :   {
; 1007 :     size_extrafield += 20;

  0012c	8d 4b 14	 lea	 ecx, DWORD PTR [ebx+20]
  0012f	75 02		 jne	 SHORT $LN16@Write_Loca
  00131	8b cb		 mov	 ecx, ebx
$LN16@Write_Loca:

; 1008 :   }
; 1009 : 
; 1010 :   if (err==ZIP_OK)

  00133	85 c0		 test	 eax, eax
  00135	0f 85 c7 00 00
	00		 jne	 $LN22@Write_Loca

; 1011 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield,2);

  0013b	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0013e	6a 02		 push	 2
  00140	50		 push	 eax
  00141	51		 push	 ecx
  00142	8b ce		 mov	 ecx, esi
  00144	e8 00 00 00 00	 call	 _zip64local_putValue
  00149	8b d8		 mov	 ebx, eax
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1012 : 
; 1013 :   if ((err==ZIP_OK) && (size_filename > 0))

  0014e	85 db		 test	 ebx, ebx
  00150	0f 85 aa 00 00
	00		 jne	 $LN28@Write_Loca
  00156	85 ff		 test	 edi, edi
  00158	74 20		 je	 SHORT $LN24@Write_Loca

; 1014 :   {
; 1015 :     if (ZWRITE64(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)

  0015a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015d	57		 push	 edi
  0015e	ff 75 f8	 push	 DWORD PTR _filename$1$[ebp]
  00161	ff 76 2c	 push	 DWORD PTR [esi+44]
  00164	ff 76 1c	 push	 DWORD PTR [esi+28]
  00167	ff d0		 call	 eax
  00169	83 c4 10	 add	 esp, 16			; 00000010H
  0016c	3b c7		 cmp	 eax, edi
  0016e	74 0a		 je	 SHORT $LN24@Write_Loca
$LN34@Write_Loca:

; 1042 :   }
; 1043 : 
; 1044 :   return err;

  00170	83 c8 ff	 or	 eax, -1

; 1045 : }

  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx
  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c3		 ret	 0
$LN24@Write_Loca:

; 1016 :       err = ZIP_ERRNO;
; 1017 :   }
; 1018 : 
; 1019 :   if ((err==ZIP_OK) && (size_extrafield_local > 0))

  0017a	8b 7d 08	 mov	 edi, DWORD PTR _size_extrafield_local$[ebp]
  0017d	85 ff		 test	 edi, edi
  0017f	74 16		 je	 SHORT $LN25@Write_Loca

; 1020 :   {
; 1021 :     if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)

  00181	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00184	57		 push	 edi
  00185	ff 75 0c	 push	 DWORD PTR _extrafield_local$[ebp]
  00188	ff 76 2c	 push	 DWORD PTR [esi+44]
  0018b	ff 76 1c	 push	 DWORD PTR [esi+28]
  0018e	ff d0		 call	 eax
  00190	83 c4 10	 add	 esp, 16			; 00000010H
  00193	3b c7		 cmp	 eax, edi
  00195	75 d9		 jne	 SHORT $LN34@Write_Loca
$LN25@Write_Loca:

; 1022 :       err = ZIP_ERRNO;
; 1023 :   }
; 1024 : 
; 1025 : 
; 1026 :   if ((err==ZIP_OK) && (zi->ci.zip64))

  00197	83 be b0 00 01
	00 00		 cmp	 DWORD PTR [esi+65712], 0
  0019e	74 60		 je	 SHORT $LN28@Write_Loca

; 1027 :   {
; 1028 :       // write the Zip64 extended info
; 1029 :       short HeaderID = 1;
; 1030 :       short DataSize = 16;
; 1031 :       ZPOS64_T CompressedSize = 0;
; 1032 :       ZPOS64_T UncompressedSize = 0;
; 1033 : 
; 1034 :       // Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)
; 1035 :       zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc,zi->filestream);

  001a0	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001a3	8b ce		 mov	 ecx, esi
  001a5	e8 00 00 00 00	 call	 _call_ztell64

; 1036 : 
; 1037 :       err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)HeaderID,2);

  001aa	6a 02		 push	 2
  001ac	89 96 bc 00 01
	00		 mov	 DWORD PTR [esi+65724], edx
  001b2	8b ce		 mov	 ecx, esi
  001b4	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001b7	6a 00		 push	 0
  001b9	6a 01		 push	 1
  001bb	89 86 b8 00 01
	00		 mov	 DWORD PTR [esi+65720], eax
  001c1	e8 00 00 00 00	 call	 _zip64local_putValue

; 1038 :       err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)DataSize,2);

  001c6	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001c9	8b ce		 mov	 ecx, esi
  001cb	6a 02		 push	 2
  001cd	6a 00		 push	 0
  001cf	6a 10		 push	 16			; 00000010H
  001d1	e8 00 00 00 00	 call	 _zip64local_putValue

; 1039 : 
; 1040 :       err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize,8);

  001d6	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001d9	8b ce		 mov	 ecx, esi
  001db	6a 08		 push	 8
  001dd	6a 00		 push	 0
  001df	6a 00		 push	 0
  001e1	e8 00 00 00 00	 call	 _zip64local_putValue

; 1041 :       err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize,8);

  001e6	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  001e9	8b ce		 mov	 ecx, esi
  001eb	6a 08		 push	 8
  001ed	6a 00		 push	 0
  001ef	6a 00		 push	 0
  001f1	e8 00 00 00 00	 call	 _zip64local_putValue
  001f6	83 c4 30	 add	 esp, 48			; 00000030H

; 1045 : }

  001f9	5f		 pop	 edi
  001fa	5e		 pop	 esi
  001fb	5b		 pop	 ebx
  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c3		 ret	 0
$LN28@Write_Loca:

; 1042 :   }
; 1043 : 
; 1044 :   return err;

  00200	8b c3		 mov	 eax, ebx
$LN22@Write_Loca:

; 1045 : }

  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c3		 ret	 0
_Write_LocalFileHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpenNewFileInZip4_64@76
_TEXT	SEGMENT
_size_comment$1$ = -20					; size = 4
_filename$2$ = -16					; size = 4
_bufHead$1 = -12					; size = 12
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_windowBits$ = 52					; size = 4
_memLevel$ = 56						; size = 4
_strategy$ = 60						; size = 4
_password$ = 64						; size = 4
_crcForCrypting$ = 68					; size = 4
_versionMadeBy$ = 72					; size = 4
_flagBase$ = 76						; size = 4
_zip64$ = 80						; size = 4
_zipOpenNewFileInZip4_64@76 PROC			; COMDAT

; 1062 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1063 :     zip64_internal* zi;
; 1064 :     uInt size_filename;
; 1065 :     uInt size_comment;
; 1066 :     uInt i;
; 1067 :     int err = ZIP_OK;
; 1068 : 
; 1069 : #    ifdef NOCRYPT
; 1070 :     (crcForCrypting);
; 1071 :     if (password != NULL)
; 1072 :         return ZIP_PARAMERROR;
; 1073 : #    endif
; 1074 : 
; 1075 :     if (file == NULL)

  0000b	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000e	57		 push	 edi
  0000f	85 f6		 test	 esi, esi
  00011	75 0e		 jne	 SHORT $LN11@zipOpenNew
$LN64@zipOpenNew:

; 1076 :         return ZIP_PARAMERROR;

  00013	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 1263 : }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 4c 00	 ret	 76			; 0000004cH
$LN11@zipOpenNew:

; 1077 : 
; 1078 : #ifdef HAVE_BZIP2
; 1079 :     if ((method!=0) && (method!=Z_DEFLATED) && (method!=Z_BZIP2ED))
; 1080 :       return ZIP_PARAMERROR;
; 1081 : #else
; 1082 :     if ((method!=0) && (method!=Z_DEFLATED))

  00021	8b 45 28	 mov	 eax, DWORD PTR _method$[ebp]
  00024	85 c0		 test	 eax, eax
  00026	74 05		 je	 SHORT $LN12@zipOpenNew
  00028	83 f8 08	 cmp	 eax, 8
  0002b	75 e6		 jne	 SHORT $LN64@zipOpenNew
$LN12@zipOpenNew:

; 1083 :       return ZIP_PARAMERROR;
; 1084 : #endif
; 1085 : 
; 1086 :     zi = (zip64_internal*)file;
; 1087 : 
; 1088 :     if (zi->in_opened_file_inzip == 1)

  0002d	83 7e 38 01	 cmp	 DWORD PTR [esi+56], 1
  00031	75 0e		 jne	 SHORT $LN14@zipOpenNew

; 1089 :     {
; 1090 :         err = zipCloseFileInZip (file);

  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 _zipCloseFileInZip@4

; 1091 :         if (err != ZIP_OK)

  00039	85 c0		 test	 eax, eax
  0003b	0f 85 95 04 00
	00		 jne	 $LN1@zipOpenNew
$LN14@zipOpenNew:

; 1092 :             return err;
; 1093 :     }
; 1094 : 
; 1095 :     if (filename==NULL)

  00041	8b 45 0c	 mov	 eax, DWORD PTR _filename$[ebp]
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  00049	85 c0		 test	 eax, eax
  0004b	0f 45 c8	 cmovne	 ecx, eax

; 1096 :         filename="-";
; 1097 : 
; 1098 :     if (comment==NULL)

  0004e	8b 45 24	 mov	 eax, DWORD PTR _comment$[ebp]
  00051	89 4c 24 10	 mov	 DWORD PTR _filename$2$[esp+32], ecx
  00055	85 c0		 test	 eax, eax
  00057	75 04		 jne	 SHORT $LN16@zipOpenNew

; 1099 :         size_comment = 0;

  00059	33 db		 xor	 ebx, ebx
  0005b	eb 0e		 jmp	 SHORT $LN61@zipOpenNew
$LN16@zipOpenNew:

; 1100 :     else
; 1101 :         size_comment = (uInt)strlen(comment);

  0005d	8b d8		 mov	 ebx, eax
  0005f	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
$LL58@zipOpenNew:
  00062	8a 03		 mov	 al, BYTE PTR [ebx]
  00064	43		 inc	 ebx
  00065	84 c0		 test	 al, al
  00067	75 f9		 jne	 SHORT $LL58@zipOpenNew
  00069	2b da		 sub	 ebx, edx
$LN61@zipOpenNew:

; 1102 : 
; 1103 :     size_filename = (uInt)strlen(filename);

  0006b	8b f9		 mov	 edi, ecx
  0006d	89 5c 24 0c	 mov	 DWORD PTR _size_comment$1$[esp+32], ebx
  00071	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL59@zipOpenNew:
  00074	8a 07		 mov	 al, BYTE PTR [edi]
  00076	47		 inc	 edi
  00077	84 c0		 test	 al, al
  00079	75 f9		 jne	 SHORT $LL59@zipOpenNew

; 1104 : 
; 1105 :     if (zipfi == NULL)

  0007b	8b 45 10	 mov	 eax, DWORD PTR _zipfi$[ebp]
  0007e	2b f9		 sub	 edi, ecx
  00080	85 c0		 test	 eax, eax
  00082	75 08		 jne	 SHORT $LN18@zipOpenNew

; 1106 :         zi->ci.dosDate = 0;

  00084	89 86 a4 00 01
	00		 mov	 DWORD PTR [esi+65700], eax
  0008a	eb 1c		 jmp	 SHORT $LN21@zipOpenNew
$LN18@zipOpenNew:

; 1107 :     else
; 1108 :     {
; 1109 :         if (zipfi->dosDate != 0)

  0008c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0008f	85 c9		 test	 ecx, ecx
  00091	74 08		 je	 SHORT $LN20@zipOpenNew

; 1110 :             zi->ci.dosDate = zipfi->dosDate;

  00093	89 8e a4 00 01
	00		 mov	 DWORD PTR [esi+65700], ecx
  00099	eb 0d		 jmp	 SHORT $LN21@zipOpenNew
$LN20@zipOpenNew:

; 1111 :         else
; 1112 :           zi->ci.dosDate = zip64local_TmzDateToDosDate(&zipfi->tmz_date);

  0009b	8b c8		 mov	 ecx, eax
  0009d	e8 00 00 00 00	 call	 _zip64local_TmzDateToDosDate
  000a2	89 86 a4 00 01
	00		 mov	 DWORD PTR [esi+65700], eax
$LN21@zipOpenNew:

; 1113 :     }
; 1114 : 
; 1115 :     zi->ci.flag = flagBase;
; 1116 :     if ((level==8) || (level==9))

  000a8	8b 4d 2c	 mov	 ecx, DWORD PTR _level$[ebp]
  000ab	8b 45 4c	 mov	 eax, DWORD PTR _flagBase$[ebp]
  000ae	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
  000b4	83 f9 08	 cmp	 ecx, 8
  000b7	74 05		 je	 SHORT $LN23@zipOpenNew
  000b9	83 f9 09	 cmp	 ecx, 9
  000bc	75 09		 jne	 SHORT $LN22@zipOpenNew
$LN23@zipOpenNew:

; 1117 :       zi->ci.flag |= 2;

  000be	83 c8 02	 or	 eax, 2
  000c1	89 86 98 00 00
	00		 mov	 DWORD PTR [esi+152], eax
$LN22@zipOpenNew:

; 1118 :     if (level==2)

  000c7	83 f9 02	 cmp	 ecx, 2
  000ca	75 09		 jne	 SHORT $LN24@zipOpenNew

; 1119 :       zi->ci.flag |= 4;

  000cc	83 8e 98 00 00
	00 04		 or	 DWORD PTR [esi+152], 4

; 1120 :     if (level==1)

  000d3	eb 0c		 jmp	 SHORT $LN25@zipOpenNew
$LN24@zipOpenNew:
  000d5	83 f9 01	 cmp	 ecx, 1
  000d8	75 07		 jne	 SHORT $LN25@zipOpenNew

; 1121 :       zi->ci.flag |= 6;

  000da	83 8e 98 00 00
	00 06		 or	 DWORD PTR [esi+152], 6
$LN25@zipOpenNew:

; 1122 :     if (password != NULL)

  000e1	83 7d 40 00	 cmp	 DWORD PTR _password$[ebp], 0
  000e5	74 07		 je	 SHORT $LN26@zipOpenNew

; 1123 :       zi->ci.flag |= 1;

  000e7	83 8e 98 00 00
	00 01		 or	 DWORD PTR [esi+152], 1
$LN26@zipOpenNew:

; 1124 : 
; 1125 :     zi->ci.crc32 = 0;
; 1126 :     zi->ci.method = method;

  000ee	8b 45 28	 mov	 eax, DWORD PTR _method$[ebp]

; 1127 :     zi->ci.encrypt = 0;
; 1128 :     zi->ci.stream_initialised = 0;
; 1129 :     zi->ci.pos_in_buffered_data = 0;
; 1130 :     zi->ci.raw = raw;
; 1131 :     zi->ci.pos_local_header = ZTELL64(zi->z_filefunc,zi->filestream);

  000f1	8b ce		 mov	 ecx, esi
  000f3	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000f6	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  000fc	8b 45 30	 mov	 eax, DWORD PTR _raw$[ebp]
  000ff	c7 86 a8 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65704], 0
  00109	c7 86 ac 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65708], 0
  00113	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0
  0011a	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
  00121	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
  00127	e8 00 00 00 00	 call	 _call_ztell64

; 1132 : 
; 1133 :     zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + size_extrafield_global + size_comment;

  0012c	8b 4d 20	 mov	 ecx, DWORD PTR _size_extrafield_global$[ebp]
  0012f	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  00135	83 c1 2e	 add	 ecx, 46			; 0000002eH
  00138	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0013b	89 96 84 00 00
	00		 mov	 DWORD PTR [esi+132], edx
  00141	03 c1		 add	 eax, ecx

; 1134 :     zi->ci.size_centralExtraFree = 32; // Extra space we have reserved in case we need to add ZIP64 extra info data

  00143	c7 86 94 00 00
	00 20 00 00 00	 mov	 DWORD PTR [esi+148], 32	; 00000020H
  0014d	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 1135 : 
; 1136 :     zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader + zi->ci.size_centralExtraFree);

  00153	83 c0 20	 add	 eax, 32			; 00000020H
  00156	50		 push	 eax
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc

; 1137 : 
; 1138 :     zi->ci.size_centralExtra = size_extrafield_global;

  0015d	8b 4d 20	 mov	 ecx, DWORD PTR _size_extrafield_global$[ebp]
  00160	83 c4 04	 add	 esp, 4
  00163	89 8e 8c 00 00
	00		 mov	 DWORD PTR [esi+140], ecx

; 1139 :     zip64local_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);

  00169	ba 04 00 00 00	 mov	 edx, 4
  0016e	8b c8		 mov	 ecx, eax
  00170	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00176	6a 00		 push	 0
  00178	68 50 4b 01 02	 push	 33639248		; 02014b50H
  0017d	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1140 :     /* version info */
; 1141 :     zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)versionMadeBy,2);

  00182	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00188	6a 00		 push	 0
  0018a	ff 75 48	 push	 DWORD PTR _versionMadeBy$[ebp]
  0018d	03 ca		 add	 ecx, edx
  0018f	ba 02 00 00 00	 mov	 edx, 2
  00194	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1142 :     zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)20,2);

  00199	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0019f	6a 00		 push	 0
  001a1	6a 14		 push	 20			; 00000014H
  001a3	83 c1 06	 add	 ecx, 6
  001a6	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1143 :     zip64local_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);

  001ab	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  001b1	6a 00		 push	 0
  001b3	ff b6 98 00 00
	00		 push	 DWORD PTR [esi+152]
  001b9	83 c1 08	 add	 ecx, 8
  001bc	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1144 :     zip64local_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);

  001c1	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  001c7	6a 00		 push	 0
  001c9	ff b6 9c 00 00
	00		 push	 DWORD PTR [esi+156]
  001cf	83 c1 0a	 add	 ecx, 10			; 0000000aH
  001d2	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1145 :     zip64local_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);

  001d7	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  001dd	ba 04 00 00 00	 mov	 edx, 4
  001e2	6a 00		 push	 0
  001e4	ff b6 a4 00 01
	00		 push	 DWORD PTR [esi+65700]
  001ea	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001ed	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1146 :     zip64local_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/

  001f2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  001f8	6a 00		 push	 0
  001fa	6a 00		 push	 0
  001fc	83 c1 10	 add	 ecx, 16			; 00000010H
  001ff	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1147 :     zip64local_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/

  00204	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0020a	6a 00		 push	 0
  0020c	6a 00		 push	 0
  0020e	83 c1 14	 add	 ecx, 20			; 00000014H
  00211	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1148 :     zip64local_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/

  00216	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0021c	83 c4 40	 add	 esp, 64			; 00000040H
  0021f	83 c1 18	 add	 ecx, 24			; 00000018H
  00222	6a 00		 push	 0
  00224	6a 00		 push	 0
  00226	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1149 :     zip64local_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);

  0022b	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00231	ba 02 00 00 00	 mov	 edx, 2
  00236	6a 00		 push	 0
  00238	57		 push	 edi
  00239	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0023c	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1150 :     zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);

  00241	6a 00		 push	 0
  00243	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00249	ff 75 20	 push	 DWORD PTR _size_extrafield_global$[ebp]
  0024c	83 c1 1e	 add	 ecx, 30			; 0000001eH
  0024f	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1151 :     zip64local_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);

  00254	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0025a	6a 00		 push	 0
  0025c	53		 push	 ebx
  0025d	83 c1 20	 add	 ecx, 32			; 00000020H
  00260	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1152 :     zip64local_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/

  00265	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0026b	6a 00		 push	 0
  0026d	6a 00		 push	 0
  0026f	83 c1 22	 add	 ecx, 34			; 00000022H
  00272	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1153 : 
; 1154 :     if (zipfi==NULL)
; 1155 :         zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2);

  00277	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0027d	83 c4 28	 add	 esp, 40			; 00000028H
  00280	8b 45 10	 mov	 eax, DWORD PTR _zipfi$[ebp]
  00283	83 c1 24	 add	 ecx, 36			; 00000024H
  00286	6a 00		 push	 0
  00288	85 c0		 test	 eax, eax
  0028a	75 0c		 jne	 SHORT $LN27@zipOpenNew
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1158 : 
; 1159 :     if (zipfi==NULL)
; 1160 :         zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4);

  00292	6a 00		 push	 0
  00294	6a 00		 push	 0
  00296	eb 10		 jmp	 SHORT $LN62@zipOpenNew
$LN27@zipOpenNew:

; 1156 :     else
; 1157 :         zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2);

  00298	ff 70 1c	 push	 DWORD PTR [eax+28]
  0029b	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1161 :     else
; 1162 :         zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);

  002a0	8b 45 10	 mov	 eax, DWORD PTR _zipfi$[ebp]
  002a3	6a 00		 push	 0
  002a5	ff 70 20	 push	 DWORD PTR [eax+32]
$LN62@zipOpenNew:
  002a8	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  002ae	ba 04 00 00 00	 mov	 edx, 4
  002b3	83 c1 26	 add	 ecx, 38			; 00000026H
  002b6	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  002bb	83 c4 10	 add	 esp, 16			; 00000010H

; 1163 : 
; 1164 :     if(zi->ci.pos_local_header >= 0xffffffff)

  002be	83 be 84 00 00
	00 00		 cmp	 DWORD PTR [esi+132], 0
  002c5	77 21		 ja	 SHORT $LN60@zipOpenNew
  002c7	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  002ce	73 18		 jae	 SHORT $LN60@zipOpenNew

; 1166 :     else
; 1167 :       zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header - zi->add_position_when_writting_offset,4);

  002d0	8b 8e 80 00 00
	00		 mov	 ecx, DWORD PTR [esi+128]
  002d6	33 c0		 xor	 eax, eax
  002d8	2b 8e f0 00 01
	00		 sub	 ecx, DWORD PTR [esi+65776]
  002de	1b 86 f4 00 01
	00		 sbb	 eax, DWORD PTR [esi+65780]
  002e4	50		 push	 eax
  002e5	51		 push	 ecx
  002e6	eb 04		 jmp	 SHORT $LN63@zipOpenNew
$LN60@zipOpenNew:

; 1165 :       zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)0xffffffff,4);

  002e8	6a 00		 push	 0
  002ea	6a ff		 push	 -1
$LN63@zipOpenNew:
  002ec	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  002f2	ba 04 00 00 00	 mov	 edx, 4
  002f7	83 c1 2a	 add	 ecx, 42			; 0000002aH
  002fa	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  002ff	83 c4 08	 add	 esp, 8

; 1168 : 
; 1169 :     for (i=0;i<size_filename;i++)

  00302	33 d2		 xor	 edx, edx
  00304	85 ff		 test	 edi, edi
  00306	74 1e		 je	 SHORT $LN3@zipOpenNew
  00308	8b 5c 24 10	 mov	 ebx, DWORD PTR _filename$2$[esp+32]
  0030c	0f 1f 40 00	 npad	 4
$LL4@zipOpenNew:

; 1170 :         *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);

  00310	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00316	8a 04 1a	 mov	 al, BYTE PTR [edx+ebx]
  00319	88 44 11 2e	 mov	 BYTE PTR [ecx+edx+46], al
  0031d	42		 inc	 edx
  0031e	3b d7		 cmp	 edx, edi
  00320	72 ee		 jb	 SHORT $LL4@zipOpenNew
  00322	8b 5c 24 0c	 mov	 ebx, DWORD PTR _size_comment$1$[esp+32]
$LN3@zipOpenNew:

; 1171 : 
; 1172 :     for (i=0;i<size_extrafield_global;i++)

  00326	33 d2		 xor	 edx, edx
  00328	39 55 20	 cmp	 DWORD PTR _size_extrafield_global$[ebp], edx
  0032b	76 1e		 jbe	 SHORT $LN6@zipOpenNew
  0032d	8b 5d 20	 mov	 ebx, DWORD PTR _size_extrafield_global$[ebp]
$LL7@zipOpenNew:

; 1173 :         *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =

  00330	8b 45 1c	 mov	 eax, DWORD PTR _extrafield_global$[ebp]
  00333	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00339	03 ca		 add	 ecx, edx
  0033b	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0033e	42		 inc	 edx
  0033f	88 44 39 2e	 mov	 BYTE PTR [ecx+edi+46], al
  00343	3b d3		 cmp	 edx, ebx
  00345	72 e9		 jb	 SHORT $LL7@zipOpenNew
  00347	8b 5c 24 0c	 mov	 ebx, DWORD PTR _size_comment$1$[esp+32]
$LN6@zipOpenNew:

; 1174 :               *(((const char*)extrafield_global)+i);
; 1175 : 
; 1176 :     for (i=0;i<size_comment;i++)

  0034b	33 d2		 xor	 edx, edx
  0034d	85 db		 test	 ebx, ebx
  0034f	74 1f		 je	 SHORT $LN9@zipOpenNew
$LL10@zipOpenNew:

; 1177 :         *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+
; 1178 :               size_extrafield_global+i) = *(comment+i);

  00351	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00357	8b 45 24	 mov	 eax, DWORD PTR _comment$[ebp]
  0035a	03 ca		 add	 ecx, edx
  0035c	8b 75 20	 mov	 esi, DWORD PTR _size_extrafield_global$[ebp]
  0035f	03 cf		 add	 ecx, edi
  00361	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00364	42		 inc	 edx
  00365	88 44 31 2e	 mov	 BYTE PTR [ecx+esi+46], al
  00369	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0036c	3b d3		 cmp	 edx, ebx
  0036e	72 e1		 jb	 SHORT $LL10@zipOpenNew
$LN9@zipOpenNew:

; 1179 :     if (zi->ci.central_header == NULL)

  00370	83 be 88 00 00
	00 00		 cmp	 DWORD PTR [esi+136], 0
  00377	75 0e		 jne	 SHORT $LN33@zipOpenNew

; 1180 :         return ZIP_INTERNALERROR;

  00379	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H

; 1263 : }

  0037e	5f		 pop	 edi
  0037f	5e		 pop	 esi
  00380	5b		 pop	 ebx
  00381	8b e5		 mov	 esp, ebp
  00383	5d		 pop	 ebp
  00384	c2 4c 00	 ret	 76			; 0000004cH
$LN33@zipOpenNew:

; 1181 : 
; 1182 :     zi->ci.zip64 = zip64;
; 1183 :     zi->ci.totalCompressedData = 0;
; 1184 :     zi->ci.totalUncompressedData = 0;
; 1185 :     zi->ci.pos_zip64extrainfo = 0;
; 1186 : 
; 1187 :     err = Write_LocalFileHeader(zi, filename, size_extrafield_local, extrafield_local);

  00387	ff 75 14	 push	 DWORD PTR _extrafield_local$[ebp]
  0038a	8b 45 50	 mov	 eax, DWORD PTR _zip64$[ebp]
  0038d	8b ce		 mov	 ecx, esi
  0038f	ff 75 18	 push	 DWORD PTR _size_extrafield_local$[ebp]
  00392	8b 54 24 18	 mov	 edx, DWORD PTR _filename$2$[esp+40]
  00396	89 86 b0 00 01
	00		 mov	 DWORD PTR [esi+65712], eax
  0039c	c7 86 c0 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65728], 0
  003a6	c7 86 c4 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65732], 0
  003b0	c7 86 c8 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65736], 0
  003ba	c7 86 cc 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65740], 0
  003c4	c7 86 b8 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65720], 0
  003ce	c7 86 bc 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65724], 0
  003d8	e8 00 00 00 00	 call	 _Write_LocalFileHeader
  003dd	8b d8		 mov	 ebx, eax

; 1188 : 
; 1189 : #ifdef HAVE_BZIP2
; 1190 :     zi->ci.bstream.avail_in = (uInt)0;
; 1191 :     zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
; 1192 :     zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
; 1193 :     zi->ci.bstream.total_in_hi32 = 0;
; 1194 :     zi->ci.bstream.total_in_lo32 = 0;
; 1195 :     zi->ci.bstream.total_out_hi32 = 0;
; 1196 :     zi->ci.bstream.total_out_lo32 = 0;
; 1197 : #endif
; 1198 : 
; 1199 :     zi->ci.stream.avail_in = (uInt)0;

  003df	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  003e6	83 c4 08	 add	 esp, 8

; 1200 :     zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;

  003e9	c7 46 50 00 00
	01 00		 mov	 DWORD PTR [esi+80], 65536 ; 00010000H

; 1201 :     zi->ci.stream.next_out = zi->ci.buffered_data;
; 1202 :     zi->ci.stream.total_in = 0;

  003f0	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  003f7	8d 8e a4 00 00
	00		 lea	 ecx, DWORD PTR [esi+164]
  003fd	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx

; 1203 :     zi->ci.stream.total_out = 0;

  00400	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0

; 1204 :     zi->ci.stream.data_type = Z_BINARY;

  00407	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 1205 : 
; 1206 : #ifdef HAVE_BZIP2
; 1207 :     if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED || zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
; 1208 : #else
; 1209 :     if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))

  0040e	85 db		 test	 ebx, ebx
  00410	75 4c		 jne	 SHORT $LN38@zipOpenNew
  00412	83 be 9c 00 00
	00 08		 cmp	 DWORD PTR [esi+156], 8
  00419	75 43		 jne	 SHORT $LN38@zipOpenNew
  0041b	39 86 a0 00 00
	00		 cmp	 DWORD PTR [esi+160], eax
  00421	75 3b		 jne	 SHORT $LN38@zipOpenNew

; 1210 : #endif
; 1211 :     {
; 1212 :         if(zi->ci.method == Z_DEFLATED)
; 1213 :         {
; 1214 :           zi->ci.stream.zalloc = (alloc_func)0;

  00423	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1215 :           zi->ci.stream.zfree = (free_func)0;

  00426	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 1216 :           zi->ci.stream.opaque = (voidpf)0;

  00429	89 46 68	 mov	 DWORD PTR [esi+104], eax

; 1217 : 
; 1218 :           if (windowBits>0)

  0042c	8b 45 34	 mov	 eax, DWORD PTR _windowBits$[ebp]
  0042f	85 c0		 test	 eax, eax
  00431	7e 02		 jle	 SHORT $LN37@zipOpenNew

; 1219 :               windowBits = -windowBits;

  00433	f7 d8		 neg	 eax
$LN37@zipOpenNew:

; 1220 : 
; 1221 :           err = deflateInit2(&zi->ci.stream, level, Z_DEFLATED, windowBits, memLevel, strategy);

  00435	6a 38		 push	 56			; 00000038H
  00437	68 00 00 00 00	 push	 OFFSET ??_C@_05IAIEPMAK@1?42?48?$AA@
  0043c	ff 75 3c	 push	 DWORD PTR _strategy$[ebp]
  0043f	ff 75 38	 push	 DWORD PTR _memLevel$[ebp]
  00442	50		 push	 eax
  00443	6a 08		 push	 8
  00445	ff 75 2c	 push	 DWORD PTR _level$[ebp]
  00448	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  0044b	50		 push	 eax
  0044c	e8 00 00 00 00	 call	 _deflateInit2_@32
  00451	8b d8		 mov	 ebx, eax

; 1222 : 
; 1223 :           if (err==Z_OK)

  00453	85 db		 test	 ebx, ebx
  00455	75 07		 jne	 SHORT $LN38@zipOpenNew

; 1224 :               zi->ci.stream_initialised = Z_DEFLATED;

  00457	c7 46 78 08 00
	00 00		 mov	 DWORD PTR [esi+120], 8
$LN38@zipOpenNew:

; 1225 :         }
; 1226 :         else if(zi->ci.method == Z_BZIP2ED)
; 1227 :         {
; 1228 : #ifdef HAVE_BZIP2
; 1229 :             // Init BZip stuff here
; 1230 :           zi->ci.bstream.bzalloc = 0;
; 1231 :           zi->ci.bstream.bzfree = 0;
; 1232 :           zi->ci.bstream.opaque = (voidpf)0;
; 1233 : 
; 1234 :           err = BZ2_bzCompressInit(&zi->ci.bstream, level, 0,35);
; 1235 :           if(err == BZ_OK)
; 1236 :             zi->ci.stream_initialised = Z_BZIP2ED;
; 1237 : #endif
; 1238 :         }
; 1239 : 
; 1240 :     }
; 1241 : 
; 1242 : #    ifndef NOCRYPT
; 1243 :     zi->ci.crypt_header_size = 0;

  0045e	c7 86 e0 00 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+65760], 0

; 1244 :     if ((err==Z_OK) && (password != NULL))

  00468	85 db		 test	 ebx, ebx
  0046a	75 68		 jne	 SHORT $LN42@zipOpenNew
  0046c	8b 7d 40	 mov	 edi, DWORD PTR _password$[ebp]
  0046f	85 ff		 test	 edi, edi
  00471	74 5a		 je	 SHORT $LN57@zipOpenNew

; 1245 :     {
; 1246 :         unsigned char bufHead[RAND_HEAD_LEN];
; 1247 :         unsigned int sizeHead;
; 1248 :         zi->ci.encrypt = 1;

  00473	c7 86 ac 00 01
	00 01 00 00 00	 mov	 DWORD PTR [esi+65708], 1

; 1249 :         zi->ci.pcrc_32_tab = get_crc_table();

  0047d	e8 00 00 00 00	 call	 _get_crc_table@0

; 1250 :         /*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
; 1251 : 
; 1252 :         sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi->ci.keys,zi->ci.pcrc_32_tab,crcForCrypting);

  00482	ff 75 44	 push	 DWORD PTR _crcForCrypting$[ebp]
  00485	89 86 dc 00 01
	00		 mov	 DWORD PTR [esi+65756], eax
  0048b	8d 54 24 18	 lea	 edx, DWORD PTR _bufHead$1[esp+36]
  0048f	50		 push	 eax
  00490	8d 86 d0 00 01
	00		 lea	 eax, DWORD PTR [esi+65744]
  00496	50		 push	 eax
  00497	51		 push	 ecx
  00498	8b cf		 mov	 ecx, edi
  0049a	e8 00 00 00 00	 call	 _crypthead

; 1253 :         zi->ci.crypt_header_size = sizeHead;
; 1254 : 
; 1255 :         if (ZWRITE64(zi->z_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)

  0049f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  004a2	8b f8		 mov	 edi, eax
  004a4	57		 push	 edi
  004a5	8d 44 24 28	 lea	 eax, DWORD PTR _bufHead$1[esp+52]
  004a9	89 be e0 00 01
	00		 mov	 DWORD PTR [esi+65760], edi
  004af	50		 push	 eax
  004b0	ff 76 2c	 push	 DWORD PTR [esi+44]
  004b3	ff 76 1c	 push	 DWORD PTR [esi+28]
  004b6	ff d1		 call	 ecx
  004b8	83 c4 20	 add	 esp, 32			; 00000020H
  004bb	3b c7		 cmp	 eax, edi
  004bd	74 0e		 je	 SHORT $LN57@zipOpenNew

; 1256 :                 err = ZIP_ERRNO;

  004bf	83 cb ff	 or	 ebx, -1

; 1262 :     return err;

  004c2	8b c3		 mov	 eax, ebx

; 1263 : }

  004c4	5f		 pop	 edi
  004c5	5e		 pop	 esi
  004c6	5b		 pop	 ebx
  004c7	8b e5		 mov	 esp, ebp
  004c9	5d		 pop	 ebp
  004ca	c2 4c 00	 ret	 76			; 0000004cH
$LN57@zipOpenNew:

; 1257 :     }
; 1258 : #    endif
; 1259 : 
; 1260 :     if (err==Z_OK)
; 1261 :         zi->in_opened_file_inzip = 1;

  004cd	c7 46 38 01 00
	00 00		 mov	 DWORD PTR [esi+56], 1
$LN42@zipOpenNew:

; 1262 :     return err;

  004d4	8b c3		 mov	 eax, ebx
$LN1@zipOpenNew:

; 1263 : }

  004d6	5f		 pop	 edi
  004d7	5e		 pop	 esi
  004d8	5b		 pop	 ebx
  004d9	8b e5		 mov	 esp, ebp
  004db	5d		 pop	 ebp
  004dc	c2 4c 00	 ret	 76			; 0000004cH
_zipOpenNewFileInZip4_64@76 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpenNewFileInZip3@64
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_windowBits$ = 52					; size = 4
_memLevel$ = 56						; size = 4
_strategy$ = 60						; size = 4
_password$ = 64						; size = 4
_crcForCrypting$ = 68					; size = 4
_zipOpenNewFileInZip3@64 PROC				; COMDAT

; 1287 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1288 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	ff 75 44	 push	 DWORD PTR _crcForCrypting$[ebp]
  0000c	ff 75 40	 push	 DWORD PTR _password$[ebp]
  0000f	ff 75 3c	 push	 DWORD PTR _strategy$[ebp]
  00012	ff 75 38	 push	 DWORD PTR _memLevel$[ebp]
  00015	ff 75 34	 push	 DWORD PTR _windowBits$[ebp]
  00018	ff 75 30	 push	 DWORD PTR _raw$[ebp]
  0001b	ff 75 2c	 push	 DWORD PTR _level$[ebp]
  0001e	ff 75 28	 push	 DWORD PTR _method$[ebp]
  00021	ff 75 24	 push	 DWORD PTR _comment$[ebp]
  00024	ff 75 20	 push	 DWORD PTR _size_extrafield_global$[ebp]
  00027	ff 75 1c	 push	 DWORD PTR _extrafield_global$[ebp]
  0002a	ff 75 18	 push	 DWORD PTR _size_extrafield_local$[ebp]
  0002d	ff 75 14	 push	 DWORD PTR _extrafield_local$[ebp]
  00030	ff 75 10	 push	 DWORD PTR _zipfi$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR _filename$[ebp]
  00036	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00039	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1289 :                                  extrafield_local, size_extrafield_local,
; 1290 :                                  extrafield_global, size_extrafield_global,
; 1291 :                                  comment, method, level, raw,
; 1292 :                                  windowBits, memLevel, strategy,
; 1293 :                                  password, crcForCrypting, VERSIONMADEBY, 0, 0);
; 1294 : }

  0003e	5d		 pop	 ebp
  0003f	c2 40 00	 ret	 64			; 00000040H
_zipOpenNewFileInZip3@64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpenNewFileInZip3_64@68
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_windowBits$ = 52					; size = 4
_memLevel$ = 56						; size = 4
_strategy$ = 60						; size = 4
_password$ = 64						; size = 4
_crcForCrypting$ = 68					; size = 4
_zip64$ = 72						; size = 4
_zipOpenNewFileInZip3_64@68 PROC			; COMDAT

; 1302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1303 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,

  00003	ff 75 48	 push	 DWORD PTR _zip64$[ebp]
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	ff 75 44	 push	 DWORD PTR _crcForCrypting$[ebp]
  0000d	ff 75 40	 push	 DWORD PTR _password$[ebp]
  00010	ff 75 3c	 push	 DWORD PTR _strategy$[ebp]
  00013	ff 75 38	 push	 DWORD PTR _memLevel$[ebp]
  00016	ff 75 34	 push	 DWORD PTR _windowBits$[ebp]
  00019	ff 75 30	 push	 DWORD PTR _raw$[ebp]
  0001c	ff 75 2c	 push	 DWORD PTR _level$[ebp]
  0001f	ff 75 28	 push	 DWORD PTR _method$[ebp]
  00022	ff 75 24	 push	 DWORD PTR _comment$[ebp]
  00025	ff 75 20	 push	 DWORD PTR _size_extrafield_global$[ebp]
  00028	ff 75 1c	 push	 DWORD PTR _extrafield_global$[ebp]
  0002b	ff 75 18	 push	 DWORD PTR _size_extrafield_local$[ebp]
  0002e	ff 75 14	 push	 DWORD PTR _extrafield_local$[ebp]
  00031	ff 75 10	 push	 DWORD PTR _zipfi$[ebp]
  00034	ff 75 0c	 push	 DWORD PTR _filename$[ebp]
  00037	ff 75 08	 push	 DWORD PTR _file$[ebp]
  0003a	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1304 :                                  extrafield_local, size_extrafield_local,
; 1305 :                                  extrafield_global, size_extrafield_global,
; 1306 :                                  comment, method, level, raw,
; 1307 :                                  windowBits, memLevel, strategy,
; 1308 :                                  password, crcForCrypting, VERSIONMADEBY, 0, zip64);
; 1309 : }

  0003f	5d		 pop	 ebp
  00040	c2 44 00	 ret	 68			; 00000044H
_zipOpenNewFileInZip3_64@68 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpenNewFileInZip2@44
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_zipOpenNewFileInZip2@44 PROC				; COMDAT

; 1315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1316 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 08		 push	 8
  00011	6a f1		 push	 -15			; fffffff1H
  00013	ff 75 30	 push	 DWORD PTR _raw$[ebp]
  00016	ff 75 2c	 push	 DWORD PTR _level$[ebp]
  00019	ff 75 28	 push	 DWORD PTR _method$[ebp]
  0001c	ff 75 24	 push	 DWORD PTR _comment$[ebp]
  0001f	ff 75 20	 push	 DWORD PTR _size_extrafield_global$[ebp]
  00022	ff 75 1c	 push	 DWORD PTR _extrafield_global$[ebp]
  00025	ff 75 18	 push	 DWORD PTR _size_extrafield_local$[ebp]
  00028	ff 75 14	 push	 DWORD PTR _extrafield_local$[ebp]
  0002b	ff 75 10	 push	 DWORD PTR _zipfi$[ebp]
  0002e	ff 75 0c	 push	 DWORD PTR _filename$[ebp]
  00031	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00034	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1317 :                                  extrafield_local, size_extrafield_local,
; 1318 :                                  extrafield_global, size_extrafield_global,
; 1319 :                                  comment, method, level, raw,
; 1320 :                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
; 1321 :                                  NULL, 0, VERSIONMADEBY, 0, 0);
; 1322 : }

  00039	5d		 pop	 ebp
  0003a	c2 2c 00	 ret	 44			; 0000002cH
_zipOpenNewFileInZip2@44 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpenNewFileInZip2_64@48
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_raw$ = 48						; size = 4
_zip64$ = 52						; size = 4
_zipOpenNewFileInZip2_64@48 PROC			; COMDAT

; 1328 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1329 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,

  00003	ff 75 34	 push	 DWORD PTR _zip64$[ebp]
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	6a 08		 push	 8
  00012	6a f1		 push	 -15			; fffffff1H
  00014	ff 75 30	 push	 DWORD PTR _raw$[ebp]
  00017	ff 75 2c	 push	 DWORD PTR _level$[ebp]
  0001a	ff 75 28	 push	 DWORD PTR _method$[ebp]
  0001d	ff 75 24	 push	 DWORD PTR _comment$[ebp]
  00020	ff 75 20	 push	 DWORD PTR _size_extrafield_global$[ebp]
  00023	ff 75 1c	 push	 DWORD PTR _extrafield_global$[ebp]
  00026	ff 75 18	 push	 DWORD PTR _size_extrafield_local$[ebp]
  00029	ff 75 14	 push	 DWORD PTR _extrafield_local$[ebp]
  0002c	ff 75 10	 push	 DWORD PTR _zipfi$[ebp]
  0002f	ff 75 0c	 push	 DWORD PTR _filename$[ebp]
  00032	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00035	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1330 :                                  extrafield_local, size_extrafield_local,
; 1331 :                                  extrafield_global, size_extrafield_global,
; 1332 :                                  comment, method, level, raw,
; 1333 :                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
; 1334 :                                  NULL, 0, VERSIONMADEBY, 0, zip64);
; 1335 : }

  0003a	5d		 pop	 ebp
  0003b	c2 30 00	 ret	 48			; 00000030H
_zipOpenNewFileInZip2_64@48 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpenNewFileInZip64@44
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_zip64$ = 48						; size = 4
_zipOpenNewFileInZip64@44 PROC				; COMDAT

; 1341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1342 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,

  00003	ff 75 30	 push	 DWORD PTR _zip64$[ebp]
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	6a 08		 push	 8
  00012	6a f1		 push	 -15			; fffffff1H
  00014	6a 00		 push	 0
  00016	ff 75 2c	 push	 DWORD PTR _level$[ebp]
  00019	ff 75 28	 push	 DWORD PTR _method$[ebp]
  0001c	ff 75 24	 push	 DWORD PTR _comment$[ebp]
  0001f	ff 75 20	 push	 DWORD PTR _size_extrafield_global$[ebp]
  00022	ff 75 1c	 push	 DWORD PTR _extrafield_global$[ebp]
  00025	ff 75 18	 push	 DWORD PTR _size_extrafield_local$[ebp]
  00028	ff 75 14	 push	 DWORD PTR _extrafield_local$[ebp]
  0002b	ff 75 10	 push	 DWORD PTR _zipfi$[ebp]
  0002e	ff 75 0c	 push	 DWORD PTR _filename$[ebp]
  00031	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00034	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1343 :                                  extrafield_local, size_extrafield_local,
; 1344 :                                  extrafield_global, size_extrafield_global,
; 1345 :                                  comment, method, level, 0,
; 1346 :                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
; 1347 :                                  NULL, 0, VERSIONMADEBY, 0, zip64);
; 1348 : }

  00039	5d		 pop	 ebp
  0003a	c2 2c 00	 ret	 44			; 0000002cH
_zipOpenNewFileInZip64@44 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipOpenNewFileInZip@40
_TEXT	SEGMENT
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_zipfi$ = 16						; size = 4
_extrafield_local$ = 20					; size = 4
_size_extrafield_local$ = 24				; size = 4
_extrafield_global$ = 28				; size = 4
_size_extrafield_global$ = 32				; size = 4
_comment$ = 36						; size = 4
_method$ = 40						; size = 4
_level$ = 44						; size = 4
_zipOpenNewFileInZip@40 PROC				; COMDAT

; 1354 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1355 :     return zipOpenNewFileInZip4_64 (file, filename, zipfi,

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 08		 push	 8
  00011	6a f1		 push	 -15			; fffffff1H
  00013	6a 00		 push	 0
  00015	ff 75 2c	 push	 DWORD PTR _level$[ebp]
  00018	ff 75 28	 push	 DWORD PTR _method$[ebp]
  0001b	ff 75 24	 push	 DWORD PTR _comment$[ebp]
  0001e	ff 75 20	 push	 DWORD PTR _size_extrafield_global$[ebp]
  00021	ff 75 1c	 push	 DWORD PTR _extrafield_global$[ebp]
  00024	ff 75 18	 push	 DWORD PTR _size_extrafield_local$[ebp]
  00027	ff 75 14	 push	 DWORD PTR _extrafield_local$[ebp]
  0002a	ff 75 10	 push	 DWORD PTR _zipfi$[ebp]
  0002d	ff 75 0c	 push	 DWORD PTR _filename$[ebp]
  00030	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00033	e8 00 00 00 00	 call	 _zipOpenNewFileInZip4_64@76

; 1356 :                                  extrafield_local, size_extrafield_local,
; 1357 :                                  extrafield_global, size_extrafield_global,
; 1358 :                                  comment, method, level, 0,
; 1359 :                                  -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
; 1360 :                                  NULL, 0, VERSIONMADEBY, 0, 0);
; 1361 : }

  00038	5d		 pop	 ebp
  00039	c2 28 00	 ret	 40			; 00000028H
_zipOpenNewFileInZip@40 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zip64FlushWriteBuffer
_TEXT	SEGMENT
tv237 = -4						; size = 4
_zip64FlushWriteBuffer PROC				; COMDAT
; _zi$ = ecx

; 1364 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 1365 :     int err=ZIP_OK;

  00008	33 db		 xor	 ebx, ebx
  0000a	57		 push	 edi

; 1366 : 
; 1367 :     if (zi->ci.encrypt != 0)

  0000b	39 9e ac 00 01
	00		 cmp	 DWORD PTR [esi+65708], ebx
  00011	74 53		 je	 SHORT $LN3@zip64Flush

; 1368 :     {
; 1369 : #ifndef NOCRYPT
; 1370 :         uInt i;
; 1371 :         int t;
; 1372 :         for (i=0;i<zi->ci.pos_in_buffered_data;i++)

  00013	39 5e 7c	 cmp	 DWORD PTR [esi+124], ebx
  00016	76 4e		 jbe	 SHORT $LN3@zip64Flush
  00018	b9 5c ff ff ff	 mov	 ecx, -164		; ffffff5cH
  0001d	8d 86 d0 00 01
	00		 lea	 eax, DWORD PTR [esi+65744]
  00023	2b ce		 sub	 ecx, esi
  00025	8d be a4 00 00
	00		 lea	 edi, DWORD PTR [esi+164]
  0002b	89 4d fc	 mov	 DWORD PTR tv237[ebp], ecx
  0002e	66 90		 npad	 2
$LL4@zip64Flush:

; 1373 :             zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i],t);

  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _decrypt_byte
  00037	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  0003a	8b d8		 mov	 ebx, eax
  0003c	8b 96 dc 00 01
	00		 mov	 edx, DWORD PTR [esi+65756]
  00042	51		 push	 ecx
  00043	8d 8e d0 00 01
	00		 lea	 ecx, DWORD PTR [esi+65744]
  00049	e8 00 00 00 00	 call	 _update_keys
  0004e	30 1f		 xor	 BYTE PTR [edi], bl
  00050	83 c4 04	 add	 esp, 4
  00053	8b 45 fc	 mov	 eax, DWORD PTR tv237[ebp]
  00056	47		 inc	 edi
  00057	03 c7		 add	 eax, edi
  00059	3b 46 7c	 cmp	 eax, DWORD PTR [esi+124]
  0005c	8d 86 d0 00 01
	00		 lea	 eax, DWORD PTR [esi+65744]
  00062	72 cc		 jb	 SHORT $LL4@zip64Flush
  00064	33 db		 xor	 ebx, ebx
$LN3@zip64Flush:

; 1374 : #endif
; 1375 :     }
; 1376 : 
; 1377 :     if (ZWRITE64(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data) != zi->ci.pos_in_buffered_data)

  00066	8b 7e 7c	 mov	 edi, DWORD PTR [esi+124]
  00069	8d 86 a4 00 00
	00		 lea	 eax, DWORD PTR [esi+164]
  0006f	57		 push	 edi
  00070	50		 push	 eax
  00071	ff 76 2c	 push	 DWORD PTR [esi+44]
  00074	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00077	ff 76 1c	 push	 DWORD PTR [esi+28]
  0007a	ff d0		 call	 eax
  0007c	83 c4 10	 add	 esp, 16			; 00000010H

; 1378 :       err = ZIP_ERRNO;
; 1379 : 
; 1380 :     zi->ci.totalCompressedData += zi->ci.pos_in_buffered_data;
; 1381 : 
; 1382 : #ifdef HAVE_BZIP2
; 1383 :     if(zi->ci.method == Z_BZIP2ED)
; 1384 :     {
; 1385 :       zi->ci.totalUncompressedData += zi->ci.bstream.total_in_lo32;
; 1386 :       zi->ci.bstream.total_in_lo32 = 0;
; 1387 :       zi->ci.bstream.total_in_hi32 = 0;
; 1388 :     }
; 1389 :     else
; 1390 : #endif
; 1391 :     {
; 1392 :       zi->ci.totalUncompressedData += zi->ci.stream.total_in;
; 1393 :       zi->ci.stream.total_in = 0;
; 1394 :     }
; 1395 : 
; 1396 : 
; 1397 :     zi->ci.pos_in_buffered_data = 0;

  0007f	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
  00086	83 c9 ff	 or	 ecx, -1
  00089	3b c7		 cmp	 eax, edi
  0008b	0f 45 d9	 cmovne	 ebx, ecx
  0008e	01 be c0 00 01
	00		 add	 DWORD PTR [esi+65728], edi
  00094	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]

; 1398 : 
; 1399 :     return err;

  00097	8b c3		 mov	 eax, ebx
  00099	83 96 c4 00 01
	00 00		 adc	 DWORD PTR [esi+65732], 0
  000a0	01 8e c8 00 01
	00		 add	 DWORD PTR [esi+65736], ecx
  000a6	5f		 pop	 edi
  000a7	83 96 cc 00 01
	00 00		 adc	 DWORD PTR [esi+65740], 0
  000ae	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 1400 : }

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
_zip64FlushWriteBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipWriteInFileInZip@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_zipWriteInFileInZip@12 PROC				; COMDAT

; 1403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1404 :     zip64_internal* zi;
; 1405 :     int err=ZIP_OK;
; 1406 : 
; 1407 :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 0a		 jne	 SHORT $LN7@zipWriteIn
$LN29@zipWriteIn:

; 1408 :         return ZIP_PARAMERROR;

  0000b	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00010	5e		 pop	 esi

; 1507 : }

  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
$LN7@zipWriteIn:

; 1409 :     zi = (zip64_internal*)file;
; 1410 : 
; 1411 :     if (zi->in_opened_file_inzip == 0)

  00015	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00019	74 f0		 je	 SHORT $LN29@zipWriteIn

; 1412 :         return ZIP_PARAMERROR;
; 1413 : 
; 1414 :     zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);

  0001b	53		 push	 ebx
  0001c	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  0001f	57		 push	 edi
  00020	8b 7d 0c	 mov	 edi, DWORD PTR _buf$[ebp]
  00023	53		 push	 ebx
  00024	57		 push	 edi
  00025	ff b6 a8 00 01
	00		 push	 DWORD PTR [esi+65704]
  0002b	e8 00 00 00 00	 call	 _crc32@12

; 1415 : 
; 1416 : #ifdef HAVE_BZIP2
; 1417 :     if(zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))
; 1418 :     {
; 1419 :       zi->ci.bstream.next_in = (void*)buf;
; 1420 :       zi->ci.bstream.avail_in = len;
; 1421 :       err = BZ_RUN_OK;
; 1422 : 
; 1423 :       while ((err==BZ_RUN_OK) && (zi->ci.bstream.avail_in>0))
; 1424 :       {
; 1425 :         if (zi->ci.bstream.avail_out == 0)
; 1426 :         {
; 1427 :           if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
; 1428 :             err = ZIP_ERRNO;
; 1429 :           zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
; 1430 :           zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
; 1431 :         }
; 1432 : 
; 1433 : 
; 1434 :         if(err != BZ_RUN_OK)
; 1435 :           break;
; 1436 : 
; 1437 :         if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
; 1438 :         {
; 1439 :           uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;
; 1440 : //          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
; 1441 :           err=BZ2_bzCompress(&zi->ci.bstream,  BZ_RUN);
; 1442 : 
; 1443 :           zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;
; 1444 :         }
; 1445 :       }
; 1446 : 
; 1447 :       if(err == BZ_RUN_OK)
; 1448 :         err = ZIP_OK;
; 1449 :     }
; 1450 :     else
; 1451 : #endif
; 1452 :     {
; 1453 :       zi->ci.stream.next_in = (Bytef*)buf;

  00030	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]

; 1454 :       zi->ci.stream.avail_in = len;

  00033	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  00036	89 39		 mov	 DWORD PTR [ecx], edi
  00038	83 cf ff	 or	 edi, -1
  0003b	89 86 a8 00 01
	00		 mov	 DWORD PTR [esi+65704], eax
  00041	33 db		 xor	 ebx, ebx
$LL2@zipWriteIn:

; 1455 : 
; 1456 :       while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))

  00043	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  00047	0f 86 9d 00 00
	00		 jbe	 $LN28@zipWriteIn

; 1457 :       {
; 1458 :           if (zi->ci.stream.avail_out == 0)

  0004d	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
  00051	75 20		 jne	 SHORT $LN9@zipWriteIn

; 1459 :           {
; 1460 :               if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)

  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 _zip64FlushWriteBuffer
  0005a	83 f8 ff	 cmp	 eax, -1

; 1461 :                   err = ZIP_ERRNO;
; 1462 :               zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;

  0005d	c7 46 50 00 00
	01 00		 mov	 DWORD PTR [esi+80], 65536 ; 00010000H

; 1463 :               zi->ci.stream.next_out = zi->ci.buffered_data;

  00064	8d 86 a4 00 00
	00		 lea	 eax, DWORD PTR [esi+164]
  0006a	0f 44 df	 cmove	 ebx, edi
  0006d	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00070	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
$LN9@zipWriteIn:

; 1464 :           }
; 1465 : 
; 1466 : 
; 1467 :           if(err != ZIP_OK)

  00073	85 db		 test	 ebx, ebx
  00075	75 73		 jne	 SHORT $LN28@zipWriteIn

; 1468 :               break;
; 1469 : 
; 1470 :           if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))

  00077	83 be 9c 00 00
	00 08		 cmp	 DWORD PTR [esi+156], 8
  0007e	75 28		 jne	 SHORT $LN12@zipWriteIn
  00080	39 9e a0 00 00
	00		 cmp	 DWORD PTR [esi+160], ebx
  00086	75 20		 jne	 SHORT $LN12@zipWriteIn

; 1471 :           {
; 1472 :               uLong uTotalOutBefore = zi->ci.stream.total_out;

  00088	8b 7e 54	 mov	 edi, DWORD PTR [esi+84]

; 1473 :               err=deflate(&zi->ci.stream,  Z_NO_FLUSH);

  0008b	53		 push	 ebx
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 _deflate@8

; 1474 :               if(uTotalOutBefore > zi->ci.stream.total_out)
; 1475 :               {
; 1476 :                 int bBreak = 0;
; 1477 :                 bBreak++;
; 1478 :               }
; 1479 : 
; 1480 :               zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;

  00092	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00095	8b d8		 mov	 ebx, eax
  00097	2b cf		 sub	 ecx, edi
  00099	01 4e 7c	 add	 DWORD PTR [esi+124], ecx
  0009c	85 db		 test	 ebx, ebx
  0009e	75 4a		 jne	 SHORT $LN28@zipWriteIn

; 1455 : 
; 1456 :       while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))

  000a0	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  000a3	83 cf ff	 or	 edi, -1
  000a6	eb 9b		 jmp	 SHORT $LL2@zipWriteIn
$LN12@zipWriteIn:

; 1481 :           }
; 1482 :           else
; 1483 :           {
; 1484 :               uInt copy_this,i;
; 1485 :               if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)

  000a8	8b 7e 50	 mov	 edi, DWORD PTR [esi+80]
  000ab	39 7e 44	 cmp	 DWORD PTR [esi+68], edi
  000ae	0f 42 7e 44	 cmovb	 edi, DWORD PTR [esi+68]

; 1486 :                   copy_this = zi->ci.stream.avail_in;
; 1487 :               else
; 1488 :                   copy_this = zi->ci.stream.avail_out;
; 1489 : 
; 1490 :               for (i = 0; i < copy_this; i++)

  000b2	33 d2		 xor	 edx, edx
  000b4	85 ff		 test	 edi, edi
  000b6	74 16		 je	 SHORT $LN5@zipWriteIn
$LL22@zipWriteIn:

; 1491 :                   *(((char*)zi->ci.stream.next_out)+i) =

  000b8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ba	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  000bd	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  000c0	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000c3	42		 inc	 edx
  000c4	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  000c7	3b d7		 cmp	 edx, edi
  000c9	72 ed		 jb	 SHORT $LL22@zipWriteIn
  000cb	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
$LN5@zipWriteIn:

; 1492 :                       *(((const char*)zi->ci.stream.next_in)+i);
; 1493 :               {
; 1494 :                   zi->ci.stream.avail_in -= copy_this;

  000ce	29 7e 44	 sub	 DWORD PTR [esi+68], edi

; 1495 :                   zi->ci.stream.avail_out-= copy_this;

  000d1	29 7e 50	 sub	 DWORD PTR [esi+80], edi

; 1496 :                   zi->ci.stream.next_in+= copy_this;

  000d4	01 39		 add	 DWORD PTR [ecx], edi

; 1497 :                   zi->ci.stream.next_out+= copy_this;

  000d6	01 7e 4c	 add	 DWORD PTR [esi+76], edi

; 1498 :                   zi->ci.stream.total_in+= copy_this;

  000d9	01 7e 48	 add	 DWORD PTR [esi+72], edi

; 1499 :                   zi->ci.stream.total_out+= copy_this;

  000dc	01 7e 54	 add	 DWORD PTR [esi+84], edi

; 1500 :                   zi->ci.pos_in_buffered_data += copy_this;

  000df	01 7e 7c	 add	 DWORD PTR [esi+124], edi
  000e2	83 cf ff	 or	 edi, -1
  000e5	e9 59 ff ff ff	 jmp	 $LL2@zipWriteIn
$LN28@zipWriteIn:
  000ea	5f		 pop	 edi

; 1501 :               }
; 1502 :           }
; 1503 :       }// while(...)
; 1504 :     }
; 1505 : 
; 1506 :     return err;

  000eb	8b c3		 mov	 eax, ebx
  000ed	5b		 pop	 ebx
  000ee	5e		 pop	 esi

; 1507 : }

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH
_zipWriteInFileInZip@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipCloseFileInZipRaw@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_uncompressed_size$ = 12				; size = 4
_crc32$ = 16						; size = 4
_zipCloseFileInZipRaw@12 PROC				; COMDAT

; 1510 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 1511 :     return zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);

  00006	ff 75 10	 push	 DWORD PTR _crc32$[ebp]
  00009	6a 00		 push	 0
  0000b	ff 75 0c	 push	 DWORD PTR _uncompressed_size$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00011	e8 00 00 00 00	 call	 _zipCloseFileInZipRaw64@16

; 1512 : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
_zipCloseFileInZipRaw@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipCloseFileInZipRaw64@16
_TEXT	SEGMENT
_uncompressed_size$2$ = -28				; size = 4
_uncompressed_size$1$ = -24				; size = 4
_cur_pos_inzip$2$ = -20					; size = 4
_p$1$ = -20						; size = 4
_compressed_size$2$ = -16				; size = 4
_compressed_size$1$ = -12				; size = 4
_crc32$1$ = -8						; size = 4
_cur_pos_inzip$1$ = -4					; size = 4
tv640 = -4						; size = 4
_file$ = 8						; size = 4
_uncompressed_size$ = 12				; size = 8
_crc32$ = 20						; size = 4
_zipCloseFileInZipRaw64@16 PROC				; COMDAT

; 1515 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1516 :     zip64_internal* zi;
; 1517 :     ZPOS64_T compressed_size;
; 1518 :     uLong invalidValue = 0xffffffff;
; 1519 :     short datasize = 0;
; 1520 :     int err=ZIP_OK;
; 1521 : 
; 1522 :     if (file == NULL)

  0000b	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000e	33 db		 xor	 ebx, ebx
  00010	57		 push	 edi
  00011	85 f6		 test	 esi, esi
  00013	75 0e		 jne	 SHORT $LN4@zipCloseFi
$LN82@zipCloseFi:

; 1523 :         return ZIP_PARAMERROR;

  00015	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 1748 : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
$LN4@zipCloseFi:

; 1524 :     zi = (zip64_internal*)file;
; 1525 : 
; 1526 :     if (zi->in_opened_file_inzip == 0)

  00023	39 5e 38	 cmp	 DWORD PTR [esi+56], ebx
  00026	74 ed		 je	 SHORT $LN82@zipCloseFi

; 1527 :         return ZIP_PARAMERROR;
; 1528 :     zi->ci.stream.avail_in = 0;
; 1529 : 
; 1530 :     if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))

  00028	83 be 9c 00 00
	00 08		 cmp	 DWORD PTR [esi+156], 8
  0002f	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  00032	75 4d		 jne	 SHORT $LN11@zipCloseFi
  00034	39 9e a0 00 00
	00		 cmp	 DWORD PTR [esi+160], ebx
  0003a	75 45		 jne	 SHORT $LN11@zipCloseFi
  0003c	0f 1f 40 00	 npad	 4
$LL70@zipCloseFi:

; 1531 :                 {
; 1532 :                         while (err==ZIP_OK)
; 1533 :                         {
; 1534 :                                 uLong uTotalOutBefore;
; 1535 :                                 if (zi->ci.stream.avail_out == 0)

  00040	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
  00044	8d 5e 40	 lea	 ebx, DWORD PTR [esi+64]
  00047	75 17		 jne	 SHORT $LN8@zipCloseFi

; 1536 :                                 {
; 1537 :                                         if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)

  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 _zip64FlushWriteBuffer

; 1538 :                                                 err = ZIP_ERRNO;
; 1539 :                                         zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
; 1540 :                                         zi->ci.stream.next_out = zi->ci.buffered_data;

  00050	8d 86 a4 00 00
	00		 lea	 eax, DWORD PTR [esi+164]
  00056	c7 46 50 00 00
	01 00		 mov	 DWORD PTR [esi+80], 65536 ; 00010000H
  0005d	89 46 4c	 mov	 DWORD PTR [esi+76], eax
$LN8@zipCloseFi:

; 1541 :                                 }
; 1542 :                                 uTotalOutBefore = zi->ci.stream.total_out;

  00060	8b 7e 54	 mov	 edi, DWORD PTR [esi+84]

; 1543 :                                 err=deflate(&zi->ci.stream,  Z_FINISH);

  00063	6a 04		 push	 4
  00065	53		 push	 ebx
  00066	e8 00 00 00 00	 call	 _deflate@8
  0006b	8b d8		 mov	 ebx, eax

; 1544 :                                 zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;

  0006d	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00070	2b c7		 sub	 eax, edi
  00072	01 46 7c	 add	 DWORD PTR [esi+124], eax
  00075	85 db		 test	 ebx, ebx
  00077	74 c7		 je	 SHORT $LL70@zipCloseFi

; 1545 :                         }
; 1546 :                 }
; 1547 :     else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
; 1548 :     {
; 1549 : #ifdef HAVE_BZIP2
; 1550 :       err = BZ_FINISH_OK;
; 1551 :       while (err==BZ_FINISH_OK)
; 1552 :       {
; 1553 :         uLong uTotalOutBefore;
; 1554 :         if (zi->ci.bstream.avail_out == 0)
; 1555 :         {
; 1556 :           if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
; 1557 :             err = ZIP_ERRNO;
; 1558 :           zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
; 1559 :           zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
; 1560 :         }
; 1561 :         uTotalOutBefore = zi->ci.bstream.total_out_lo32;
; 1562 :         err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);
; 1563 :         if(err == BZ_STREAM_END)
; 1564 :           err = Z_STREAM_END;
; 1565 : 
; 1566 :         zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);
; 1567 :       }
; 1568 : 
; 1569 :       if(err == BZ_FINISH_OK)
; 1570 :         err = ZIP_OK;
; 1571 : #endif
; 1572 :     }
; 1573 : 
; 1574 :     if (err==Z_STREAM_END)

  00079	33 c0		 xor	 eax, eax
  0007b	83 fb 01	 cmp	 ebx, 1
  0007e	0f 44 d8	 cmove	 ebx, eax
$LN11@zipCloseFi:

; 1575 :         err=ZIP_OK; /* this is normal */
; 1576 : 
; 1577 :     if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))

  00081	83 cf ff	 or	 edi, -1
  00084	83 7e 7c 00	 cmp	 DWORD PTR [esi+124], 0
  00088	76 10		 jbe	 SHORT $LN13@zipCloseFi
  0008a	85 db		 test	 ebx, ebx
  0008c	75 0c		 jne	 SHORT $LN13@zipCloseFi

; 1578 :                 {
; 1579 :         if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)

  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 _zip64FlushWriteBuffer
  00095	3b c7		 cmp	 eax, edi
  00097	0f 44 df	 cmove	 ebx, edi
$LN13@zipCloseFi:

; 1580 :             err = ZIP_ERRNO;
; 1581 :                 }
; 1582 : 
; 1583 :     if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))

  0009a	83 be 9c 00 00
	00 08		 cmp	 DWORD PTR [esi+156], 8
  000a1	75 1e		 jne	 SHORT $LN14@zipCloseFi
  000a3	83 be a0 00 00
	00 00		 cmp	 DWORD PTR [esi+160], 0
  000aa	75 36		 jne	 SHORT $LN69@zipCloseFi

; 1584 :     {
; 1585 :         int tmp_err = deflateEnd(&zi->ci.stream);

  000ac	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _deflateEnd@4

; 1586 :         if (err == ZIP_OK)

  000b5	85 db		 test	 ebx, ebx

; 1587 :             err = tmp_err;
; 1588 :         zi->ci.stream_initialised = 0;

  000b7	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0
  000be	0f 44 d8	 cmove	 ebx, eax
$LN14@zipCloseFi:

; 1589 :     }
; 1590 : #ifdef HAVE_BZIP2
; 1591 :     else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
; 1592 :     {
; 1593 :       int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);
; 1594 :                         if (err==ZIP_OK)
; 1595 :                                 err = tmperr;
; 1596 :                         zi->ci.stream_initialised = 0;
; 1597 :     }
; 1598 : #endif
; 1599 : 
; 1600 :     if (!zi->ci.raw)

  000c1	83 be a0 00 00
	00 00		 cmp	 DWORD PTR [esi+160], 0
  000c8	75 18		 jne	 SHORT $LN69@zipCloseFi

; 1601 :     {
; 1602 :         crc32 = (uLong)zi->ci.crc32;

  000ca	8b 86 a8 00 01
	00		 mov	 eax, DWORD PTR [esi+65704]

; 1603 :         uncompressed_size = zi->ci.totalUncompressedData;

  000d0	8b 8e c8 00 01
	00		 mov	 ecx, DWORD PTR [esi+65736]
  000d6	89 44 24 20	 mov	 DWORD PTR _crc32$1$[esp+40], eax
  000da	8b 86 cc 00 01
	00		 mov	 eax, DWORD PTR [esi+65740]
  000e0	eb 0d		 jmp	 SHORT $LN78@zipCloseFi
$LN69@zipCloseFi:
  000e2	8b 45 14	 mov	 eax, DWORD PTR _crc32$[ebp]
  000e5	8b 4d 0c	 mov	 ecx, DWORD PTR _uncompressed_size$[ebp]
  000e8	89 44 24 20	 mov	 DWORD PTR _crc32$1$[esp+40], eax
  000ec	8b 45 10	 mov	 eax, DWORD PTR _uncompressed_size$[ebp+4]
$LN78@zipCloseFi:
  000ef	89 44 24 0c	 mov	 DWORD PTR _uncompressed_size$2$[esp+40], eax

; 1604 :     }
; 1605 :     compressed_size = zi->ci.totalCompressedData;
; 1606 : 
; 1607 : #    ifndef NOCRYPT
; 1608 :     compressed_size += zi->ci.crypt_header_size;

  000f3	8b 86 e0 00 01
	00		 mov	 eax, DWORD PTR [esi+65760]
  000f9	99		 cdq
  000fa	8b f8		 mov	 edi, eax
  000fc	89 4c 24 10	 mov	 DWORD PTR _uncompressed_size$1$[esp+40], ecx
  00100	03 be c0 00 01
	00		 add	 edi, DWORD PTR [esi+65728]
  00106	8b c2		 mov	 eax, edx
  00108	89 7c 24 18	 mov	 DWORD PTR _compressed_size$2$[esp+40], edi
  0010c	13 86 c4 00 01
	00		 adc	 eax, DWORD PTR [esi+65732]
  00112	89 44 24 1c	 mov	 DWORD PTR _compressed_size$1$[esp+40], eax

; 1609 : #    endif
; 1610 : 
; 1611 :     // update Current Item crc and sizes,
; 1612 :     if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)

  00116	85 c0		 test	 eax, eax
  00118	77 27		 ja	 SHORT $LN57@zipCloseFi
  0011a	72 05		 jb	 SHORT $LN55@zipCloseFi
  0011c	83 ff ff	 cmp	 edi, -1
  0011f	73 20		 jae	 SHORT $LN57@zipCloseFi
$LN55@zipCloseFi:
  00121	83 7c 24 0c 00	 cmp	 DWORD PTR _uncompressed_size$2$[esp+40], 0
  00126	77 19		 ja	 SHORT $LN57@zipCloseFi
  00128	72 05		 jb	 SHORT $LN56@zipCloseFi
  0012a	83 f9 ff	 cmp	 ecx, -1
  0012d	73 12		 jae	 SHORT $LN57@zipCloseFi
$LN56@zipCloseFi:
  0012f	83 be 84 00 00
	00 00		 cmp	 DWORD PTR [esi+132], 0
  00136	77 09		 ja	 SHORT $LN57@zipCloseFi
  00138	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  0013f	72 2c		 jb	 SHORT $LN17@zipCloseFi
$LN57@zipCloseFi:

; 1613 :     {
; 1614 :       /*version Made by*/
; 1615 :       zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);

  00141	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00147	ba 02 00 00 00	 mov	 edx, 2
  0014c	6a 00		 push	 0
  0014e	6a 2d		 push	 45			; 0000002dH
  00150	83 c1 04	 add	 ecx, 4
  00153	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1616 :       /*version needed*/
; 1617 :       zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)45,2);

  00158	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0015e	6a 00		 push	 0
  00160	6a 2d		 push	 45			; 0000002dH
  00162	83 c1 06	 add	 ecx, 6
  00165	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  0016a	83 c4 10	 add	 esp, 16			; 00000010H
$LN17@zipCloseFi:

; 1618 : 
; 1619 :     }
; 1620 : 
; 1621 :     zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/

  0016d	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00173	ba 04 00 00 00	 mov	 edx, 4
  00178	6a 00		 push	 0
  0017a	ff 74 24 24	 push	 DWORD PTR _crc32$1$[esp+44]
  0017e	83 c1 10	 add	 ecx, 16			; 00000010H
  00181	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1622 : 
; 1623 : 
; 1624 :     if(compressed_size >= 0xffffffff)

  00186	8b 44 24 24	 mov	 eax, DWORD PTR _compressed_size$1$[esp+48]
  0018a	83 c4 08	 add	 esp, 8
  0018d	85 c0		 test	 eax, eax
  0018f	75 09		 jne	 SHORT $LN58@zipCloseFi
  00191	83 ff ff	 cmp	 edi, -1
  00194	73 04		 jae	 SHORT $LN58@zipCloseFi

; 1626 :     else
; 1627 :       zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/

  00196	50		 push	 eax
  00197	57		 push	 edi
  00198	eb 04		 jmp	 SHORT $LN79@zipCloseFi
$LN58@zipCloseFi:

; 1625 :       zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/

  0019a	6a 00		 push	 0
  0019c	6a ff		 push	 -1
$LN79@zipCloseFi:
  0019e	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  001a4	83 c1 14	 add	 ecx, 20			; 00000014H
  001a7	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  001ac	83 c4 08	 add	 esp, 8

; 1628 : 
; 1629 :     /// set internal file attributes field
; 1630 :     if (zi->ci.stream.data_type == Z_ASCII)

  001af	83 7e 6c 01	 cmp	 DWORD PTR [esi+108], 1
  001b3	75 1a		 jne	 SHORT $LN21@zipCloseFi

; 1631 :         zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);

  001b5	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  001bb	ba 02 00 00 00	 mov	 edx, 2
  001c0	6a 00		 push	 0
  001c2	6a 01		 push	 1
  001c4	83 c1 24	 add	 ecx, 36			; 00000024H
  001c7	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  001cc	83 c4 08	 add	 esp, 8
$LN21@zipCloseFi:

; 1632 : 
; 1633 :     if(uncompressed_size >= 0xffffffff)

  001cf	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uncompressed_size$2$[esp+40]
  001d3	85 c9		 test	 ecx, ecx
  001d5	75 0d		 jne	 SHORT $LN59@zipCloseFi
  001d7	8b 44 24 10	 mov	 eax, DWORD PTR _uncompressed_size$1$[esp+40]
  001db	83 f8 ff	 cmp	 eax, -1
  001de	73 04		 jae	 SHORT $LN59@zipCloseFi

; 1635 :     else
; 1636 :       zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/

  001e0	51		 push	 ecx
  001e1	50		 push	 eax
  001e2	eb 04		 jmp	 SHORT $LN80@zipCloseFi
$LN59@zipCloseFi:

; 1634 :       zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/

  001e4	6a 00		 push	 0
  001e6	6a ff		 push	 -1
$LN80@zipCloseFi:
  001e8	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  001ee	ba 04 00 00 00	 mov	 edx, 4
  001f3	83 c1 18	 add	 ecx, 24			; 00000018H
  001f6	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  001fb	83 c4 08	 add	 esp, 8

; 1637 : 
; 1638 :     // Add ZIP64 extra info field for uncompressed size
; 1639 :     if(uncompressed_size >= 0xffffffff)

  001fe	83 7c 24 0c 00	 cmp	 DWORD PTR _uncompressed_size$2$[esp+40], 0
  00203	77 07		 ja	 SHORT $LN60@zipCloseFi
  00205	83 7c 24 10 ff	 cmp	 DWORD PTR _uncompressed_size$1$[esp+40], -1
  0020a	72 07		 jb	 SHORT $LN76@zipCloseFi
$LN60@zipCloseFi:

; 1640 :       datasize += 8;

  0020c	b8 08 00 00 00	 mov	 eax, 8
  00211	eb 02		 jmp	 SHORT $LN24@zipCloseFi
$LN76@zipCloseFi:
  00213	33 c0		 xor	 eax, eax
$LN24@zipCloseFi:

; 1641 : 
; 1642 :     // Add ZIP64 extra info field for compressed size
; 1643 :     if(compressed_size >= 0xffffffff)

  00215	83 7c 24 1c 00	 cmp	 DWORD PTR _compressed_size$1$[esp+40], 0
  0021a	77 05		 ja	 SHORT $LN61@zipCloseFi
  0021c	83 ff ff	 cmp	 edi, -1
  0021f	72 03		 jb	 SHORT $LN25@zipCloseFi
$LN61@zipCloseFi:

; 1644 :       datasize += 8;

  00221	83 c0 08	 add	 eax, 8
$LN25@zipCloseFi:

; 1645 : 
; 1646 :     // Add ZIP64 extra info field for relative offset to local file header of current file
; 1647 :     if(zi->ci.pos_local_header >= 0xffffffff)

  00224	83 be 84 00 00
	00 00		 cmp	 DWORD PTR [esi+132], 0
  0022b	77 09		 ja	 SHORT $LN62@zipCloseFi
  0022d	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  00234	72 03		 jb	 SHORT $LN26@zipCloseFi
$LN62@zipCloseFi:

; 1648 :       datasize += 8;

  00236	83 c0 08	 add	 eax, 8
$LN26@zipCloseFi:

; 1649 : 
; 1650 :     if(datasize > 0)

  00239	66 85 c0	 test	 ax, ax
  0023c	0f 8e 1d 01 00
	00		 jle	 $LN27@zipCloseFi

; 1651 :     {
; 1652 :       char* p = NULL;
; 1653 : 
; 1654 :       if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)

  00242	98		 cwde
  00243	89 44 24 24	 mov	 DWORD PTR tv640[esp+40], eax
  00247	83 c0 04	 add	 eax, 4
  0024a	3b 86 94 00 00
	00		 cmp	 eax, DWORD PTR [esi+148]
  00250	76 0e		 jbe	 SHORT $LN28@zipCloseFi

; 1655 :       {
; 1656 :         // we can not write more data to the buffer that we have room for.
; 1657 :         return ZIP_BADZIPFILE;

  00252	b8 99 ff ff ff	 mov	 eax, -103		; ffffff99H

; 1748 : }

  00257	5f		 pop	 edi
  00258	5e		 pop	 esi
  00259	5b		 pop	 ebx
  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c2 10 00	 ret	 16			; 00000010H
$LN28@zipCloseFi:

; 1658 :       }
; 1659 : 
; 1660 :       p = zi->ci.central_header + zi->ci.size_centralheader;

  00260	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]

; 1661 : 
; 1662 :       // Add Extra Information Header for 'ZIP64 information'
; 1663 :       zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID

  00266	ba 02 00 00 00	 mov	 edx, 2
  0026b	03 86 90 00 00
	00		 add	 eax, DWORD PTR [esi+144]
  00271	6a 00		 push	 0
  00273	6a 01		 push	 1
  00275	8b c8		 mov	 ecx, eax
  00277	89 44 24 1c	 mov	 DWORD PTR _p$1$[esp+48], eax
  0027b	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1664 :       p += 2;

  00280	8b 4c 24 1c	 mov	 ecx, DWORD PTR _p$1$[esp+48]

; 1665 :       zip64local_putValue_inmemory(p, datasize, 2); // DataSize

  00284	8b 44 24 2c	 mov	 eax, DWORD PTR tv640[esp+48]
  00288	03 ca		 add	 ecx, edx
  0028a	99		 cdq
  0028b	52		 push	 edx
  0028c	50		 push	 eax
  0028d	ba 02 00 00 00	 mov	 edx, 2
  00292	89 4c 24 24	 mov	 DWORD PTR _p$1$[esp+56], ecx
  00296	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1666 :       p += 2;

  0029b	8b 44 24 24	 mov	 eax, DWORD PTR _p$1$[esp+56]
  0029f	83 c4 10	 add	 esp, 16			; 00000010H

; 1667 : 
; 1668 :       if(uncompressed_size >= 0xffffffff)

  002a2	8b 4c 24 10	 mov	 ecx, DWORD PTR _uncompressed_size$1$[esp+40]
  002a6	03 c2		 add	 eax, edx
  002a8	8b 54 24 0c	 mov	 edx, DWORD PTR _uncompressed_size$2$[esp+40]
  002ac	89 44 24 14	 mov	 DWORD PTR _p$1$[esp+40], eax
  002b0	85 d2		 test	 edx, edx
  002b2	75 05		 jne	 SHORT $LN63@zipCloseFi
  002b4	83 f9 ff	 cmp	 ecx, -1
  002b7	72 1b		 jb	 SHORT $LN29@zipCloseFi
$LN63@zipCloseFi:

; 1669 :       {
; 1670 :         zip64local_putValue_inmemory(p, uncompressed_size, 8);

  002b9	52		 push	 edx
  002ba	51		 push	 ecx
  002bb	ba 08 00 00 00	 mov	 edx, 8
  002c0	8b c8		 mov	 ecx, eax
  002c2	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1671 :         p += 8;

  002c7	8b 44 24 1c	 mov	 eax, DWORD PTR _p$1$[esp+48]
  002cb	83 c4 08	 add	 esp, 8
  002ce	03 c2		 add	 eax, edx
  002d0	89 44 24 14	 mov	 DWORD PTR _p$1$[esp+40], eax
$LN29@zipCloseFi:

; 1672 :       }
; 1673 : 
; 1674 :       if(compressed_size >= 0xffffffff)

  002d4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _compressed_size$1$[esp+40]
  002d8	85 c9		 test	 ecx, ecx
  002da	75 05		 jne	 SHORT $LN64@zipCloseFi
  002dc	83 ff ff	 cmp	 edi, -1
  002df	72 17		 jb	 SHORT $LN30@zipCloseFi
$LN64@zipCloseFi:

; 1675 :       {
; 1676 :         zip64local_putValue_inmemory(p, compressed_size, 8);

  002e1	51		 push	 ecx
  002e2	57		 push	 edi
  002e3	ba 08 00 00 00	 mov	 edx, 8
  002e8	8b c8		 mov	 ecx, eax
  002ea	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory

; 1677 :         p += 8;

  002ef	8b 44 24 1c	 mov	 eax, DWORD PTR _p$1$[esp+48]
  002f3	83 c4 08	 add	 esp, 8
  002f6	03 c2		 add	 eax, edx
$LN30@zipCloseFi:

; 1678 :       }
; 1679 : 
; 1680 :       if(zi->ci.pos_local_header >= 0xffffffff)

  002f8	8b be 84 00 00
	00		 mov	 edi, DWORD PTR [esi+132]
  002fe	8b 8e 80 00 00
	00		 mov	 ecx, DWORD PTR [esi+128]
  00304	85 ff		 test	 edi, edi
  00306	75 05		 jne	 SHORT $LN65@zipCloseFi
  00308	83 f9 ff	 cmp	 ecx, -1
  0030b	72 11		 jb	 SHORT $LN31@zipCloseFi
$LN65@zipCloseFi:

; 1681 :       {
; 1682 :         zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);

  0030d	57		 push	 edi
  0030e	51		 push	 ecx
  0030f	ba 08 00 00 00	 mov	 edx, 8
  00314	8b c8		 mov	 ecx, eax
  00316	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  0031b	83 c4 08	 add	 esp, 8
$LN31@zipCloseFi:

; 1683 :         p += 8;
; 1684 :       }
; 1685 : 
; 1686 :       // Update how much extra free space we got in the memory buffer
; 1687 :       // and increase the centralheader size so the new ZIP64 fields are included
; 1688 :       // ( 4 below is the size of HeaderID and DataSize field )
; 1689 :       zi->ci.size_centralExtraFree -= datasize + 4;

  0031e	8b 4c 24 24	 mov	 ecx, DWORD PTR tv640[esp+40]
  00322	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00327	2b c1		 sub	 eax, ecx

; 1690 :       zi->ci.size_centralheader += datasize + 4;
; 1691 : 
; 1692 :       // Update the extra info size field
; 1693 :       zi->ci.size_centralExtra += datasize + 4;
; 1694 :       zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);

  00329	ba 02 00 00 00	 mov	 edx, 2
  0032e	01 86 94 00 00
	00		 add	 DWORD PTR [esi+148], eax
  00334	6a 00		 push	 0
  00336	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00339	01 86 90 00 00
	00		 add	 DWORD PTR [esi+144], eax
  0033f	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00342	01 86 8c 00 00
	00		 add	 DWORD PTR [esi+140], eax
  00348	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0034e	ff b6 8c 00 00
	00		 push	 DWORD PTR [esi+140]
  00354	83 c1 1e	 add	 ecx, 30			; 0000001eH
  00357	e8 00 00 00 00	 call	 _zip64local_putValue_inmemory
  0035c	83 c4 08	 add	 esp, 8
$LN27@zipCloseFi:

; 1695 :     }
; 1696 : 
; 1697 :     if (err==ZIP_OK)

  0035f	85 db		 test	 ebx, ebx
  00361	75 19		 jne	 SHORT $LN32@zipCloseFi

; 1698 :         err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);

  00363	ff b6 90 00 00
	00		 push	 DWORD PTR [esi+144]
  00369	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  0036f	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00372	e8 00 00 00 00	 call	 _add_data_in_datablock
  00377	83 c4 04	 add	 esp, 4
  0037a	8b d8		 mov	 ebx, eax
$LN32@zipCloseFi:

; 1699 : 
; 1700 :     free(zi->ci.central_header);

  0037c	ff b6 88 00 00
	00		 push	 DWORD PTR [esi+136]
  00382	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00388	83 c4 04	 add	 esp, 4

; 1701 : 
; 1702 :     if (err==ZIP_OK)

  0038b	85 db		 test	 ebx, ebx
  0038d	0f 85 3a 01 00
	00		 jne	 $LN46@zipCloseFi

; 1703 :     {
; 1704 :         // Update the LocalFileHeader with the new values.
; 1705 : 
; 1706 :         ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);

  00393	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00396	8b ce		 mov	 ecx, esi
  00398	e8 00 00 00 00	 call	 _call_ztell64

; 1707 : 
; 1708 :         if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)

  0039d	8b be 80 00 00
	00		 mov	 edi, DWORD PTR [esi+128]
  003a3	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  003a9	83 c7 0e	 add	 edi, 14			; 0000000eH
  003ac	53		 push	 ebx
  003ad	13 cb		 adc	 ecx, ebx
  003af	89 54 24 28	 mov	 DWORD PTR _cur_pos_inzip$1$[esp+44], edx
  003b3	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  003b6	51		 push	 ecx
  003b7	57		 push	 edi
  003b8	8b ce		 mov	 ecx, esi
  003ba	89 44 24 20	 mov	 DWORD PTR _cur_pos_inzip$2$[esp+52], eax
  003be	e8 00 00 00 00	 call	 _call_zseek64
  003c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c6	85 c0		 test	 eax, eax
  003c8	74 05		 je	 SHORT $LN53@zipCloseFi

; 1709 :             err = ZIP_ERRNO;

  003ca	83 cb ff	 or	 ebx, -1

; 1710 : 
; 1711 :         if (err==ZIP_OK)

  003cd	eb 17		 jmp	 SHORT $LN35@zipCloseFi
$LN53@zipCloseFi:

; 1712 :             err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */

  003cf	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  003d2	8b ce		 mov	 ecx, esi
  003d4	6a 04		 push	 4
  003d6	6a 00		 push	 0
  003d8	ff 74 24 28	 push	 DWORD PTR _crc32$1$[esp+48]
  003dc	e8 00 00 00 00	 call	 _zip64local_putValue
  003e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e4	8b d8		 mov	 ebx, eax
$LN35@zipCloseFi:

; 1713 : 
; 1714 :         if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff )

  003e6	83 7c 24 0c 00	 cmp	 DWORD PTR _uncompressed_size$2$[esp+40], 0
  003eb	77 4b		 ja	 SHORT $LN73@zipCloseFi
  003ed	72 07		 jb	 SHORT $LN66@zipCloseFi
  003ef	83 7c 24 10 ff	 cmp	 DWORD PTR _uncompressed_size$1$[esp+40], -1
  003f4	73 42		 jae	 SHORT $LN73@zipCloseFi
$LN66@zipCloseFi:
  003f6	8b 44 24 1c	 mov	 eax, DWORD PTR _compressed_size$1$[esp+40]
  003fa	8b 7c 24 18	 mov	 edi, DWORD PTR _compressed_size$2$[esp+40]
  003fe	85 c0		 test	 eax, eax
  00400	77 3a		 ja	 SHORT $LN38@zipCloseFi
  00402	72 05		 jb	 SHORT $LN67@zipCloseFi
  00404	83 ff ff	 cmp	 edi, -1
  00407	73 33		 jae	 SHORT $LN38@zipCloseFi
$LN67@zipCloseFi:

; 1730 :         }
; 1731 :         else
; 1732 :         {
; 1733 :           if (err==ZIP_OK) /* compressed size, unknown */

  00409	85 db		 test	 ebx, ebx
  0040b	0f 85 9b 00 00
	00		 jne	 $LN40@zipCloseFi

; 1734 :               err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);

  00411	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00414	8b ce		 mov	 ecx, esi
  00416	6a 04		 push	 4
  00418	50		 push	 eax
  00419	57		 push	 edi
  0041a	e8 00 00 00 00	 call	 _zip64local_putValue
  0041f	8b d8		 mov	 ebx, eax
  00421	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1735 : 
; 1736 :           if (err==ZIP_OK) /* uncompressed size, unknown */

  00424	85 db		 test	 ebx, ebx
  00426	0f 85 80 00 00
	00		 jne	 $LN40@zipCloseFi

; 1737 :               err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);

  0042c	6a 04		 push	 4
  0042e	ff 74 24 10	 push	 DWORD PTR _uncompressed_size$2$[esp+44]
  00432	ff 74 24 18	 push	 DWORD PTR _uncompressed_size$1$[esp+48]
  00436	eb 65		 jmp	 SHORT $LN81@zipCloseFi
$LN73@zipCloseFi:
  00438	8b 7c 24 18	 mov	 edi, DWORD PTR _compressed_size$2$[esp+40]
$LN38@zipCloseFi:

; 1715 :         {
; 1716 :           if(zi->ci.pos_zip64extrainfo > 0)

  0043c	8b 8e bc 00 01
	00		 mov	 ecx, DWORD PTR [esi+65724]
  00442	8b 86 b8 00 01
	00		 mov	 eax, DWORD PTR [esi+65720]
  00448	85 c9		 test	 ecx, ecx
  0044a	75 09		 jne	 SHORT $LN68@zipCloseFi
  0044c	85 c0		 test	 eax, eax
  0044e	75 05		 jne	 SHORT $LN68@zipCloseFi

; 1727 :           }
; 1728 :           else
; 1729 :               err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal

  00450	8d 58 99	 lea	 ebx, DWORD PTR [eax-103]
  00453	eb 57		 jmp	 SHORT $LN40@zipCloseFi
$LN68@zipCloseFi:

; 1717 :           {
; 1718 :             // Update the size in the ZIP64 extended field.
; 1719 :             if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)

  00455	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00458	83 c0 04	 add	 eax, 4
  0045b	6a 00		 push	 0
  0045d	83 d1 00	 adc	 ecx, 0
  00460	51		 push	 ecx
  00461	50		 push	 eax
  00462	8b ce		 mov	 ecx, esi
  00464	e8 00 00 00 00	 call	 _call_zseek64
  00469	83 c4 0c	 add	 esp, 12			; 0000000cH
  0046c	85 c0		 test	 eax, eax
  0046e	74 05		 je	 SHORT $LN41@zipCloseFi

; 1720 :               err = ZIP_ERRNO;

  00470	83 cb ff	 or	 ebx, -1

; 1721 : 
; 1722 :             if (err==ZIP_OK) /* compressed size, unknown */

  00473	eb 37		 jmp	 SHORT $LN40@zipCloseFi
$LN41@zipCloseFi:
  00475	85 db		 test	 ebx, ebx
  00477	75 33		 jne	 SHORT $LN40@zipCloseFi

; 1723 :               err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);

  00479	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0047c	8b ce		 mov	 ecx, esi
  0047e	6a 08		 push	 8
  00480	ff 74 24 10	 push	 DWORD PTR _uncompressed_size$2$[esp+44]
  00484	ff 74 24 18	 push	 DWORD PTR _uncompressed_size$1$[esp+48]
  00488	e8 00 00 00 00	 call	 _zip64local_putValue
  0048d	8b d8		 mov	 ebx, eax
  0048f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1724 : 
; 1725 :             if (err==ZIP_OK) /* uncompressed size, unknown */

  00492	85 db		 test	 ebx, ebx
  00494	75 16		 jne	 SHORT $LN40@zipCloseFi

; 1726 :               err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);

  00496	6a 08		 push	 8
  00498	ff 74 24 20	 push	 DWORD PTR _compressed_size$1$[esp+44]
  0049c	57		 push	 edi
$LN81@zipCloseFi:
  0049d	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  004a0	8b ce		 mov	 ecx, esi
  004a2	e8 00 00 00 00	 call	 _zip64local_putValue
  004a7	8b d8		 mov	 ebx, eax
  004a9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN40@zipCloseFi:

; 1738 :         }
; 1739 : 
; 1740 :         if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)

  004ac	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  004af	8b ce		 mov	 ecx, esi
  004b1	6a 00		 push	 0
  004b3	ff 74 24 28	 push	 DWORD PTR _cur_pos_inzip$1$[esp+44]
  004b7	ff 74 24 1c	 push	 DWORD PTR _cur_pos_inzip$2$[esp+48]
  004bb	e8 00 00 00 00	 call	 _call_zseek64
  004c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c3	85 c0		 test	 eax, eax
  004c5	b8 ff ff ff ff	 mov	 eax, -1
  004ca	0f 45 d8	 cmovne	 ebx, eax
$LN46@zipCloseFi:

; 1741 :             err = ZIP_ERRNO;
; 1742 :     }
; 1743 : 
; 1744 :     zi->number_entry ++;

  004cd	83 86 f8 00 01
	00 01		 add	 DWORD PTR [esi+65784], 1

; 1745 :     zi->in_opened_file_inzip = 0;
; 1746 : 
; 1747 :     return err;

  004d4	8b c3		 mov	 eax, ebx

; 1748 : }

  004d6	5f		 pop	 edi
  004d7	83 96 fc 00 01
	00 00		 adc	 DWORD PTR [esi+65788], 0
  004de	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  004e5	5e		 pop	 esi
  004e6	5b		 pop	 ebx
  004e7	8b e5		 mov	 esp, ebp
  004e9	5d		 pop	 ebp
  004ea	c2 10 00	 ret	 16			; 00000010H
_zipCloseFileInZipRaw64@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipCloseFileInZip@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_zipCloseFileInZip@4 PROC				; COMDAT

; 1751 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1752 :     return zipCloseFileInZipRaw (file,0,0);

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR _file$[ebp]
  0000a	e8 00 00 00 00	 call	 _zipCloseFileInZipRaw@12

; 1753 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
_zipCloseFileInZip@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _Write_Zip64EndOfCentralDirectoryLocator
_TEXT	SEGMENT
_zip64eocd_pos_inzip$ = 8				; size = 8
_Write_Zip64EndOfCentralDirectoryLocator PROC		; COMDAT
; _zi$ = ecx

; 1756 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1757 :   int err = ZIP_OK;
; 1758 :   ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writting_offset;

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _zip64eocd_pos_inzip$[ebp+4]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 08	 mov	 edi, DWORD PTR _zip64eocd_pos_inzip$[ebp]
  0000c	8b f1		 mov	 esi, ecx

; 1759 : 
; 1760 :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);

  0000e	6a 04		 push	 4
  00010	6a 00		 push	 0
  00012	68 50 4b 06 07	 push	 117853008		; 07064b50H
  00017	2b be f0 00 01
	00		 sub	 edi, DWORD PTR [esi+65776]
  0001d	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00020	1b 9e f4 00 01
	00		 sbb	 ebx, DWORD PTR [esi+65780]
  00026	e8 00 00 00 00	 call	 _zip64local_putValue
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1761 : 
; 1762 :   /*num disks*/
; 1763 :     if (err==ZIP_OK) /* number of the disk with the start of the central directory */

  0002e	85 c0		 test	 eax, eax
  00030	75 3c		 jne	 SHORT $LN4@Write_Zip6

; 1764 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);

  00032	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00035	8b ce		 mov	 ecx, esi
  00037	6a 04		 push	 4
  00039	50		 push	 eax
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _zip64local_putValue
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1765 : 
; 1766 :   /*relative offset*/
; 1767 :     if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */

  00043	85 c0		 test	 eax, eax
  00045	75 27		 jne	 SHORT $LN4@Write_Zip6

; 1768 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);

  00047	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0004a	8b ce		 mov	 ecx, esi
  0004c	6a 08		 push	 8
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 _zip64local_putValue
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1769 : 
; 1770 :   /*total disks*/ /* Do not support spawning of disk so always say 1 here*/
; 1771 :     if (err==ZIP_OK) /* number of the disk with the start of the central directory */

  00058	85 c0		 test	 eax, eax
  0005a	75 12		 jne	 SHORT $LN4@Write_Zip6

; 1772 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);

  0005c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0005f	8b ce		 mov	 ecx, esi
  00061	6a 04		 push	 4
  00063	50		 push	 eax
  00064	6a 01		 push	 1
  00066	e8 00 00 00 00	 call	 _zip64local_putValue
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@Write_Zip6:

; 1773 : 
; 1774 :     return err;
; 1775 : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_Write_Zip64EndOfCentralDirectoryLocator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _Write_Zip64EndOfCentralDirectoryRecord
_TEXT	SEGMENT
_centraldir_pos_inzip$ = 8				; size = 8
_Write_Zip64EndOfCentralDirectoryRecord PROC		; COMDAT
; _zi$ = ecx
; _size_centraldir$ = edx

; 1778 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx
  00007	8b fa		 mov	 edi, edx

; 1779 :   int err = ZIP_OK;
; 1780 : 
; 1781 :   uLong Zip64DataSize = 44;
; 1782 : 
; 1783 :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);

  00009	6a 04		 push	 4
  0000b	6a 00		 push	 0
  0000d	68 50 4b 06 06	 push	 101075792		; 06064b50H
  00012	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00015	e8 00 00 00 00	 call	 _zip64local_putValue
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1784 : 
; 1785 :   if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */

  0001d	85 c0		 test	 eax, eax
  0001f	0f 85 f2 00 00
	00		 jne	 $LN10@Write_Zip6

; 1786 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); // why ZPOS64_T of this ?

  00025	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00028	8b ce		 mov	 ecx, esi
  0002a	6a 08		 push	 8
  0002c	50		 push	 eax
  0002d	6a 2c		 push	 44			; 0000002cH
  0002f	e8 00 00 00 00	 call	 _zip64local_putValue
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1787 : 
; 1788 :   if (err==ZIP_OK) /* version made by */

  00037	85 c0		 test	 eax, eax
  00039	0f 85 d8 00 00
	00		 jne	 $LN10@Write_Zip6

; 1789 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);

  0003f	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00042	8b ce		 mov	 ecx, esi
  00044	6a 02		 push	 2
  00046	50		 push	 eax
  00047	6a 2d		 push	 45			; 0000002dH
  00049	e8 00 00 00 00	 call	 _zip64local_putValue
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1790 : 
; 1791 :   if (err==ZIP_OK) /* version needed */

  00051	85 c0		 test	 eax, eax
  00053	0f 85 be 00 00
	00		 jne	 $LN10@Write_Zip6

; 1792 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);

  00059	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0005c	8b ce		 mov	 ecx, esi
  0005e	6a 02		 push	 2
  00060	50		 push	 eax
  00061	6a 2d		 push	 45			; 0000002dH
  00063	e8 00 00 00 00	 call	 _zip64local_putValue
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1793 : 
; 1794 :   if (err==ZIP_OK) /* number of this disk */

  0006b	85 c0		 test	 eax, eax
  0006d	0f 85 a4 00 00
	00		 jne	 $LN10@Write_Zip6

; 1795 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);

  00073	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00076	8b ce		 mov	 ecx, esi
  00078	6a 04		 push	 4
  0007a	50		 push	 eax
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _zip64local_putValue
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1796 : 
; 1797 :   if (err==ZIP_OK) /* number of the disk with the start of the central directory */

  00084	85 c0		 test	 eax, eax
  00086	0f 85 8b 00 00
	00		 jne	 $LN10@Write_Zip6

; 1798 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);

  0008c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0008f	8b ce		 mov	 ecx, esi
  00091	6a 04		 push	 4
  00093	50		 push	 eax
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _zip64local_putValue
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1799 : 
; 1800 :   if (err==ZIP_OK) /* total number of entries in the central dir on this disk */

  0009d	85 c0		 test	 eax, eax
  0009f	75 76		 jne	 SHORT $LN10@Write_Zip6

; 1801 :     err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);

  000a1	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000a4	8b ce		 mov	 ecx, esi
  000a6	6a 08		 push	 8
  000a8	ff b6 fc 00 01
	00		 push	 DWORD PTR [esi+65788]
  000ae	ff b6 f8 00 01
	00		 push	 DWORD PTR [esi+65784]
  000b4	e8 00 00 00 00	 call	 _zip64local_putValue
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1802 : 
; 1803 :   if (err==ZIP_OK) /* total number of entries in the central dir */

  000bc	85 c0		 test	 eax, eax
  000be	75 57		 jne	 SHORT $LN10@Write_Zip6

; 1804 :     err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);

  000c0	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000c3	8b ce		 mov	 ecx, esi
  000c5	6a 08		 push	 8
  000c7	ff b6 fc 00 01
	00		 push	 DWORD PTR [esi+65788]
  000cd	ff b6 f8 00 01
	00		 push	 DWORD PTR [esi+65784]
  000d3	e8 00 00 00 00	 call	 _zip64local_putValue
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1805 : 
; 1806 :   if (err==ZIP_OK) /* size of the central directory */

  000db	85 c0		 test	 eax, eax
  000dd	75 38		 jne	 SHORT $LN10@Write_Zip6

; 1807 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);

  000df	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000e2	8b ce		 mov	 ecx, esi
  000e4	6a 08		 push	 8
  000e6	50		 push	 eax
  000e7	57		 push	 edi
  000e8	e8 00 00 00 00	 call	 _zip64local_putValue
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1808 : 
; 1809 :   if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */

  000f0	85 c0		 test	 eax, eax
  000f2	75 23		 jne	 SHORT $LN10@Write_Zip6

; 1810 :   {
; 1811 :     ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;

  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _centraldir_pos_inzip$[ebp]
  000f7	2b 8e f0 00 01
	00		 sub	 ecx, DWORD PTR [esi+65776]
  000fd	8b 45 0c	 mov	 eax, DWORD PTR _centraldir_pos_inzip$[ebp+4]
  00100	1b 86 f4 00 01
	00		 sbb	 eax, DWORD PTR [esi+65780]

; 1812 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);

  00106	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00109	6a 08		 push	 8
  0010b	50		 push	 eax
  0010c	51		 push	 ecx
  0010d	8b ce		 mov	 ecx, esi
  0010f	e8 00 00 00 00	 call	 _zip64local_putValue
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@Write_Zip6:

; 1813 :   }
; 1814 :   return err;
; 1815 : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
_Write_Zip64EndOfCentralDirectoryRecord ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _Write_EndOfCentralDirectoryRecord
_TEXT	SEGMENT
tv191 = -8						; size = 8
_centraldir_pos_inzip$ = 8				; size = 8
_Write_EndOfCentralDirectoryRecord PROC			; COMDAT
; _zi$ = ecx
; _size_centraldir$ = edx

; 1817 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b fa		 mov	 edi, edx

; 1818 :   int err = ZIP_OK;
; 1819 : 
; 1820 :   /*signature*/
; 1821 :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);

  0000c	6a 04		 push	 4
  0000e	6a 00		 push	 0
  00010	68 50 4b 05 06	 push	 101010256		; 06054b50H
  00015	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00018	e8 00 00 00 00	 call	 _zip64local_putValue
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1822 : 
; 1823 :   if (err==ZIP_OK) /* number of this disk */

  00020	85 c0		 test	 eax, eax
  00022	0f 85 0c 01 00
	00		 jne	 $LN13@Write_EndO

; 1824 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);

  00028	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0002b	8b ce		 mov	 ecx, esi
  0002d	6a 02		 push	 2
  0002f	50		 push	 eax
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _zip64local_putValue
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1825 : 
; 1826 :   if (err==ZIP_OK) /* number of the disk with the start of the central directory */

  00039	85 c0		 test	 eax, eax
  0003b	0f 85 f3 00 00
	00		 jne	 $LN13@Write_EndO

; 1827 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);

  00041	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00044	8b ce		 mov	 ecx, esi
  00046	6a 02		 push	 2
  00048	50		 push	 eax
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _zip64local_putValue
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1828 : 
; 1829 :   if (err==ZIP_OK) /* total number of entries in the central dir on this disk */

  00052	85 c0		 test	 eax, eax
  00054	0f 85 da 00 00
	00		 jne	 $LN13@Write_EndO

; 1830 :   {
; 1831 :     {
; 1832 :       if(zi->number_entry >= 0xFFFF)

  0005a	39 86 fc 00 01
	00		 cmp	 DWORD PTR [esi+65788], eax
  00060	77 17		 ja	 SHORT $LN15@Write_EndO
  00062	81 be f8 00 01
	00 ff ff 00 00	 cmp	 DWORD PTR [esi+65784], 65535 ; 0000ffffH
  0006c	73 0b		 jae	 SHORT $LN15@Write_EndO

; 1834 :       else
; 1835 :         err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);

  0006e	6a 02		 push	 2
  00070	50		 push	 eax
  00071	ff b6 f8 00 01
	00		 push	 DWORD PTR [esi+65784]
  00077	eb 09		 jmp	 SHORT $LN24@Write_EndO
$LN15@Write_EndO:

; 1833 :         err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record

  00079	6a 02		 push	 2
  0007b	6a 00		 push	 0
  0007d	68 ff ff 00 00	 push	 65535			; 0000ffffH
$LN24@Write_EndO:
  00082	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00085	8b ce		 mov	 ecx, esi
  00087	e8 00 00 00 00	 call	 _zip64local_putValue
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1836 :     }
; 1837 :   }
; 1838 : 
; 1839 :   if (err==ZIP_OK) /* total number of entries in the central dir */

  0008f	85 c0		 test	 eax, eax
  00091	0f 85 9d 00 00
	00		 jne	 $LN13@Write_EndO

; 1840 :   {
; 1841 :     if(zi->number_entry >= 0xFFFF)

  00097	39 86 fc 00 01
	00		 cmp	 DWORD PTR [esi+65788], eax
  0009d	77 17		 ja	 SHORT $LN16@Write_EndO
  0009f	81 be f8 00 01
	00 ff ff 00 00	 cmp	 DWORD PTR [esi+65784], 65535 ; 0000ffffH
  000a9	73 0b		 jae	 SHORT $LN16@Write_EndO

; 1843 :     else
; 1844 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);

  000ab	6a 02		 push	 2
  000ad	50		 push	 eax
  000ae	ff b6 f8 00 01
	00		 push	 DWORD PTR [esi+65784]
  000b4	eb 09		 jmp	 SHORT $LN25@Write_EndO
$LN16@Write_EndO:

; 1842 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record

  000b6	6a 02		 push	 2
  000b8	6a 00		 push	 0
  000ba	68 ff ff 00 00	 push	 65535			; 0000ffffH
$LN25@Write_EndO:
  000bf	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000c2	8b ce		 mov	 ecx, esi
  000c4	e8 00 00 00 00	 call	 _zip64local_putValue
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1845 :   }
; 1846 : 
; 1847 :   if (err==ZIP_OK) /* size of the central directory */

  000cc	85 c0		 test	 eax, eax
  000ce	75 64		 jne	 SHORT $LN13@Write_EndO

; 1848 :     err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);

  000d0	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000d3	8b ce		 mov	 ecx, esi
  000d5	6a 04		 push	 4
  000d7	50		 push	 eax
  000d8	57		 push	 edi
  000d9	e8 00 00 00 00	 call	 _zip64local_putValue
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1849 : 
; 1850 :   if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */

  000e1	85 c0		 test	 eax, eax
  000e3	75 4f		 jne	 SHORT $LN13@Write_EndO

; 1851 :   {
; 1852 :     ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;

  000e5	8b 55 08	 mov	 edx, DWORD PTR _centraldir_pos_inzip$[ebp]
  000e8	8b ca		 mov	 ecx, edx
  000ea	2b 8e f0 00 01
	00		 sub	 ecx, DWORD PTR [esi+65776]
  000f0	8b 45 0c	 mov	 eax, DWORD PTR _centraldir_pos_inzip$[ebp+4]
  000f3	1b 86 f4 00 01
	00		 sbb	 eax, DWORD PTR [esi+65780]

; 1853 :     if(pos >= 0xffffffff)

  000f9	89 45 fc	 mov	 DWORD PTR tv191[ebp+4], eax
  000fc	75 23		 jne	 SHORT $LN17@Write_EndO
  000fe	83 f9 ff	 cmp	 ecx, -1
  00101	73 1e		 jae	 SHORT $LN17@Write_EndO

; 1856 :     }
; 1857 :     else
; 1858 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);

  00103	2b 96 f0 00 01
	00		 sub	 edx, DWORD PTR [esi+65776]
  00109	8b ce		 mov	 ecx, esi
  0010b	6a 04		 push	 4
  0010d	6a 00		 push	 0
  0010f	52		 push	 edx
  00110	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00113	e8 00 00 00 00	 call	 _zip64local_putValue
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1859 :   }
; 1860 : 
; 1861 :    return err;
; 1862 : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
$LN17@Write_EndO:

; 1854 :     {
; 1855 :       err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);

  00121	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00124	8b ce		 mov	 ecx, esi
  00126	6a 04		 push	 4
  00128	6a 00		 push	 0
  0012a	6a ff		 push	 -1
  0012c	e8 00 00 00 00	 call	 _zip64local_putValue
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@Write_EndO:

; 1859 :   }
; 1860 : 
; 1861 :    return err;
; 1862 : }

  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
_Write_EndOfCentralDirectoryRecord ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _Write_GlobalComment
_TEXT	SEGMENT
_global_comment$1$ = -4					; size = 4
_Write_GlobalComment PROC				; COMDAT
; _zi$ = ecx
; _global_comment$ = edx

; 1865 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b c2		 mov	 eax, edx

; 1866 :   int err = ZIP_OK;
; 1867 :   uInt size_global_comment = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	89 45 fc	 mov	 DWORD PTR _global_comment$1$[ebp], eax
  0000d	8b d9		 mov	 ebx, ecx
  0000f	57		 push	 edi

; 1868 : 
; 1869 :   if(global_comment != NULL)

  00010	85 c0		 test	 eax, eax
  00012	74 15		 je	 SHORT $LN2@Write_Glob

; 1870 :     size_global_comment = (uInt)strlen(global_comment);

  00014	8b f0		 mov	 esi, eax
  00016	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@Write_Glob:
  00020	8a 06		 mov	 al, BYTE PTR [esi]
  00022	46		 inc	 esi
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL6@Write_Glob
  00027	2b f1		 sub	 esi, ecx
$LN2@Write_Glob:

; 1871 : 
; 1872 :   err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);

  00029	8b 53 2c	 mov	 edx, DWORD PTR [ebx+44]
  0002c	8b cb		 mov	 ecx, ebx
  0002e	6a 02		 push	 2
  00030	6a 00		 push	 0
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 _zip64local_putValue
  00038	8b f8		 mov	 edi, eax
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1873 : 
; 1874 :   if (err == ZIP_OK && size_global_comment > 0)

  0003d	85 ff		 test	 edi, edi
  0003f	75 1e		 jne	 SHORT $LN7@Write_Glob
  00041	85 f6		 test	 esi, esi
  00043	74 1a		 je	 SHORT $LN7@Write_Glob

; 1875 :   {
; 1876 :     if (ZWRITE64(zi->z_filefunc,zi->filestream, global_comment, size_global_comment) != size_global_comment)

  00045	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00048	56		 push	 esi
  00049	ff 75 fc	 push	 DWORD PTR _global_comment$1$[ebp]
  0004c	ff 73 2c	 push	 DWORD PTR [ebx+44]
  0004f	ff 73 1c	 push	 DWORD PTR [ebx+28]
  00052	ff d1		 call	 ecx
  00054	83 c9 ff	 or	 ecx, -1
  00057	83 c4 10	 add	 esp, 16			; 00000010H
  0005a	3b c6		 cmp	 eax, esi
  0005c	0f 45 f9	 cmovne	 edi, ecx
$LN7@Write_Glob:

; 1877 :       err = ZIP_ERRNO;
; 1878 :   }
; 1879 :   return err;

  0005f	8b c7		 mov	 eax, edi

; 1880 : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_Write_GlobalComment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\contrib\minizip\zip.c
;	COMDAT _zipClose@8
_TEXT	SEGMENT
_size_centraldir$1$ = -16				; size = 4
_err$1$ = -12						; size = 4
_centraldir_pos_inzip$2$ = -8				; size = 4
_centraldir_pos_inzip$1$ = -4				; size = 4
_file$ = 8						; size = 4
_global_comment$ = 12					; size = 4
_zipClose@8 PROC					; COMDAT

; 1883 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1884 :     zip64_internal* zi;
; 1885 :     int err = 0;
; 1886 :     uLong size_centraldir = 0;
; 1887 :     ZPOS64_T centraldir_pos_inzip;
; 1888 :     ZPOS64_T pos;
; 1889 : 
; 1890 :     if (file == NULL)

  0000b	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000e	33 db		 xor	 ebx, ebx
  00010	89 5c 24 10	 mov	 DWORD PTR _err$1$[esp+28], ebx
  00014	89 5c 24 0c	 mov	 DWORD PTR _size_centraldir$1$[esp+28], ebx
  00018	57		 push	 edi
  00019	85 f6		 test	 esi, esi
  0001b	75 0c		 jne	 SHORT $LN4@zipClose

; 1891 :         return ZIP_PARAMERROR;

  0001d	8d 43 9a	 lea	 eax, DWORD PTR [ebx-102]

; 1949 : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN4@zipClose:

; 1892 : 
; 1893 :     zi = (zip64_internal*)file;
; 1894 : 
; 1895 :     if (zi->in_opened_file_inzip == 1)

  00029	83 7e 38 01	 cmp	 DWORD PTR [esi+56], 1
  0002d	75 0c		 jne	 SHORT $LN5@zipClose

; 1896 :     {
; 1897 :         err = zipCloseFileInZip (file);

  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 _zipCloseFileInZip@4
  00035	8b d8		 mov	 ebx, eax
  00037	89 44 24 14	 mov	 DWORD PTR _err$1$[esp+32], eax
$LN5@zipClose:

; 1898 :     }
; 1899 : 
; 1900 : #ifndef NO_ADDFILEINEXISTINGZIP
; 1901 :     if (global_comment==NULL)

  0003b	83 7d 0c 00	 cmp	 DWORD PTR _global_comment$[ebp], 0
  0003f	75 09		 jne	 SHORT $LN6@zipClose

; 1902 :         global_comment = zi->globalcomment;

  00041	8b 86 00 01 01
	00		 mov	 eax, DWORD PTR [esi+65792]
  00047	89 45 0c	 mov	 DWORD PTR _global_comment$[ebp], eax
$LN6@zipClose:

; 1903 : #endif
; 1904 : 
; 1905 :     centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);

  0004a	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 _call_ztell64
  00054	89 44 24 18	 mov	 DWORD PTR _centraldir_pos_inzip$2$[esp+32], eax
  00058	89 54 24 1c	 mov	 DWORD PTR _centraldir_pos_inzip$1$[esp+32], edx

; 1906 : 
; 1907 :     if (err==ZIP_OK)

  0005c	85 db		 test	 ebx, ebx
  0005e	75 4e		 jne	 SHORT $LN3@zipClose

; 1908 :     {
; 1909 :         linkedlist_datablock_internal* ldi = zi->central_dir.first_block;

  00060	8b 7e 30	 mov	 edi, DWORD PTR [esi+48]

; 1910 :         while (ldi!=NULL)

  00063	85 ff		 test	 edi, edi
  00065	74 47		 je	 SHORT $LN3@zipClose
  00067	33 c0		 xor	 eax, eax
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@zipClose:

; 1911 :         {
; 1912 :             if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))

  00070	85 db		 test	 ebx, ebx
  00072	75 29		 jne	 SHORT $LN9@zipClose
  00074	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00077	85 c0		 test	 eax, eax
  00079	74 1e		 je	 SHORT $LN25@zipClose

; 1913 :             {
; 1914 :                 if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)

  0007b	50		 push	 eax
  0007c	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  0007f	50		 push	 eax
  00080	ff 76 2c	 push	 DWORD PTR [esi+44]
  00083	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00086	ff 76 1c	 push	 DWORD PTR [esi+28]
  00089	ff d0		 call	 eax
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00091	b8 ff ff ff ff	 mov	 eax, -1
  00096	0f 45 d8	 cmovne	 ebx, eax
$LN25@zipClose:
  00099	8b 44 24 10	 mov	 eax, DWORD PTR _size_centraldir$1$[esp+32]
$LN9@zipClose:

; 1915 :                     err = ZIP_ERRNO;
; 1916 :             }
; 1917 : 
; 1918 :             size_centraldir += ldi->filled_in_this_block;

  0009d	03 47 08	 add	 eax, DWORD PTR [edi+8]

; 1919 :             ldi = ldi->next_datablock;

  000a0	8b 3f		 mov	 edi, DWORD PTR [edi]
  000a2	89 44 24 10	 mov	 DWORD PTR _size_centraldir$1$[esp+32], eax
  000a6	85 ff		 test	 edi, edi
  000a8	75 c6		 jne	 SHORT $LL2@zipClose
  000aa	89 5c 24 14	 mov	 DWORD PTR _err$1$[esp+32], ebx
$LN3@zipClose:

; 1920 :         }
; 1921 :     }
; 1922 :     free_linkedlist(&(zi->central_dir));

  000ae	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  000b1	e8 00 00 00 00	 call	 _free_linkedlist

; 1923 : 
; 1924 :     pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;

  000b6	8b 54 24 18	 mov	 edx, DWORD PTR _centraldir_pos_inzip$2$[esp+32]
  000ba	8b ca		 mov	 ecx, edx
  000bc	2b 8e f0 00 01
	00		 sub	 ecx, DWORD PTR [esi+65776]
  000c2	8b 7c 24 1c	 mov	 edi, DWORD PTR _centraldir_pos_inzip$1$[esp+32]
  000c6	8b c7		 mov	 eax, edi
  000c8	1b 86 f4 00 01
	00		 sbb	 eax, DWORD PTR [esi+65780]

; 1925 :     if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)

  000ce	85 c0		 test	 eax, eax
  000d0	77 1c		 ja	 SHORT $LN24@zipClose
  000d2	72 05		 jb	 SHORT $LN23@zipClose
  000d4	83 f9 ff	 cmp	 ecx, -1
  000d7	73 15		 jae	 SHORT $LN24@zipClose
$LN23@zipClose:
  000d9	83 be fc 00 01
	00 00		 cmp	 DWORD PTR [esi+65788], 0
  000e0	77 0c		 ja	 SHORT $LN24@zipClose
  000e2	81 be f8 00 01
	00 ff ff 00 00	 cmp	 DWORD PTR [esi+65784], 65535 ; 0000ffffH
  000ec	76 39		 jbe	 SHORT $LN10@zipClose
$LN24@zipClose:

; 1926 :     {
; 1927 :       ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);

  000ee	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  000f1	8b ce		 mov	 ecx, esi
  000f3	e8 00 00 00 00	 call	 _call_ztell64

; 1928 :       Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

  000f8	ff 74 24 1c	 push	 DWORD PTR _centraldir_pos_inzip$1$[esp+32]
  000fc	8b fa		 mov	 edi, edx
  000fe	8b ce		 mov	 ecx, esi
  00100	ff 74 24 1c	 push	 DWORD PTR _centraldir_pos_inzip$2$[esp+36]
  00104	8b 54 24 18	 mov	 edx, DWORD PTR _size_centraldir$1$[esp+40]
  00108	8b d8		 mov	 ebx, eax
  0010a	e8 00 00 00 00	 call	 _Write_Zip64EndOfCentralDirectoryRecord

; 1929 : 
; 1930 :       Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);

  0010f	57		 push	 edi
  00110	53		 push	 ebx
  00111	8b ce		 mov	 ecx, esi
  00113	e8 00 00 00 00	 call	 _Write_Zip64EndOfCentralDirectoryLocator
  00118	8b 5c 24 24	 mov	 ebx, DWORD PTR _err$1$[esp+48]
  0011c	83 c4 10	 add	 esp, 16			; 00000010H
  0011f	8b 54 24 18	 mov	 edx, DWORD PTR _centraldir_pos_inzip$2$[esp+32]
  00123	8b 7c 24 1c	 mov	 edi, DWORD PTR _centraldir_pos_inzip$1$[esp+32]
$LN10@zipClose:

; 1931 :     }
; 1932 : 
; 1933 :     if (err==ZIP_OK)

  00127	85 db		 test	 ebx, ebx
  00129	75 22		 jne	 SHORT $LN13@zipClose

; 1934 :       err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

  0012b	57		 push	 edi
  0012c	52		 push	 edx
  0012d	8b 54 24 18	 mov	 edx, DWORD PTR _size_centraldir$1$[esp+40]
  00131	8b ce		 mov	 ecx, esi
  00133	e8 00 00 00 00	 call	 _Write_EndOfCentralDirectoryRecord
  00138	8b d8		 mov	 ebx, eax
  0013a	83 c4 08	 add	 esp, 8

; 1935 : 
; 1936 :     if(err == ZIP_OK)

  0013d	85 db		 test	 ebx, ebx
  0013f	75 0c		 jne	 SHORT $LN13@zipClose

; 1937 :       err = Write_GlobalComment(zi, global_comment);

  00141	8b 55 0c	 mov	 edx, DWORD PTR _global_comment$[ebp]
  00144	8b ce		 mov	 ecx, esi
  00146	e8 00 00 00 00	 call	 _Write_GlobalComment
  0014b	8b d8		 mov	 ebx, eax
$LN13@zipClose:

; 1938 : 
; 1939 :     if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0)

  0014d	ff 76 2c	 push	 DWORD PTR [esi+44]
  00150	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00153	ff 76 1c	 push	 DWORD PTR [esi+28]
  00156	ff d0		 call	 eax
  00158	83 c4 08	 add	 esp, 8
  0015b	85 c0		 test	 eax, eax
  0015d	74 0a		 je	 SHORT $LN15@zipClose

; 1940 :         if (err == ZIP_OK)

  0015f	85 db		 test	 ebx, ebx
  00161	b8 ff ff ff ff	 mov	 eax, -1
  00166	0f 44 d8	 cmove	 ebx, eax
$LN15@zipClose:

; 1941 :             err = ZIP_ERRNO;
; 1942 : 
; 1943 : #ifndef NO_ADDFILEINEXISTINGZIP
; 1944 :     TRYFREE(zi->globalcomment);

  00169	8b 86 00 01 01
	00		 mov	 eax, DWORD PTR [esi+65792]
  0016f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  00175	85 c0		 test	 eax, eax
  00177	74 06		 je	 SHORT $LN16@zipClose
  00179	50		 push	 eax
  0017a	ff d7		 call	 edi
  0017c	83 c4 04	 add	 esp, 4
$LN16@zipClose:

; 1945 : #endif
; 1946 :     TRYFREE(zi);

  0017f	56		 push	 esi
  00180	ff d7		 call	 edi
  00182	83 c4 04	 add	 esp, 4

; 1947 : 
; 1948 :     return err;

  00185	8b c3		 mov	 eax, ebx

; 1949 : }

  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c2 08 00	 ret	 8
_zipClose@8 ENDP
_TEXT	ENDS
END
