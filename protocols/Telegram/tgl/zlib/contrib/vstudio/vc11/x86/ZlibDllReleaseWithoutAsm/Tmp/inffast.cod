; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	d:\downloads\tgl-master\tgl-master\zlib\inffast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
; Function compile flags: /Ogtp
; File d:\downloads\tgl-master\tgl-master\zlib\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
_whave$1$ = -68						; size = 4
_beg$1$ = -64						; size = 4
_end$1$ = -60						; size = 4
_last$1$ = -56						; size = 4
_window$1$ = -52					; size = 4
_wsize$1$ = -48						; size = 4
_dcode$1$ = -44						; size = 4
_lcode$1$ = -40						; size = 4
_bits$1$ = -36						; size = 4
_wnext$1$ = -32						; size = 4
_dmask$1$ = -28						; size = 4
_strm$1$ = -24						; size = 4
_lmask$1$ = -20						; size = 4
_state$1$ = -16						; size = 4
_dist$1$ = -12						; size = 4
_in$1$ = -8						; size = 4
_hold$1$ = -4						; size = 4
_inflate_fast PROC					; COMDAT
; _strm$ = ecx
; _start$ = edx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d e8	 mov	 DWORD PTR _strm$1$[ebp], edi

; 71   :     struct inflate_state FAR *state;
; 72   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 73   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 74   :     unsigned char FAR *out;     /* local strm->next_out */
; 75   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 76   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 77   : #ifdef INFLATE_STRICT
; 78   :     unsigned dmax;              /* maximum distance from zlib header */
; 79   : #endif
; 80   :     unsigned wsize;             /* window size or zero if not using window */
; 81   :     unsigned whave;             /* valid bytes in the window */
; 82   :     unsigned wnext;             /* window write index */
; 83   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 84   :     unsigned long hold;         /* local strm->hold */
; 85   :     unsigned bits;              /* local strm->bits */
; 86   :     code const FAR *lcode;      /* local strm->lencode */
; 87   :     code const FAR *dcode;      /* local strm->distcode */
; 88   :     unsigned lmask;             /* mask for first level of length codes */
; 89   :     unsigned dmask;             /* mask for first level of distance codes */
; 90   :     code here;                  /* retrieved table entry */
; 91   :     unsigned op;                /* code bits, operation, extra bits, or */
; 92   :                                 /*  window position, window bytes to copy */
; 93   :     unsigned len;               /* match length, unused bytes */
; 94   :     unsigned dist;              /* match distance */
; 95   :     unsigned char FAR *from;    /* where to copy match from */
; 96   : 
; 97   :     /* copy state to local variables */
; 98   :     state = (struct inflate_state FAR *)strm->state;

  0000e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]

; 99   :     in = strm->next_in - OFF;

  00011	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 100  :     last = in + (strm->avail_in - 5);

  00013	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00016	4b		 dec	 ebx

; 101  :     out = strm->next_out - OFF;

  00017	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0001a	83 c0 fb	 add	 eax, -5			; fffffffbH
  0001d	03 c3		 add	 eax, ebx
  0001f	89 4d f0	 mov	 DWORD PTR _state$1$[ebp], ecx
  00022	89 45 c8	 mov	 DWORD PTR _last$1$[ebp], eax
  00025	4e		 dec	 esi

; 102  :     beg = out - (start - strm->avail_out);

  00026	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00029	8b f8		 mov	 edi, eax

; 103  :     end = out + (strm->avail_out - 257);

  0002b	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  00030	89 5d f8	 mov	 DWORD PTR _in$1$[ebp], ebx
  00033	03 c6		 add	 eax, esi
  00035	2b fa		 sub	 edi, edx

; 104  : #ifdef INFLATE_STRICT
; 105  :     dmax = state->dmax;
; 106  : #endif
; 107  :     wsize = state->wsize;
; 108  :     whave = state->whave;
; 109  :     wnext = state->wnext;
; 110  :     window = state->window;
; 111  :     hold = state->hold;

  00037	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0003a	03 fe		 add	 edi, esi
  0003c	89 45 c4	 mov	 DWORD PTR _end$1$[ebp], eax
  0003f	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00042	89 45 d0	 mov	 DWORD PTR _wsize$1$[ebp], eax
  00045	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00048	89 45 bc	 mov	 DWORD PTR _whave$1$[ebp], eax
  0004b	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0004e	89 45 e0	 mov	 DWORD PTR _wnext$1$[ebp], eax
  00051	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00054	89 45 cc	 mov	 DWORD PTR _window$1$[ebp], eax

; 112  :     bits = state->bits;
; 113  :     lcode = state->lencode;

  00057	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0005a	89 45 d8	 mov	 DWORD PTR _lcode$1$[ebp], eax

; 114  :     dcode = state->distcode;

  0005d	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00060	89 45 d4	 mov	 DWORD PTR _dcode$1$[ebp], eax

; 115  :     lmask = (1U << state->lenbits) - 1;

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	89 45 ec	 mov	 DWORD PTR _lmask$1$[ebp], eax

; 116  :     dmask = (1U << state->distbits) - 1;

  0006b	89 45 e4	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0006e	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  00071	89 7d c0	 mov	 DWORD PTR _beg$1$[ebp], edi
  00074	8b 79 3c	 mov	 edi, DWORD PTR [ecx+60]
  00077	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  0007a	d3 65 ec	 shl	 DWORD PTR _lmask$1$[ebp], cl
  0007d	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00080	8b 45 e4	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00083	ff 4d ec	 dec	 DWORD PTR _lmask$1$[ebp]
  00086	d3 e0		 shl	 eax, cl
  00088	48		 dec	 eax
  00089	89 45 e4	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0008c	0f 1f 40 00	 npad	 4
$LL4@inflate_fa:

; 117  : 
; 118  :     /* decode literals and length/distances until end-of-block or not enough
; 119  :        input data or output space */
; 120  :     do {
; 121  :         if (bits < 15) {

  00090	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00093	73 1d		 jae	 SHORT $LN22@inflate_fa

; 122  :             hold += (unsigned long)(PUP(in)) << bits;

  00095	0f b6 43 01	 movzx	 eax, BYTE PTR [ebx+1]
  00099	8b cf		 mov	 ecx, edi
  0009b	d3 e0		 shl	 eax, cl

; 123  :             bits += 8;
; 124  :             hold += (unsigned long)(PUP(in)) << bits;

  0009d	83 c3 02	 add	 ebx, 2
  000a0	03 d0		 add	 edx, eax
  000a2	89 5d f8	 mov	 DWORD PTR _in$1$[ebp], ebx
  000a5	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  000a8	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  000ab	d3 e0		 shl	 eax, cl
  000ad	03 d0		 add	 edx, eax

; 125  :             bits += 8;

  000af	83 c7 10	 add	 edi, 16			; 00000010H
$LN22@inflate_fa:

; 126  :         }
; 127  :         here = lcode[hold & lmask];

  000b2	8b 45 ec	 mov	 eax, DWORD PTR _lmask$1$[ebp]
  000b5	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000b8	23 c2		 and	 eax, edx
  000ba	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]

; 128  :       dolen:
; 129  :         op = (unsigned)(here.bits);

  000bd	8b c3		 mov	 eax, ebx
  000bf	c1 e8 08	 shr	 eax, 8
  000c2	0f b6 c8	 movzx	 ecx, al

; 130  :         hold >>= op;

  000c5	d3 ea		 shr	 edx, cl

; 131  :         bits -= op;

  000c7	2b f9		 sub	 edi, ecx
  000c9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 132  :         op = (unsigned)(here.op);

  000cc	0f b6 d3	 movzx	 edx, bl

; 133  :         if (op == 0) {                          /* literal */

  000cf	84 db		 test	 bl, bl
  000d1	74 3e		 je	 SHORT $LN72@inflate_fa
$dolen$105:

; 138  :         }
; 139  :         else if (op & 16) {                     /* length base */

  000d3	f6 c2 10	 test	 dl, 16			; 00000010H
  000d6	75 44		 jne	 SHORT $LN73@inflate_fa

; 291  :             }
; 292  :         }
; 293  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000d8	f6 c2 40	 test	 dl, 64			; 00000040H
  000db	0f 85 b7 02 00
	00		 jne	 $LN52@inflate_fa

; 294  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000e1	8b ca		 mov	 ecx, edx
  000e3	c1 eb 10	 shr	 ebx, 16			; 00000010H
  000e6	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	d3 e0		 shl	 eax, cl
  000f0	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000f3	48		 dec	 eax
  000f4	23 c2		 and	 eax, edx
  000f6	03 c3		 add	 eax, ebx
  000f8	8b 1c 81	 mov	 ebx, DWORD PTR [ecx+eax*4]
  000fb	8b c3		 mov	 eax, ebx
  000fd	c1 e8 08	 shr	 eax, 8
  00100	0f b6 c8	 movzx	 ecx, al
  00103	d3 ea		 shr	 edx, cl
  00105	2b f9		 sub	 edi, ecx
  00107	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0010a	0f b6 d3	 movzx	 edx, bl
  0010d	84 db		 test	 bl, bl
  0010f	75 c2		 jne	 SHORT $dolen$105
$LN72@inflate_fa:

; 134  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 135  :                     "inflate:         literal '%c'\n" :
; 136  :                     "inflate:         literal 0x%02x\n", here.val));
; 137  :             PUP(out) = (unsigned char)(here.val);

  00111	46		 inc	 esi
  00112	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00115	88 1e		 mov	 BYTE PTR [esi], bl
  00117	e9 21 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 140  :             len = (unsigned)(here.val);

  0011c	c1 eb 10	 shr	 ebx, 16			; 00000010H

; 141  :             op &= 15;                           /* number of extra bits */

  0011f	83 e2 0f	 and	 edx, 15			; 0000000fH

; 142  :             if (op) {

  00122	74 2c		 je	 SHORT $LN27@inflate_fa

; 143  :                 if (bits < op) {

  00124	3b fa		 cmp	 edi, edx
  00126	73 14		 jae	 SHORT $LN28@inflate_fa

; 144  :                     hold += (unsigned long)(PUP(in)) << bits;

  00128	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0012b	8b cf		 mov	 ecx, edi
  0012d	40		 inc	 eax
  0012e	89 45 f8	 mov	 DWORD PTR _in$1$[ebp], eax
  00131	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00134	d3 e0		 shl	 eax, cl
  00136	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax

; 145  :                     bits += 8;

  00139	83 c7 08	 add	 edi, 8
$LN28@inflate_fa:

; 146  :                 }
; 147  :                 len += (unsigned)hold & ((1U << op) - 1);

  0013c	8b ca		 mov	 ecx, edx
  0013e	b8 01 00 00 00	 mov	 eax, 1
  00143	d3 e0		 shl	 eax, cl
  00145	48		 dec	 eax
  00146	23 45 fc	 and	 eax, DWORD PTR _hold$1$[ebp]

; 148  :                 hold >>= op;

  00149	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  0014c	03 d8		 add	 ebx, eax

; 149  :                 bits -= op;

  0014e	2b fa		 sub	 edi, edx
$LN27@inflate_fa:

; 150  :             }
; 151  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 152  :             if (bits < 15) {
; 153  :                 hold += (unsigned long)(PUP(in)) << bits;

  00150	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00153	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00156	73 24		 jae	 SHORT $LN29@inflate_fa
  00158	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0015b	8b cf		 mov	 ecx, edi
  0015d	40		 inc	 eax
  0015e	89 45 f8	 mov	 DWORD PTR _in$1$[ebp], eax
  00161	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00164	d3 e0		 shl	 eax, cl

; 154  :                 bits += 8;
; 155  :                 hold += (unsigned long)(PUP(in)) << bits;

  00166	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00169	03 d0		 add	 edx, eax
  0016b	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0016e	40		 inc	 eax
  0016f	89 45 f8	 mov	 DWORD PTR _in$1$[ebp], eax
  00172	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00175	d3 e0		 shl	 eax, cl
  00177	03 d0		 add	 edx, eax

; 156  :                 bits += 8;

  00179	83 c7 10	 add	 edi, 16			; 00000010H
$LN29@inflate_fa:

; 157  :             }
; 158  :             here = dcode[hold & dmask];

  0017c	8b 45 e4	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  0017f	8b 4d d4	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  00182	23 c2		 and	 eax, edx
  00184	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00187	89 45 f4	 mov	 DWORD PTR _dist$1$[ebp], eax

; 159  :           dodist:
; 160  :             op = (unsigned)(here.bits);

  0018a	c1 e8 08	 shr	 eax, 8
  0018d	0f b6 c8	 movzx	 ecx, al

; 161  :             hold >>= op;
; 162  :             bits -= op;
; 163  :             op = (unsigned)(here.op);

  00190	8b 45 f4	 mov	 eax, DWORD PTR _dist$1$[ebp]
  00193	2b f9		 sub	 edi, ecx
  00195	d3 ea		 shr	 edx, cl
  00197	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0019a	0f b6 d0	 movzx	 edx, al

; 164  :             if (op & 16) {                      /* distance base */

  0019d	f6 c2 10	 test	 dl, 16			; 00000010H
  001a0	75 44		 jne	 SHORT $LN74@inflate_fa
$dodist$106:

; 280  :                     }
; 281  :                 }
; 282  :             }
; 283  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001a2	f6 c2 40	 test	 dl, 64			; 00000040H
  001a5	0f 85 0f 02 00
	00		 jne	 $LN50@inflate_fa

; 284  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001ab	8b ca		 mov	 ecx, edx
  001ad	b8 01 00 00 00	 mov	 eax, 1
  001b2	8b 55 d4	 mov	 edx, DWORD PTR _dcode$1$[ebp]
  001b5	d3 e0		 shl	 eax, cl
  001b7	8b 4d f4	 mov	 ecx, DWORD PTR _dist$1$[ebp]
  001ba	48		 dec	 eax
  001bb	23 45 fc	 and	 eax, DWORD PTR _hold$1$[ebp]
  001be	c1 e9 10	 shr	 ecx, 16			; 00000010H
  001c1	03 c1		 add	 eax, ecx
  001c3	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  001c6	8b c1		 mov	 eax, ecx
  001c8	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001cb	c1 e8 08	 shr	 eax, 8
  001ce	89 4d f4	 mov	 DWORD PTR _dist$1$[ebp], ecx
  001d1	0f b6 c8	 movzx	 ecx, al
  001d4	8b 45 f4	 mov	 eax, DWORD PTR _dist$1$[ebp]
  001d7	2b f9		 sub	 edi, ecx
  001d9	d3 ea		 shr	 edx, cl
  001db	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  001de	0f b6 d0	 movzx	 edx, al
  001e1	f6 c2 10	 test	 dl, 16			; 00000010H
  001e4	74 bc		 je	 SHORT $dodist$106
$LN74@inflate_fa:

; 165  :                 dist = (unsigned)(here.val);

  001e6	c1 e8 10	 shr	 eax, 16			; 00000010H

; 166  :                 op &= 15;                       /* number of extra bits */

  001e9	83 e2 0f	 and	 edx, 15			; 0000000fH
  001ec	89 45 f4	 mov	 DWORD PTR _dist$1$[ebp], eax

; 167  :                 if (bits < op) {

  001ef	3b fa		 cmp	 edi, edx
  001f1	73 2c		 jae	 SHORT $LN33@inflate_fa

; 168  :                     hold += (unsigned long)(PUP(in)) << bits;

  001f3	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  001f6	8b cf		 mov	 ecx, edi
  001f8	40		 inc	 eax

; 169  :                     bits += 8;

  001f9	83 c7 08	 add	 edi, 8
  001fc	89 45 f8	 mov	 DWORD PTR _in$1$[ebp], eax
  001ff	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00202	d3 e0		 shl	 eax, cl
  00204	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax

; 170  :                     if (bits < op) {

  00207	3b fa		 cmp	 edi, edx
  00209	73 14		 jae	 SHORT $LN33@inflate_fa

; 171  :                         hold += (unsigned long)(PUP(in)) << bits;

  0020b	8b 45 f8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0020e	8b cf		 mov	 ecx, edi
  00210	40		 inc	 eax
  00211	89 45 f8	 mov	 DWORD PTR _in$1$[ebp], eax
  00214	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00217	d3 e0		 shl	 eax, cl
  00219	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax

; 172  :                         bits += 8;

  0021c	83 c7 08	 add	 edi, 8
$LN33@inflate_fa:

; 173  :                     }
; 174  :                 }
; 175  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0021f	8b ca		 mov	 ecx, edx
  00221	b8 01 00 00 00	 mov	 eax, 1
  00226	d3 e0		 shl	 eax, cl

; 176  : #ifdef INFLATE_STRICT
; 177  :                 if (dist > dmax) {
; 178  :                     strm->msg = (char *)"invalid distance too far back";
; 179  :                     state->mode = BAD;
; 180  :                     break;
; 181  :                 }
; 182  : #endif
; 183  :                 hold >>= op;
; 184  :                 bits -= op;

  00228	2b fa		 sub	 edi, edx
  0022a	48		 dec	 eax
  0022b	89 7d dc	 mov	 DWORD PTR _bits$1$[ebp], edi
  0022e	23 45 fc	 and	 eax, DWORD PTR _hold$1$[ebp]
  00231	01 45 f4	 add	 DWORD PTR _dist$1$[ebp], eax

; 185  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 186  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00234	8b c6		 mov	 eax, esi
  00236	2b 45 c0	 sub	 eax, DWORD PTR _beg$1$[ebp]
  00239	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl

; 187  :                 if (dist > op) {                /* see if copy from window */

  0023c	8b 55 f4	 mov	 edx, DWORD PTR _dist$1$[ebp]
  0023f	3b d0		 cmp	 edx, eax
  00241	0f 86 13 01 00
	00		 jbe	 $LN34@inflate_fa

; 188  :                     op = dist - op;             /* distance back in window */

  00247	8b ca		 mov	 ecx, edx
  00249	2b c8		 sub	 ecx, eax

; 189  :                     if (op > whave) {

  0024b	3b 4d bc	 cmp	 ecx, DWORD PTR _whave$1$[ebp]
  0024e	76 10		 jbe	 SHORT $LN37@inflate_fa

; 190  :                         if (state->sane) {

  00250	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  00253	83 b8 c0 1b 00
	00 00		 cmp	 DWORD PTR [eax+7104], 0
  0025a	0f 85 69 01 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 194  :                             break;
; 195  :                         }
; 196  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 197  :                         if (len <= op - whave) {
; 198  :                             do {
; 199  :                                 PUP(out) = 0;
; 200  :                             } while (--len);
; 201  :                             continue;
; 202  :                         }
; 203  :                         len -= op - whave;
; 204  :                         do {
; 205  :                             PUP(out) = 0;
; 206  :                         } while (--op > whave);
; 207  :                         if (op == 0) {
; 208  :                             from = out - dist;
; 209  :                             do {
; 210  :                                 PUP(out) = PUP(from);
; 211  :                             } while (--len);
; 212  :                             continue;
; 213  :                         }
; 214  : #endif
; 215  :                     }
; 216  :                     from = window - OFF;

  00260	8b 7d cc	 mov	 edi, DWORD PTR _window$1$[ebp]

; 217  :                     if (wnext == 0) {           /* very common case */

  00263	8b 45 e0	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  00266	4f		 dec	 edi
  00267	85 c0		 test	 eax, eax
  00269	75 1d		 jne	 SHORT $LN38@inflate_fa

; 218  :                         from += wsize - op;

  0026b	8b 45 d0	 mov	 eax, DWORD PTR _wsize$1$[ebp]
  0026e	2b c1		 sub	 eax, ecx
  00270	03 f8		 add	 edi, eax

; 219  :                         if (op < len) {         /* some from window */

  00272	3b cb		 cmp	 ecx, ebx
  00274	73 7c		 jae	 SHORT $LN69@inflate_fa

; 220  :                             len -= op;

  00276	2b d9		 sub	 ebx, ecx
$LL7@inflate_fa:

; 221  :                             do {
; 222  :                                 PUP(out) = PUP(from);

  00278	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0027b	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  0027e	46		 inc	 esi
  0027f	88 06		 mov	 BYTE PTR [esi], al

; 223  :                             } while (--op);

  00281	83 e9 01	 sub	 ecx, 1
  00284	75 f2		 jne	 SHORT $LL7@inflate_fa

; 224  :                             from = out - dist;  /* rest from output */
; 225  :                         }
; 226  :                     }

  00286	eb 66		 jmp	 SHORT $LN101@inflate_fa
$LN38@inflate_fa:

; 227  :                     else if (wnext < op) {      /* wrap around window */

  00288	3b c1		 cmp	 eax, ecx
  0028a	73 44		 jae	 SHORT $LN41@inflate_fa

; 228  :                         from += wsize + wnext - op;

  0028c	2b c1		 sub	 eax, ecx

; 229  :                         op -= wnext;

  0028e	2b 4d e0	 sub	 ecx, DWORD PTR _wnext$1$[ebp]
  00291	03 45 d0	 add	 eax, DWORD PTR _wsize$1$[ebp]
  00294	03 f8		 add	 edi, eax

; 230  :                         if (op < len) {         /* some from end of window */

  00296	3b cb		 cmp	 ecx, ebx
  00298	73 58		 jae	 SHORT $LN69@inflate_fa

; 231  :                             len -= op;

  0029a	2b d9		 sub	 ebx, ecx

; 234  :                             } while (--op);

  0029c	2b fe		 sub	 edi, esi
  0029e	66 90		 npad	 2
$LL10@inflate_fa:

; 232  :                             do {
; 233  :                                 PUP(out) = PUP(from);

  002a0	8a 44 37 01	 mov	 al, BYTE PTR [edi+esi+1]
  002a4	46		 inc	 esi
  002a5	88 06		 mov	 BYTE PTR [esi], al

; 234  :                             } while (--op);

  002a7	83 e9 01	 sub	 ecx, 1
  002aa	75 f4		 jne	 SHORT $LL10@inflate_fa

; 235  :                             from = window - OFF;

  002ac	8b 7d cc	 mov	 edi, DWORD PTR _window$1$[ebp]

; 236  :                             if (wnext < len) {  /* some from start of window */

  002af	8b 45 e0	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  002b2	4f		 dec	 edi
  002b3	3b c3		 cmp	 eax, ebx
  002b5	73 3b		 jae	 SHORT $LN69@inflate_fa

; 237  :                                 op = wnext;

  002b7	8b c8		 mov	 ecx, eax

; 238  :                                 len -= op;

  002b9	2b d8		 sub	 ebx, eax
  002bb	0f 1f 44 00 00	 npad	 5
$LL13@inflate_fa:

; 239  :                                 do {
; 240  :                                     PUP(out) = PUP(from);

  002c0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002c3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002c6	46		 inc	 esi
  002c7	88 06		 mov	 BYTE PTR [esi], al

; 241  :                                 } while (--op);

  002c9	83 e9 01	 sub	 ecx, 1
  002cc	75 f2		 jne	 SHORT $LL13@inflate_fa

; 242  :                                 from = out - dist;      /* rest from output */
; 243  :                             }
; 244  :                         }
; 245  :                     }

  002ce	eb 1e		 jmp	 SHORT $LN101@inflate_fa
$LN41@inflate_fa:

; 246  :                     else {                      /* contiguous in window */
; 247  :                         from += wnext - op;

  002d0	2b c1		 sub	 eax, ecx
  002d2	03 f8		 add	 edi, eax

; 248  :                         if (op < len) {         /* some from window */

  002d4	3b cb		 cmp	 ecx, ebx
  002d6	73 1a		 jae	 SHORT $LN69@inflate_fa

; 249  :                             len -= op;

  002d8	2b d9		 sub	 ebx, ecx
  002da	66 0f 1f 44 00
	00		 npad	 6
$LL16@inflate_fa:

; 250  :                             do {
; 251  :                                 PUP(out) = PUP(from);

  002e0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002e3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002e6	46		 inc	 esi
  002e7	88 06		 mov	 BYTE PTR [esi], al

; 252  :                             } while (--op);

  002e9	83 e9 01	 sub	 ecx, 1
  002ec	75 f2		 jne	 SHORT $LL16@inflate_fa
$LN101@inflate_fa:

; 253  :                             from = out - dist;  /* rest from output */

  002ee	8b fe		 mov	 edi, esi
  002f0	2b fa		 sub	 edi, edx
$LN69@inflate_fa:

; 254  :                         }
; 255  :                     }
; 256  :                     while (len > 2) {

  002f2	83 fb 02	 cmp	 ebx, 2
  002f5	76 2e		 jbe	 SHORT $LN18@inflate_fa
  002f7	8d 4b fd	 lea	 ecx, DWORD PTR [ebx-3]
  002fa	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  002ff	f7 e1		 mul	 ecx
  00301	d1 ea		 shr	 edx, 1
  00303	42		 inc	 edx
$LL17@inflate_fa:

; 257  :                         PUP(out) = PUP(from);

  00304	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]

; 258  :                         PUP(out) = PUP(from);
; 259  :                         PUP(out) = PUP(from);
; 260  :                         len -= 3;

  00308	83 eb 03	 sub	 ebx, 3
  0030b	88 46 01	 mov	 BYTE PTR [esi+1], al
  0030e	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  00312	83 c7 03	 add	 edi, 3
  00315	88 46 02	 mov	 BYTE PTR [esi+2], al
  00318	83 c6 03	 add	 esi, 3
  0031b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0031e	88 06		 mov	 BYTE PTR [esi], al
  00320	83 ea 01	 sub	 edx, 1
  00323	75 df		 jne	 SHORT $LL17@inflate_fa
$LN18@inflate_fa:

; 261  :                     }
; 262  :                     if (len) {

  00325	85 db		 test	 ebx, ebx
  00327	74 11		 je	 SHORT $LN99@inflate_fa

; 263  :                         PUP(out) = PUP(from);

  00329	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0032c	46		 inc	 esi
  0032d	88 06		 mov	 BYTE PTR [esi], al

; 264  :                         if (len > 1)

  0032f	83 fb 01	 cmp	 ebx, 1
  00332	76 06		 jbe	 SHORT $LN99@inflate_fa

; 265  :                             PUP(out) = PUP(from);

  00334	8a 47 02	 mov	 al, BYTE PTR [edi+2]
  00337	46		 inc	 esi
  00338	88 06		 mov	 BYTE PTR [esi], al
$LN99@inflate_fa:
  0033a	8b 7d dc	 mov	 edi, DWORD PTR _bits$1$[ebp]
$LN2@inflate_fa:

; 305  :             break;
; 306  :         }
; 307  :     } while (in < last && out < end);

  0033d	8b 5d f8	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00340	3b 5d c8	 cmp	 ebx, DWORD PTR _last$1$[ebp]
  00343	0f 83 93 00 00
	00		 jae	 $LN3@inflate_fa
  00349	3b 75 c4	 cmp	 esi, DWORD PTR _end$1$[ebp]
  0034c	0f 83 8a 00 00
	00		 jae	 $LN3@inflate_fa
  00352	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00355	e9 36 fd ff ff	 jmp	 $LL4@inflate_fa
$LN34@inflate_fa:

; 266  :                     }
; 267  :                 }
; 268  :                 else {
; 269  :                     from = out - dist;          /* copy direct from output */

  0035a	8b ce		 mov	 ecx, esi
  0035c	2b ca		 sub	 ecx, edx
  0035e	66 90		 npad	 2
$LL21@inflate_fa:

; 270  :                     do {                        /* minimum length is three */
; 271  :                         PUP(out) = PUP(from);

  00360	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]

; 272  :                         PUP(out) = PUP(from);
; 273  :                         PUP(out) = PUP(from);

  00364	8d 49 03	 lea	 ecx, DWORD PTR [ecx+3]
  00367	88 46 01	 mov	 BYTE PTR [esi+1], al

; 274  :                         len -= 3;

  0036a	83 eb 03	 sub	 ebx, 3
  0036d	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00371	88 46 02	 mov	 BYTE PTR [esi+2], al
  00374	83 c6 03	 add	 esi, 3
  00377	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0037a	88 06		 mov	 BYTE PTR [esi], al

; 275  :                     } while (len > 2);

  0037c	83 fb 02	 cmp	 ebx, 2
  0037f	77 df		 ja	 SHORT $LL21@inflate_fa

; 276  :                     if (len) {

  00381	85 db		 test	 ebx, ebx
  00383	74 b8		 je	 SHORT $LN2@inflate_fa

; 277  :                         PUP(out) = PUP(from);

  00385	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00388	46		 inc	 esi
  00389	88 06		 mov	 BYTE PTR [esi], al

; 278  :                         if (len > 1)

  0038b	83 fb 01	 cmp	 ebx, 1
  0038e	76 ad		 jbe	 SHORT $LN2@inflate_fa

; 279  :                             PUP(out) = PUP(from);

  00390	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00393	46		 inc	 esi
  00394	88 06		 mov	 BYTE PTR [esi], al
  00396	eb a5		 jmp	 SHORT $LN2@inflate_fa
$LN52@inflate_fa:

; 300  :             break;

  00398	8b 5d f8	 mov	 ebx, DWORD PTR _in$1$[ebp]
  0039b	f6 c2 20	 test	 dl, 32			; 00000020H
  0039e	74 0b		 je	 SHORT $LN54@inflate_fa

; 295  :             goto dolen;
; 296  :         }
; 297  :         else if (op & 32) {                     /* end-of-block */
; 298  :             Tracevv((stderr, "inflate:         end of block\n"));
; 299  :             state->mode = TYPE;

  003a0	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  003a3	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 300  :             break;

  003a9	eb 31		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 301  :         }
; 302  :         else {
; 303  :             strm->msg = (char *)"invalid literal/length code";

  003ab	8b 45 e8	 mov	 eax, DWORD PTR _strm$1$[ebp]
  003ae	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 304  :             state->mode = BAD;

  003b5	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  003b8	eb 1c		 jmp	 SHORT $LN102@inflate_fa
$LN50@inflate_fa:

; 285  :                 goto dodist;
; 286  :             }
; 287  :             else {
; 288  :                 strm->msg = (char *)"invalid distance code";

  003ba	8b 45 e8	 mov	 eax, DWORD PTR _strm$1$[ebp]
  003bd	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 289  :                 state->mode = BAD;

  003c4	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]

; 290  :                 break;

  003c7	eb 0a		 jmp	 SHORT $LN103@inflate_fa
$LN75@inflate_fa:

; 191  :                             strm->msg =

  003c9	8b 4d e8	 mov	 ecx, DWORD PTR _strm$1$[ebp]
  003cc	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
$LN103@inflate_fa:
  003d3	8b 5d f8	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN102@inflate_fa:

; 192  :                                 (char *)"invalid distance too far back";
; 193  :                             state->mode = BAD;

  003d6	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH
$LN3@inflate_fa:

; 308  : 
; 309  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 310  :     len = bits >> 3;
; 311  :     in -= len;
; 312  :     bits -= len << 3;
; 313  :     hold &= (1U << bits) - 1;
; 314  : 
; 315  :     /* update state and return */
; 316  :     strm->next_in = in + OFF;

  003dc	8b 55 e8	 mov	 edx, DWORD PTR _strm$1$[ebp]
  003df	8b c7		 mov	 eax, edi
  003e1	c1 e8 03	 shr	 eax, 3
  003e4	2b d8		 sub	 ebx, eax
  003e6	c1 e0 03	 shl	 eax, 3
  003e9	2b f8		 sub	 edi, eax
  003eb	b8 01 00 00 00	 mov	 eax, 1
  003f0	8b cf		 mov	 ecx, edi
  003f2	d3 e0		 shl	 eax, cl
  003f4	8b 4d fc	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  003f7	48		 dec	 eax
  003f8	23 c8		 and	 ecx, eax
  003fa	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  003fd	89 02		 mov	 DWORD PTR [edx], eax

; 317  :     strm->next_out = out + OFF;

  003ff	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00402	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 318  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  00405	8b 45 c8	 mov	 eax, DWORD PTR _last$1$[ebp]
  00408	2b c3		 sub	 eax, ebx
  0040a	8b da		 mov	 ebx, edx

; 319  :     strm->avail_out = (unsigned)(out < end ?

  0040c	8b 55 c4	 mov	 edx, DWORD PTR _end$1$[ebp]
  0040f	83 c0 05	 add	 eax, 5
  00412	2b d6		 sub	 edx, esi
  00414	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  0041a	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 320  :                                  257 + (end - out) : 257 - (out - end));
; 321  :     state->hold = hold;

  0041d	8b 45 f0	 mov	 eax, DWORD PTR _state$1$[ebp]
  00420	89 53 10	 mov	 DWORD PTR [ebx+16], edx

; 322  :     state->bits = bits;

  00423	89 78 3c	 mov	 DWORD PTR [eax+60], edi
  00426	5f		 pop	 edi
  00427	5e		 pop	 esi
  00428	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  0042b	5b		 pop	 ebx

; 323  :     return;
; 324  : }

  0042c	8b e5		 mov	 esp, ebp
  0042e	5d		 pop	 ebp
  0042f	c3		 ret	 0
_inflate_fast ENDP
_TEXT	ENDS
END
